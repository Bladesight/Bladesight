{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bladesight Learning centre","text":"<p>Welcome to the Bladesight Learning center . </p> <p>Bladesight is a company offering Blade Tip Timing hardware, open-source software and tutorials.</p> <p>You're probably looking for the Introduction to Blade Tip Timing Using Python tutorial. You can find it  here.</p>"},{"location":"#datasets","title":"Datasets","text":"<p>We've recently added a dataset. You can find it here . </p>"},{"location":"#about-bladesight","title":"About Bladesight","text":"<p>If you'd like to learn more about Bladesight, you can visit our   website </p>"},{"location":"#contact-me","title":"Contact me","text":"<p>I'd love to get in touch with you. You can reach me at  dawie.diamond@bladesight.com</p>"},{"location":"#newsletter","title":"Newsletter","text":"<p>If you'd like to be kept up to date with the latest developments, you can subscribe to our newsletter in the table of contents.</p>"},{"location":"bhdl/","title":"Bladesight HDL","text":"<p>Bladesight HDL (BHL) is a hardware description language (HDL) that we use to create our own hardware designs. It depends heavily on MyHDL for converting the HDL code to VHDL. It uses type annotations to infer the types of the signals and ports. It also allows you to specify your RTL blocks in a declarative way. All of this makes BHDL a concise and beautifully expressive language to write HDL code in. </p>"},{"location":"calculators/","title":"Calculators","text":"<p>Here, we provide calculators to perform certain tasks in Test and Measurement. Some of them will be basic, but most will be advanced and based on some of the research we have done.</p>"},{"location":"reference/dataset_handler/","title":"Dataset handler","text":""},{"location":"reference/dataset_handler/#bladesight.dataset_handler.BladesightDatasetDirectory","title":"<code>BladesightDatasetDirectory</code>","text":"<p>This object is used to access datasets from the  Bladesight Data bucket on S3. </p> <p>It also lists the local datasets.</p>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.BladesightDatasetDirectory--examples","title":"Examples:","text":"<p>Load a dataset into memory:</p> <pre><code>&gt;&gt;&gt; Datasets = BladesightDatasetDirectory()\n&gt;&gt;&gt; dataset = Datasets[\"data/intro_to_btt/intro_to_btt_ch02\"]\n&gt;&gt;&gt; df_table = dataset[\"table/dataset_1\"]\n</code></pre> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>class BladesightDatasetDirectory:\n    \"\"\"This object is used to access datasets from the \n    Bladesight Data bucket on S3. \n\n    It also lists the local datasets.\n\n    Examples:\n    ---------\n    Load a dataset into memory:\n\n        &gt;&gt;&gt; Datasets = BladesightDatasetDirectory()\n        &gt;&gt;&gt; dataset = Datasets[\"data/intro_to_btt/intro_to_btt_ch02\"]\n        &gt;&gt;&gt; df_table = dataset[\"table/dataset_1\"]\n    \"\"\"\n    def __init__(self):\n        self.path = get_path_to_local_bladesight()\n        self.local_datasets = [\n            self._replace_path_prefix(i) for i in get_local_datasets()\n        ]\n        self.local_datasets :  List[str] = get_local_datasets()\n        self.online_datasets : List[str] = []\n\n        self.online_loaded = False\n\n    @staticmethod\n    def _getitem_key_correct_format(key: str) -&gt; bool:\n        \"\"\"This function checks if the key is in the correct format. The key\n        should be in the format \"data/intro_to_btt/intro_to_btt_ch02\".\n\n        Args:\n            key (str): The key to check.\n\n        Returns:\n            bool: True if the key is in the correct format, False otherwise.\n\n        Examples:\n        ---------\n        Check if a key is in the correct format:\n\n            &gt;&gt;&gt; BladesightDatasetDirectory._getitem_key_correct_format(\n            ... \"data/intro_to_btt/intro_to_btt_ch02\"\n            ... )\n            True\n\n            &gt;&gt;&gt; BladesightDatasetDirectory._getitem_key_correct_format(\n            ... \"intro_to_btt/intro_to_btt_ch02\"\n            ... )\n            False\n        \"\"\"\n        if key.startswith(\"data/\"):\n            return True\n        return False\n\n    def __getitem__(self, key: str) -&gt; Dataset:\n        \"\"\"Get the dataset specified by a key. If the dataset is not found, it\n        will be downloaded from the Bladesight Data bucket.\n\n        Args:\n            key (str): The name of the dataset.\n\n        Raises:\n            KeyError: If the dataset is not found.\n\n        Returns:\n            Dataset: The dataset.\n\n        Examples:\n        ---------\n        Load a dataset into memory:\n\n            &gt;&gt;&gt; Datasets = BladesightDatasetDirectory()\n            &gt;&gt;&gt; dataset = Datasets[\"data/intro_to_btt/intro_to_btt_ch02\"]\n        \"\"\"\n        if self._getitem_key_correct_format(key) is False:\n            raise KeyError(\n                f\"Dataset {key} does not start with data/. The key should be in the format 'data/../../etc'.\"\n            )\n        for local_dataset in self.local_datasets:\n            homogenized_local_name = self._replace_path_prefix(local_dataset)\n            if key == homogenized_local_name:\n                return Dataset(self.path / pathlib.Path(local_dataset + \".db\"))\n        else:\n            # Download the dataset from the online datasets\n            if self.online_loaded is False:\n                self._refresh_available_datasets()\n                self.online_loaded = True\n            for online_set in self.online_datasets:\n                homogenized_online_name = self._replace_path_prefix(online_set)\n                if key == homogenized_online_name:\n                    download_dataset_from_bladesight_data(\n                        self._replace_path_prefix(key, BLADESIGHT_DATASETS_S3_BUCKET)\n                    )\n                    self.local_datasets = get_local_datasets()\n                    return self[key]\n\n            else:\n                raise KeyError(f\"Dataset {key} not found.\")\n\n    @staticmethod\n    def _replace_path_prefix(\n        dataset_full_path: str, replace_prefix: str = \"data\"\n    ) -&gt; str:\n        \"\"\"This function is used to replace the first path prefix with the\n            replace_prefix argument. For example, if the dataset path\n            is \"bladesight-data/intro_to_btt/intro_to_btt_ch02\", and the\n            replace_prefix is \"data\", and the path is returned as\n            \"data/intro_to_btt/intro_to_btt_ch02\".\n\n        Args:\n            dataset_full_path (str): The full path to the dataset.\n            replace_prefix (str, optional): The prefix to replace. Defaults to \"data\".\n\n        Returns:\n            str: The new path.\n\n        Examples:\n        ---------\n        Replace the first path prefix with \"data\":\n\n            &gt;&gt;&gt; _replace_path_prefix(\n            ... \"bladesight-data/intro_to_btt/intro_to_btt_ch02\", \n            ... \"data\"\n            ... )\n            \"data/intro_to_btt/intro_to_btt_ch02\"\n        \"\"\"\n        new_path = [replace_prefix] + dataset_full_path.split(\"/\")[1:]\n        return \"/\".join(new_path)\n\n    def _ipython_key_completions_(self):\n        \"\"\" \n        We replace whatever prefix is in the \n        dataset with \"data\" \n        \"\"\"\n        if self.online_loaded is False:\n            self._refresh_available_datasets()\n            self.online_loaded = True\n        local_sets_homogenized = [self._replace_path_prefix(i) for i in self.local_datasets]\n        online_sets_homogenized = [self._replace_path_prefix(i) for i in self.online_datasets]\n        composite_set = local_sets_homogenized\n        for i in online_sets_homogenized:\n            if i not in composite_set:\n                composite_set.append(i)\n        return composite_set\n\n    def _refresh_available_datasets(self):\n        \"\"\"\n        This function refreshes the local and online datasets.\n        If the online datasets cannot be read, it will only \n        list the local datasets.\n        \"\"\"\n        self.local_datasets = get_local_datasets()\n        try:\n            self.online_datasets = get_bladesight_datasets()\n        except Exception as _:\n            print(\"Could not read remote datasets. Only listing local datasets\")\n            self.online_datasets = self.local_datasets\n\n    def new_dataset(\n            self, \n            dataset_name : str, \n            exist_ok : bool = False \n        ) -&gt; Dataset:\n        \"\"\"This function creates a new dataset object.\n\n        Args:\n            dataset_name (str): The name of the dataset.\n            exist_ok (bool, optional): If True, the function will not raise an error\n                if the dataset already exists. Defaults to False.\n\n        Returns:\n            Dataset: The dataset object.\n\n        Examples:\n        ---------\n        Create a new dataset object:\n\n            &gt;&gt;&gt; Datasets = BladesightDatasetDirectory()\n            &gt;&gt;&gt; dataset = Datasets.new_dataset(\"intro_to_btt/intro_to_btt_ch02_my_dev\")\n        \"\"\"\n        if not dataset_name.startswith(\"data/\"):\n            add_prefix = \"data/\"\n        else:\n            add_prefix = \"\"\n        new_dataset_path = self.path / pathlib.Path(add_prefix + dataset_name + \".db\")\n\n        # Check if the dataset already exists\n        if new_dataset_path.exists():\n            if exist_ok:\n                return self[add_prefix + dataset_name]\n            else:\n                raise FileExistsError(f\"Dataset {dataset_name} already exists.\")\n\n        # Create a new dataset\n        pathlib.Path(new_dataset_path.parent).mkdir(parents=True, exist_ok=True)\n        with duckdb.connect(str(new_dataset_path)) as con:\n            con.execute(\"CREATE TABLE metadata (metadata_key TEXT, metadata_value TEXT);\")\n        init_citation = {\n                \"url\" : \"No citation provided in metadata table.\",\n                \"doi\" : \"No citation provided in metadata table.\",\n                \"repr\": \"No citation provided in metadata table.\"\n        }\n        _set_metadata_key(new_dataset_path, \"CITATION\", init_citation)\n        ds = Dataset(new_dataset_path)\n        self.local_datasets = get_local_datasets()\n        return ds\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.BladesightDatasetDirectory.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get the dataset specified by a key. If the dataset is not found, it will be downloaded from the Bladesight Data bucket.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the dataset.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dataset is not found.</p> <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>The dataset.</p>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.BladesightDatasetDirectory.__getitem__--examples","title":"Examples:","text":"<p>Load a dataset into memory:</p> <pre><code>&gt;&gt;&gt; Datasets = BladesightDatasetDirectory()\n&gt;&gt;&gt; dataset = Datasets[\"data/intro_to_btt/intro_to_btt_ch02\"]\n</code></pre> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Dataset:\n    \"\"\"Get the dataset specified by a key. If the dataset is not found, it\n    will be downloaded from the Bladesight Data bucket.\n\n    Args:\n        key (str): The name of the dataset.\n\n    Raises:\n        KeyError: If the dataset is not found.\n\n    Returns:\n        Dataset: The dataset.\n\n    Examples:\n    ---------\n    Load a dataset into memory:\n\n        &gt;&gt;&gt; Datasets = BladesightDatasetDirectory()\n        &gt;&gt;&gt; dataset = Datasets[\"data/intro_to_btt/intro_to_btt_ch02\"]\n    \"\"\"\n    if self._getitem_key_correct_format(key) is False:\n        raise KeyError(\n            f\"Dataset {key} does not start with data/. The key should be in the format 'data/../../etc'.\"\n        )\n    for local_dataset in self.local_datasets:\n        homogenized_local_name = self._replace_path_prefix(local_dataset)\n        if key == homogenized_local_name:\n            return Dataset(self.path / pathlib.Path(local_dataset + \".db\"))\n    else:\n        # Download the dataset from the online datasets\n        if self.online_loaded is False:\n            self._refresh_available_datasets()\n            self.online_loaded = True\n        for online_set in self.online_datasets:\n            homogenized_online_name = self._replace_path_prefix(online_set)\n            if key == homogenized_online_name:\n                download_dataset_from_bladesight_data(\n                    self._replace_path_prefix(key, BLADESIGHT_DATASETS_S3_BUCKET)\n                )\n                self.local_datasets = get_local_datasets()\n                return self[key]\n\n        else:\n            raise KeyError(f\"Dataset {key} not found.\")\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.BladesightDatasetDirectory.new_dataset","title":"<code>new_dataset(dataset_name, exist_ok=False)</code>","text":"<p>This function creates a new dataset object.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>exist_ok</code> <code>bool</code> <p>If True, the function will not raise an error if the dataset already exists. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>The dataset object.</p>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.BladesightDatasetDirectory.new_dataset--examples","title":"Examples:","text":"<p>Create a new dataset object:</p> <pre><code>&gt;&gt;&gt; Datasets = BladesightDatasetDirectory()\n&gt;&gt;&gt; dataset = Datasets.new_dataset(\"intro_to_btt/intro_to_btt_ch02_my_dev\")\n</code></pre> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def new_dataset(\n        self, \n        dataset_name : str, \n        exist_ok : bool = False \n    ) -&gt; Dataset:\n    \"\"\"This function creates a new dataset object.\n\n    Args:\n        dataset_name (str): The name of the dataset.\n        exist_ok (bool, optional): If True, the function will not raise an error\n            if the dataset already exists. Defaults to False.\n\n    Returns:\n        Dataset: The dataset object.\n\n    Examples:\n    ---------\n    Create a new dataset object:\n\n        &gt;&gt;&gt; Datasets = BladesightDatasetDirectory()\n        &gt;&gt;&gt; dataset = Datasets.new_dataset(\"intro_to_btt/intro_to_btt_ch02_my_dev\")\n    \"\"\"\n    if not dataset_name.startswith(\"data/\"):\n        add_prefix = \"data/\"\n    else:\n        add_prefix = \"\"\n    new_dataset_path = self.path / pathlib.Path(add_prefix + dataset_name + \".db\")\n\n    # Check if the dataset already exists\n    if new_dataset_path.exists():\n        if exist_ok:\n            return self[add_prefix + dataset_name]\n        else:\n            raise FileExistsError(f\"Dataset {dataset_name} already exists.\")\n\n    # Create a new dataset\n    pathlib.Path(new_dataset_path.parent).mkdir(parents=True, exist_ok=True)\n    with duckdb.connect(str(new_dataset_path)) as con:\n        con.execute(\"CREATE TABLE metadata (metadata_key TEXT, metadata_value TEXT);\")\n    init_citation = {\n            \"url\" : \"No citation provided in metadata table.\",\n            \"doi\" : \"No citation provided in metadata table.\",\n            \"repr\": \"No citation provided in metadata table.\"\n    }\n    _set_metadata_key(new_dataset_path, \"CITATION\", init_citation)\n    ds = Dataset(new_dataset_path)\n    self.local_datasets = get_local_datasets()\n    return ds\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset","title":"<code>Dataset</code>","text":"<p>This object is used to access data from a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the dataset.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n&gt;&gt;&gt; dataset.tables\n['dataset_1', 'dataset_2']\n&gt;&gt;&gt; dataset.metadata\n{\n    \"CITATION\": {\n        \"repr\": \"This is a citation\",\n        \"url\": \"https://example.com\",\n        \"doi\": \"10.1234/5678\"\n    }\n}\n&gt;&gt;&gt; df_table = dataset[\"table/dataset_1\"]\n&gt;&gt;&gt; dataset.print_citation()\n</code></pre> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>class Dataset:\n    \"\"\"This object is used to access data from a dataset.\n\n    Args:\n        path (pathlib.Path): The path to the dataset.\n\n    Examples:\n    ---------\n        &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n        &gt;&gt;&gt; dataset.tables\n        ['dataset_1', 'dataset_2']\n        &gt;&gt;&gt; dataset.metadata\n        {\n            \"CITATION\": {\n                \"repr\": \"This is a citation\",\n                \"url\": \"https://example.com\",\n                \"doi\": \"10.1234/5678\"\n            }\n        }\n        &gt;&gt;&gt; df_table = dataset[\"table/dataset_1\"]\n        &gt;&gt;&gt; dataset.print_citation()\n    \"\"\"\n    def __init__(self, path: pathlib.Path):\n        _confirm_dataset_is_valid(path)\n        self.path = path\n        self.tables: List[str] = _get_db_tables(self.path)\n        self.metadata: Dict[str, Dict] = _get_all_metadata(self.path)\n        self.print_citation()\n\n    # Create a getter and setter for the metadata.doi property\n    @property\n    def doi(self) -&gt; str:\n        \"\"\"This function returns the DOI from the metadata.\n\n        Returns:\n            str: The DOI.\n\n        Examples:\n        ---------\n            Get the DOI from the metadata.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset.doi\n            \"10.1234/5678\"\n        \"\"\"\n        return self.metadata[\"CITATION\"][\"doi\"]\n\n    def _set_citation_field(\n            self, \n            metadata_key : Literal[\"repr\", \"url\", \"doi\"], \n            new_value : str\n        ):\n        \"\"\"This function sets a metadata field in the dataset.\n\n        Args:\n            metadata_key (Literal[\"repr\", \"url\", \"doi\"]): The metadata key.\n            new_value (str): The new value.\n\n        Examples:\n        ---------\n            Set the metadata field in the dataset.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset._set_citation_field(\"doi\", \"10.1234/5678\")\n        \"\"\"\n        self.metadata[\"CITATION\"][metadata_key] = new_value\n        _set_metadata_key(self.path, \"CITATION\", self.metadata['CITATION'])\n        self.metadata: Dict[str, Dict] = _get_all_metadata(self.path)\n\n    @doi.setter\n    def doi(self, new_doi: str):\n        \"\"\"This function sets the DOI in the metadata.\n\n        Args:\n            new_doi (str): The new DOI.\n\n        Examples:\n        ---------\n            Set the DOI in the metadata.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset.doi = \"10.1234/5678\"\n        \"\"\"\n        self._set_citation_field(\"doi\", new_doi)\n\n    @property\n    def url(self) -&gt; str:\n        \"\"\"This function returns the URL from the metadata.\n\n        Returns:\n            str: The URL.\n\n        Examples:\n        ---------\n            Get the URL from the metadata.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset.url\n            \"https://example.com\"\n        \"\"\"\n        return self.metadata[\"CITATION\"][\"url\"]\n\n    @url.setter\n    def url(self, new_url: str):\n        \"\"\"This function sets the URL in the metadata.\n\n        Args:\n            new_url (str): The new URL.\n\n        Examples:\n        ---------\n            Set the URL in the metadata.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset.url = \"https://example.com\"\n        \"\"\"\n        self._set_citation_field(\"url\", new_url)\n\n    @property\n    def citation(self) -&gt; str:\n        \"\"\"This function returns the citation from the metadata.\n        This is syntactic sugar for the repr field in the CITATION.\n\n        Returns:\n            str: The citation.\n\n        Examples:\n        ---------\n            Get the citation from the metadata.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset.citation\n            \"This is a citation\\nLink to paper: https://example.com\\nDOI: 10.1234/5678\"\n        \"\"\"\n        return self.metadata[\"CITATION\"][\"repr\"]\n\n    @citation.setter\n    def citation(self, new_citation: str):\n        \"\"\"This function sets the citation in the metadata.\n        This is syntactic sugar for the repr field in the CITATION.\n\n        Args:\n            new_citation (str): The new citation.\n\n        Examples:\n        ---------\n            Set the citation in the metadata.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset.citation = \"This is a citation\"\n        \"\"\"\n        self._set_citation_field(\"repr\", new_citation)\n\n\n    @property\n    def license(self) -&gt; str:\n        \"\"\"This function returns the license from the metadata.\n\n        Returns:\n            str: The license.\n\n        Examples:\n        ---------\n            Get the license from the metadata.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset.license\n            \"CC BY 4.0\"\n        \"\"\"\n        return self.metadata[\"license\"]\n\n    @license.setter\n    def license(self, new_license: str):\n        \"\"\"This function sets the license in the metadata.\n\n        Args:\n            new_license (str): The new license.\n\n        Examples:\n        ---------\n            Set the license in the metadata.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset.license = \"CC BY 4.0\"\n        \"\"\"\n        self._set_citation_field(\"license\", new_license)\n\n    def query(\n            self, \n            sql_query: str, \n            df_in_memory : Optional[Union[pd.DataFrame, pl.DataFrame]] = None,\n            no_return : bool = False\n        ) -&gt; Union[pd.DataFrame, pl.DataFrame]:\n        \"\"\"This function executes a SQL query on the dataset\n        and returns its result as a pandas or polars DataFrame.\n\n        Args:\n            sql_query (str): The SQL query to execute.\n            df_in_memory (Optional[Union[pd.DataFrame, pl.DataFrame]], optional):\n                An in-memory DataFrame to pass through to the query statement.\n                Defaults to None.\n            no_return (bool, optional): If True, the query will not return a DataFrame.\n                Use this with custom create statements.\n\n        Returns:\n            Union[pd.DataFrame, pl.DataFrame]: The results of the query.\n\n        Examples:\n        ---------\n            Query a dataset using SQL.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; df = dataset.query(\"SELECT * FROM table_1;\")\n        \"\"\"\n        if df_in_memory is not None:\n            if not isinstance(df_in_memory, (pd.DataFrame, pl.DataFrame)):\n                raise ValueError(\"df_in_memory must be a pandas or polars DataFrame\")\n            return _execute_sql_with_arg(\n                self.path, \n                sql_query, \n                df_in_memory, \n                return_mode=_get_dataframe_library_preference() if not no_return else \"no_return\"\n            )\n        return _execute_sql_without_arg(\n            self.path, \n            sql_query, \n            return_mode=_get_dataframe_library_preference() if not no_return else \"no_return\"\n        )\n\n    def __getitem__(self, key: str) -&gt; Union[pd.DataFrame, pl.DataFrame]:\n        \"\"\" This function returns a table from the dataset.\n\n        Args:\n            key (str): The name of the table, prefixed with \"table/\".\n\n        Raises:\n            KeyError: If the table is not found.\n\n        Returns:\n            Union[pd.DataFrame, pl.DataFrame]: The table.\n\n        Examples:\n        ---------\n            Load a table from the dataset into memory:\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; df_table = dataset[\"table/dataset_1\"]\n        \"\"\"\n        table_name = key.replace(\"table/\", \"\")\n        if table_name in self.tables:\n            return _execute_sql_without_arg(\n                self.path,\n                f\"SELECT * FROM {table_name};\", \n                return_mode=_get_dataframe_library_preference()\n            )\n        else:\n            raise KeyError(\n                f\"Table {table_name} not found. These are the tables in the dataset: {self.tables}\"\n            )\n\n    def print_citation(self):\n        \"\"\"Print the citation provided in the metadata table.\"\"\"\n        print(_get_printable_citation(self.metadata))\n\n    def _ipython_key_completions_(self):\n        return [\"table/\" + i for i in self.tables]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Show the dataset and its tables.\n\n        Returns:\n            str: The dataset and its tables in a string.\n        \"\"\"\n        table_string = \"[\\n\"\n        for table in self.tables:\n            table_string += f\"\\t'table/{table}',\\n \"\n        table_string += \"]\"\n        return f\"Dataset({self.path}),\\n\\n Tables: \\n {table_string}\"\n\n    def __setitem__(self, key: str, df: Union[pd.DataFrame, pl.DataFrame]):\n        \"\"\"This function sets a table in the dataset.\n\n        Args:\n            key (str): The name of the table.\n            df (Union[pd.DataFrame, pl.DataFrame]): The table.\n\n        Examples:\n        ---------\n            Set a table in the dataset.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n            &gt;&gt;&gt; dataset[\"table/my_table\"] = df\n        \"\"\"\n        if not isinstance(df, (pd.DataFrame, pl.DataFrame)):\n            raise ValueError(\"df must be a pandas or polars DataFrame\")\n        table_name = key.replace(\"table/\", \"\")\n        if table_name in self.tables:\n            raise ValueError(\n                f\"\"\"Table {table_name} already exists in the dataset. \"\"\"\n                \"\"\"\\nIf you want to overwrite this table, use the .drop_table method to drop\"\"\"\n                \"\"\"it first.\"\"\"\n            )\n        _execute_sql_with_arg(\n            self.path,\n            f\"CREATE OR REPLACE TABLE {table_name} AS SELECT * FROM df\",\n            df,\n            return_mode=\"no_return\"\n        )\n        print(f\"\u2705 Created table {table_name} in dataset {self.path}\")\n        self.tables: List[str] = _get_db_tables(self.path)\n\n    def refresh_tables(self):\n        \"\"\"This function refreshes the tables in the dataset.\n\n        Examples:\n        ---------\n            Refresh the tables in the dataset.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset.refresh_tables()\n        \"\"\"\n        self.tables: List[str] = _get_db_tables(self.path)\n\n    def drop_table(self, table_name: str) -&gt; Self:\n        \"\"\"This function drops a table in the dataset.\n\n        Args:\n            key (str): The name of the table.\n\n        Examples:\n        ---------\n            Drop a table in the dataset.\n\n            &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n            &gt;&gt;&gt; dataset.drop_table(\"table/my_table\")\n        \"\"\"\n        table_name = table_name.replace(\"table/\", \"\")\n        if table_name in self.tables:\n            _execute_sql_without_arg(\n                self.path,\n                f\"DROP TABLE {table_name};\",\n                return_mode=\"no_return\"\n            )\n            print(f\"\u2705 Dropped table {table_name} in dataset {self.path}\")\n            self.tables: List[str] = _get_db_tables(self.path)\n        else:\n            pass\n        return self\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.citation","title":"<code>citation</code>  <code>property</code> <code>writable</code>","text":"<p>This function returns the citation from the metadata.         This is syntactic sugar for the repr field in the CITATION.</p> <pre><code>    Returns:\n        str: The citation.\n\n    Examples:\n    ---------\n        Get the citation from the metadata.\n\n        &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n        &gt;&gt;&gt; dataset.citation\n        \"This is a citation\n</code></pre> <p>Link to paper: https://example.com DOI: 10.1234/5678\"</p>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.doi","title":"<code>doi</code>  <code>property</code> <code>writable</code>","text":"<p>This function returns the DOI from the metadata.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The DOI.</p> <p>Examples:</p> <pre><code>Get the DOI from the metadata.\n\n&gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n&gt;&gt;&gt; dataset.doi\n\"10.1234/5678\"\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.license","title":"<code>license</code>  <code>property</code> <code>writable</code>","text":"<p>This function returns the license from the metadata.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The license.</p> <p>Examples:</p> <pre><code>Get the license from the metadata.\n\n&gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n&gt;&gt;&gt; dataset.license\n\"CC BY 4.0\"\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.url","title":"<code>url</code>  <code>property</code> <code>writable</code>","text":"<p>This function returns the URL from the metadata.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The URL.</p> <p>Examples:</p> <pre><code>Get the URL from the metadata.\n\n&gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n&gt;&gt;&gt; dataset.url\n\"https://example.com\"\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>This function returns a table from the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the table, prefixed with \"table/\".</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the table is not found.</p> <p>Returns:</p> Type Description <code>Union[DataFrame, DataFrame]</code> <p>Union[pd.DataFrame, pl.DataFrame]: The table.</p> <p>Examples:</p> <pre><code>Load a table from the dataset into memory:\n\n&gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n&gt;&gt;&gt; df_table = dataset[\"table/dataset_1\"]\n</code></pre> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Union[pd.DataFrame, pl.DataFrame]:\n    \"\"\" This function returns a table from the dataset.\n\n    Args:\n        key (str): The name of the table, prefixed with \"table/\".\n\n    Raises:\n        KeyError: If the table is not found.\n\n    Returns:\n        Union[pd.DataFrame, pl.DataFrame]: The table.\n\n    Examples:\n    ---------\n        Load a table from the dataset into memory:\n\n        &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n        &gt;&gt;&gt; df_table = dataset[\"table/dataset_1\"]\n    \"\"\"\n    table_name = key.replace(\"table/\", \"\")\n    if table_name in self.tables:\n        return _execute_sql_without_arg(\n            self.path,\n            f\"SELECT * FROM {table_name};\", \n            return_mode=_get_dataframe_library_preference()\n        )\n    else:\n        raise KeyError(\n            f\"Table {table_name} not found. These are the tables in the dataset: {self.tables}\"\n        )\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.__repr__","title":"<code>__repr__()</code>","text":"<p>Show the dataset and its tables.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The dataset and its tables in a string.</p> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Show the dataset and its tables.\n\n    Returns:\n        str: The dataset and its tables in a string.\n    \"\"\"\n    table_string = \"[\\n\"\n    for table in self.tables:\n        table_string += f\"\\t'table/{table}',\\n \"\n    table_string += \"]\"\n    return f\"Dataset({self.path}),\\n\\n Tables: \\n {table_string}\"\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.__setitem__","title":"<code>__setitem__(key, df)</code>","text":"<p>This function sets a table in the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the table.</p> required <code>df</code> <code>Union[DataFrame, DataFrame]</code> <p>The table.</p> required <p>Examples:</p> <pre><code>Set a table in the dataset.\n\n&gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n&gt;&gt;&gt; dataset[\"table/my_table\"] = df\n</code></pre> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def __setitem__(self, key: str, df: Union[pd.DataFrame, pl.DataFrame]):\n    \"\"\"This function sets a table in the dataset.\n\n    Args:\n        key (str): The name of the table.\n        df (Union[pd.DataFrame, pl.DataFrame]): The table.\n\n    Examples:\n    ---------\n        Set a table in the dataset.\n\n        &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n        &gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n        &gt;&gt;&gt; dataset[\"table/my_table\"] = df\n    \"\"\"\n    if not isinstance(df, (pd.DataFrame, pl.DataFrame)):\n        raise ValueError(\"df must be a pandas or polars DataFrame\")\n    table_name = key.replace(\"table/\", \"\")\n    if table_name in self.tables:\n        raise ValueError(\n            f\"\"\"Table {table_name} already exists in the dataset. \"\"\"\n            \"\"\"\\nIf you want to overwrite this table, use the .drop_table method to drop\"\"\"\n            \"\"\"it first.\"\"\"\n        )\n    _execute_sql_with_arg(\n        self.path,\n        f\"CREATE OR REPLACE TABLE {table_name} AS SELECT * FROM df\",\n        df,\n        return_mode=\"no_return\"\n    )\n    print(f\"\u2705 Created table {table_name} in dataset {self.path}\")\n    self.tables: List[str] = _get_db_tables(self.path)\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.drop_table","title":"<code>drop_table(table_name)</code>","text":"<p>This function drops a table in the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the table.</p> required <p>Examples:</p> <pre><code>Drop a table in the dataset.\n\n&gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n&gt;&gt;&gt; dataset.drop_table(\"table/my_table\")\n</code></pre> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def drop_table(self, table_name: str) -&gt; Self:\n    \"\"\"This function drops a table in the dataset.\n\n    Args:\n        key (str): The name of the table.\n\n    Examples:\n    ---------\n        Drop a table in the dataset.\n\n        &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n        &gt;&gt;&gt; dataset.drop_table(\"table/my_table\")\n    \"\"\"\n    table_name = table_name.replace(\"table/\", \"\")\n    if table_name in self.tables:\n        _execute_sql_without_arg(\n            self.path,\n            f\"DROP TABLE {table_name};\",\n            return_mode=\"no_return\"\n        )\n        print(f\"\u2705 Dropped table {table_name} in dataset {self.path}\")\n        self.tables: List[str] = _get_db_tables(self.path)\n    else:\n        pass\n    return self\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.print_citation","title":"<code>print_citation()</code>","text":"<p>Print the citation provided in the metadata table.</p> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def print_citation(self):\n    \"\"\"Print the citation provided in the metadata table.\"\"\"\n    print(_get_printable_citation(self.metadata))\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.query","title":"<code>query(sql_query, df_in_memory=None, no_return=False)</code>","text":"<p>This function executes a SQL query on the dataset and returns its result as a pandas or polars DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>sql_query</code> <code>str</code> <p>The SQL query to execute.</p> required <code>df_in_memory</code> <code>Optional[Union[DataFrame, DataFrame]]</code> <p>An in-memory DataFrame to pass through to the query statement. Defaults to None.</p> <code>None</code> <code>no_return</code> <code>bool</code> <p>If True, the query will not return a DataFrame. Use this with custom create statements.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[DataFrame, DataFrame]</code> <p>Union[pd.DataFrame, pl.DataFrame]: The results of the query.</p> <p>Examples:</p> <pre><code>Query a dataset using SQL.\n\n&gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n&gt;&gt;&gt; df = dataset.query(\"SELECT * FROM table_1;\")\n</code></pre> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def query(\n        self, \n        sql_query: str, \n        df_in_memory : Optional[Union[pd.DataFrame, pl.DataFrame]] = None,\n        no_return : bool = False\n    ) -&gt; Union[pd.DataFrame, pl.DataFrame]:\n    \"\"\"This function executes a SQL query on the dataset\n    and returns its result as a pandas or polars DataFrame.\n\n    Args:\n        sql_query (str): The SQL query to execute.\n        df_in_memory (Optional[Union[pd.DataFrame, pl.DataFrame]], optional):\n            An in-memory DataFrame to pass through to the query statement.\n            Defaults to None.\n        no_return (bool, optional): If True, the query will not return a DataFrame.\n            Use this with custom create statements.\n\n    Returns:\n        Union[pd.DataFrame, pl.DataFrame]: The results of the query.\n\n    Examples:\n    ---------\n        Query a dataset using SQL.\n\n        &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n        &gt;&gt;&gt; df = dataset.query(\"SELECT * FROM table_1;\")\n    \"\"\"\n    if df_in_memory is not None:\n        if not isinstance(df_in_memory, (pd.DataFrame, pl.DataFrame)):\n            raise ValueError(\"df_in_memory must be a pandas or polars DataFrame\")\n        return _execute_sql_with_arg(\n            self.path, \n            sql_query, \n            df_in_memory, \n            return_mode=_get_dataframe_library_preference() if not no_return else \"no_return\"\n        )\n    return _execute_sql_without_arg(\n        self.path, \n        sql_query, \n        return_mode=_get_dataframe_library_preference() if not no_return else \"no_return\"\n    )\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.Dataset.refresh_tables","title":"<code>refresh_tables()</code>","text":"<p>This function refreshes the tables in the dataset.</p> <p>Examples:</p> <pre><code>Refresh the tables in the dataset.\n\n&gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n&gt;&gt;&gt; dataset.refresh_tables()\n</code></pre> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def refresh_tables(self):\n    \"\"\"This function refreshes the tables in the dataset.\n\n    Examples:\n    ---------\n        Refresh the tables in the dataset.\n\n        &gt;&gt;&gt; dataset = Dataset(\"bladesight-data/intro_to_btt/intro_to_btt_ch02.db\")\n        &gt;&gt;&gt; dataset.refresh_tables()\n    \"\"\"\n    self.tables: List[str] = _get_db_tables(self.path)\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.download_dataset_from_bladesight_data","title":"<code>download_dataset_from_bladesight_data(dataset_path_on_s3)</code>","text":"<p>This function downloads a dataset from S3 and saves it locally.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_path_on_s3</code> <code>str</code> <p>The path to the dataset on S3.</p> required <p>Examples:</p> <pre><code>Download a dataset into the local .bladesight directory\n\n&gt;&gt;&gt; download_dataset_from_bladesight_data(\"bladesight-datasets/intro_to_btt/intro_to_btt_ch02\")\n</code></pre> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def download_dataset_from_bladesight_data(dataset_path_on_s3: str) -&gt; None:\n    \"\"\"This function downloads a dataset from S3 and saves it locally.\n\n    Args:\n        dataset_path_on_s3 (str): The path to the dataset on S3.\n\n    Examples:\n    ---------\n        Download a dataset into the local .bladesight directory\n\n        &gt;&gt;&gt; download_dataset_from_bladesight_data(\"bladesight-datasets/intro_to_btt/intro_to_btt_ch02\")\n    \"\"\"\n    s3 = s3fs.S3FileSystem(anon=True)\n    PATH_TO_LOCAL_DB = get_path_to_local_bladesight() / \"data\"\n    for s3_subfolder in dataset_path_on_s3.split(\"/\")[1:]:\n        PATH_TO_LOCAL_DB = PATH_TO_LOCAL_DB / s3_subfolder\n\n    if not PATH_TO_LOCAL_DB.parent.exists():\n        PATH_TO_LOCAL_DB.parent.mkdir(parents=True)\n\n    with yaspin(\n        text=f\"Downloading {dataset_path_on_s3} from Bladesight Data...\"\n    ) as spinner:\n        s3.download(dataset_path_on_s3 + \".db\", str(PATH_TO_LOCAL_DB) + \".db\")\n    spinner.text = f\"Done downloading {dataset_path_on_s3} from Bladesight Data... \"\n    spinner.ok(\"\u2705 \")\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.get_bladesight_datasets","title":"<code>get_bladesight_datasets()</code>","text":"<p>This function returns a list of all the datasets in     the bladesight-datasets bucket.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of the names of the datasets in the bucket.</p> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def get_bladesight_datasets() -&gt; List[str]:\n    \"\"\"This function returns a list of all the datasets in\n        the bladesight-datasets bucket.\n\n    Returns:\n        List[str]: A list of the names of the datasets in the bucket.\n    \"\"\"\n    s3 = s3fs.S3FileSystem(anon=True)\n    datasets = []\n    with yaspin(text=\"Getting all datasets from Bladesight Data...\"):\n        for bucket_root, _, files in s3.walk(BLADESIGHT_DATASETS_S3_BUCKET + \"/\"):\n            for file in files:\n                if file.endswith(\".db\"):\n                    datasets.append(f\"{bucket_root}/{file}\"[:-3])\n    return datasets\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.get_local_datasets","title":"<code>get_local_datasets()</code>","text":"<p>This function returns a list of the names of the datasets in the local datasets folder.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of the dataset names in the in the  local datasets folder.</p> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def get_local_datasets() -&gt; List[str]:\n    \"\"\"This function returns a list of the names of the datasets in the local\n    datasets folder.\n\n    Returns:\n        List[str]: A list of the dataset names in the in the \n            local datasets folder.\n    \"\"\"\n    BLADESIGHT_DATASETS_PATH = get_path_to_local_bladesight()\n    if not BLADESIGHT_DATASETS_PATH.exists():\n        return []\n    else:\n        local_datasets = []\n        for path_root, _, files in os.walk(BLADESIGHT_DATASETS_PATH):\n            for file in files:\n                if file.endswith(\".db\"):\n                    path_parts = pathlib.Path(path_root).parts\n                    path_prefix = None\n                    add_parts = False\n                    for part in path_parts:\n                        if add_parts:\n                            if path_prefix is None:\n                                path_prefix = part\n                            else:\n                                path_prefix = path_prefix + \"/\" + part\n                        if part == \".bladesight\":\n                            add_parts = True\n                    local_datasets.append(f\"{path_prefix}/{file}\"[:-3])\n        return local_datasets\n</code></pre>"},{"location":"reference/dataset_handler/#bladesight.dataset_handler.get_path_to_local_bladesight","title":"<code>get_path_to_local_bladesight()</code>","text":"<p>This function returns the path to the local datasets folder. If there is no environmental variable called BLADESIGHT_DATASETS_PATH, it will return ~/.bladesight.</p> <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path: The path to the local datasets folder. It does not necessarily exist.</p> Source code in <code>bladesight/dataset_handler.py</code> <pre><code>def get_path_to_local_bladesight() -&gt; pathlib.Path:\n    \"\"\"This function returns the path to the local datasets folder.\n    If there is no environmental variable called BLADESIGHT_DATASETS_PATH, it\n    will return ~/.bladesight.\n\n    Returns:\n        pathlib.Path: The path to the local datasets folder. It does\n            not necessarily exist.\n    \"\"\"\n    if \"BLADESIGHT_DATASETS_PATH\" in os.environ:\n        return pathlib.Path(os.environ[\"BLADESIGHT_DATASETS_PATH\"]) / \".bladesight\"\n    else:\n        return pathlib.Path.home() / \".bladesight\"\n</code></pre>"},{"location":"reference/btt/","title":"Index","text":""},{"location":"reference/btt/#bladesight.btt.get_blade_tip_deflections_from_AoAs","title":"<code>get_blade_tip_deflections_from_AoAs(df_rotor_blade_AoAs, blade_radius, poly_order=11, filter_function=None, filter_kwargs=None, verbose=False)</code>","text":"This function performs the following operations <ol> <li>Normalizes the AoAs of each probe.</li> <li>Scales the AoAs to tip deflections.</li> <li>Detrends the tip deflections using a polynomial fit.</li> <li>Filters the tip deflections using a Butterworth filter.</li> <li>Calculates the peak-to-peak tip deflection.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>df_rotor_blade_AoAs</code> <code>DataFrame</code> <p>The DataFrame containing the AoAs of each probe. This is an item from the list returned by the function <code>get_rotor_blade_AoAs</code>.</p> required <code>blade_radius</code> <code>float</code> <p>The radius of the blade in microns.</p> required <code>poly_order</code> <code>int</code> <p>The polynomial order to use for the detrending algorithm . Defaults to 11.</p> <code>11</code> <code>filter_function</code> <code>Optional[Callable]</code> <p>The filter function to be applied to the tip deflections. If None, no filtering is applied. Note that the filter function needs to only return the filtered signal that is the same shape and analogous to the unfiltered signal.</p> <code>None</code> <code>filter_kwargs</code> <p>Optional[dict], default=None The arguments to be passed to the filter function. If None, no filtering filter arguments are applied and use None when you dont want to filter.</p> <code>None</code> <code>verbose</code> <p>Optional[bool], default=False A flag to enable verbose output.</p> <code>False</code> <p>Returns:     pd.DataFrame: The DataFrame containing the detrended and filtered         tip deflections. This DataFrame also contains the peak-to-peak         tip deflection.</p> Example Usage <p>def example_filter(signal, kernel_size):     return scisig.medfilt(signal, kernel_size=kernel_size)</p> <p>df_rotor_blade_AoAs = pd.DataFrame({     'Omega': np.linspace(0, 10, 100),     'AoA_p1': np.random.randn(100),     'AoA_p2': np.random.randn(100) })</p> <p>blade_radius = 100.0 filter_function = example_filter filter_args = {'kernel_size': 5}</p> <p>df_filtered = get_blade_tip_deflections_from_AoAs_kernel(     df_rotor_blade_AoAs,     blade_radius,     filter_function,     filter_args,     poly_order=11,     filter_deflections_bool=True,     verbose=True )</p> <p>print(df_filtered.head())</p> Source code in <code>bladesight/btt/zero.py</code> <pre><code>def get_blade_tip_deflections_from_AoAs(\n    df_rotor_blade_AoAs: pd.DataFrame,\n    blade_radius: float,\n    poly_order: Optional[int] = 11,\n    filter_function: Optional[Callable] = None,\n    filter_kwargs: Optional[dict] = None,\n    verbose: Optional[bool] = False,\n) -&gt; pd.DataFrame:\n    \"\"\"This function performs the following operations:\n        1. Normalizes the AoAs of each probe.\n        2. Scales the AoAs to tip deflections.\n        3. Detrends the tip deflections using a polynomial fit.\n        4. Filters the tip deflections using a Butterworth filter.\n        5. Calculates the peak-to-peak tip deflection.\n\n    Args:\n        df_rotor_blade_AoAs (pd.DataFrame): The DataFrame containing the AoAs of each\n            probe. This is an item from the list returned by the\n            function `get_rotor_blade_AoAs`.\n        blade_radius (float): The radius of the blade in microns.\n        poly_order (int, optional): The polynomial order to use for the detrending\n            algorithm . Defaults to 11.\n        filter_function (Optional[Callable], optional):\n            The filter function to be applied to the tip deflections. If None, no filtering is applied.\n            Note that the filter function needs to only return the filtered signal that is the same shape and analogous to the unfiltered signal.\n        filter_kwargs : Optional[dict], default=None\n            The arguments to be passed to the filter function. If None, no filtering filter arguments are applied and use None when you dont want to filter.\n        verbose : Optional[bool], default=False\n            A flag to enable verbose output.\n    Returns:\n        pd.DataFrame: The DataFrame containing the detrended and filtered\n            tip deflections. This DataFrame also contains the peak-to-peak\n            tip deflection.\n\n    Example Usage:\n        def example_filter(signal, kernel_size):\n            return scisig.medfilt(signal, kernel_size=kernel_size)\n\n        df_rotor_blade_AoAs = pd.DataFrame({\n            'Omega': np.linspace(0, 10, 100),\n            'AoA_p1': np.random.randn(100),\n            'AoA_p2': np.random.randn(100)\n        })\n\n        blade_radius = 100.0\n        filter_function = example_filter\n        filter_args = {'kernel_size': 5}\n\n        df_filtered = get_blade_tip_deflections_from_AoAs_kernel(\n            df_rotor_blade_AoAs,\n            blade_radius,\n            filter_function,\n            filter_args,\n            poly_order=11,\n            filter_deflections_bool=True,\n            verbose=True\n        )\n\n        print(df_filtered.head())\n    \"\"\"\n    if filter_kwargs is None:\n        filter_kwargs = {}\n\n    df = df_rotor_blade_AoAs.copy(deep=True)\n    all_aoa_columns = [\n        col_name for col_name in df.columns if col_name.startswith(\"AoA_p\")\n    ]\n\n    for col in all_aoa_columns:\n        df[col + \"_norm\"] = df[col].mean() - df[col]\n        deflection_col_name = col.replace(\"AoA\", \"x\")\n        df[deflection_col_name] = blade_radius * df[col + \"_norm\"]\n        poly = np.polyfit(df[\"Omega\"], df[deflection_col_name], poly_order)\n        df[deflection_col_name] = df[deflection_col_name] - np.polyval(\n            poly, df[\"Omega\"]\n        )\n\n        if (\n            filter_function is not None and filter_kwargs is not None\n        ):  # Filter tip deflections and denoted by columns with \"_filt subfix\"\n            df[deflection_col_name + \"_filt\"] = filter_function(\n                df[deflection_col_name].values, **filter_kwargs\n            )\n\n    if filter_function is not None and filter_kwargs is not None:\n        x_matrix = df[[col for col in df.columns if col.endswith(\"_filt\")]].to_numpy()\n    else:\n        x_matrix = df[\n            [\n                col\n                for col in df.columns\n                if col.startswith(\"x_p\") and not col.endswith(\"_filt\")\n            ]\n        ].to_numpy()\n\n    df[\"pk-pk\"] = x_matrix.max(axis=1) - x_matrix.min(\n        axis=1\n    )  # If a filter function is supplied, the pk-pk values will be calculated from the filtered deflections\n\n    return df\n</code></pre>"},{"location":"reference/btt/#bladesight.btt.get_rotor_blade_AoAs","title":"<code>get_rotor_blade_AoAs(df_encoder, prox_probe_toas, probe_spacings, B, is_mpr=False, tramsform_prox_AoAs_to_blade_AoAs_kwargs={})</code>","text":"<p>This function converts the raw time stamps, both the OPR zero-crossing times and he proximity probe ToAs, and returns a DataFrame for each  blade containing the ToA and AoA values for each blade over all the proximity probes.</p> <p>Parameters:</p> Name Type Description Default <code>df_encoder</code> <code>DataFrame</code> <p>A DataFrame containing the zero-crossing times and corresponding info. This DataFrame can take on two values:      1) OPR encoder: The first column of the DataFrame should be     the zero-crossing times of the OPR encoder.     2) MPR encoder: The DataFrame MUST be the result of the     bladesight.ias.calculate_mpr function.</p> required <code>prox_probe_toas</code> <code>List[DataFrame]</code> <p>A list of DataFrames where each DataFrame contains the ToAs of a single blade from a proximity probe.</p> required <code>probe_spacings</code> <code>List[float]</code> <p>The relative spacing between the first probe and every other probe. There are one less value in this list than in prox_probe_toas.</p> required <code>B</code> <code>int</code> <p>The number of blades.</p> required <code>is_mpr</code> <code>bool</code> <p>A flag to indicate if the encoder is an MPR encoder. Defaults to False.</p> <code>False</code> <code>tramsform_prox_AoAs_to_blade_AoAs_kwargs</code> <code>Optional[dict]</code> <p>The keyword arguments to be passed to the  transform_prox_AoAs_to_blade_AoAs function. Defaults to None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[DataFrame]</code> <p>List[pd.DataFrame]: A list of DataFrames where each DataFrame contains the ToAs and AoAs of a single blade over all the proximity probes.</p> Source code in <code>bladesight/btt/__init__.py</code> <pre><code>def get_rotor_blade_AoAs(\n    df_encoder : pd.DataFrame,\n    prox_probe_toas : List[Union[pd.DataFrame, pl.DataFrame]],\n    probe_spacings : List[float],\n    B : int,\n    is_mpr : bool = False,\n    tramsform_prox_AoAs_to_blade_AoAs_kwargs : Optional[dict] = {}\n) -&gt; List[pd.DataFrame]:\n    \"\"\"This function converts the raw time stamps, both the OPR zero-crossing\n    times and he proximity probe ToAs, and returns a DataFrame for each \n    blade containing the ToA and AoA values for each blade over all the\n    proximity probes.\n\n    Args:\n        df_encoder (pd.DataFrame): A DataFrame containing the\n            zero-crossing times and corresponding info. This DataFrame can\n            take on two values: \n                1) OPR encoder: The first column of the DataFrame should be\n                the zero-crossing times of the OPR encoder.\n                2) MPR encoder: The DataFrame MUST be the result of the\n                bladesight.ias.calculate_mpr function.\n        prox_probe_toas (List[pd.DataFrame]): A list of DataFrames\n            where each DataFrame contains the ToAs of a single\n            blade from a proximity probe.\n        probe_spacings (List[float]): The relative spacing between\n            the first probe and every other probe. There are one\n            less value in this list than in prox_probe_toas.\n        B (int): The number of blades.\n        is_mpr (bool, optional): A flag to indicate if the encoder is\n            an MPR encoder. Defaults to False.\n        tramsform_prox_AoAs_to_blade_AoAs_kwargs (Optional[dict], optional):\n            The keyword arguments to be passed to the \n            transform_prox_AoAs_to_blade_AoAs function. Defaults to None.\n\n    Returns:\n        List[pd.DataFrame]: A list of DataFrames where each DataFrame\n            contains the ToAs and AoAs of a single blade over all\n            the proximity probes.\n    \"\"\"\n    blade_dfs_recombined = []\n\n    if not is_mpr:\n        for df_prox_toas in prox_probe_toas:\n            df_prox = transform_ToAs_to_AoAs(\n                df_encoder.to_frame() if isinstance(df_encoder, (pd.Series, pl.Series)) else df_encoder, \n                df_prox_toas.to_frame() if isinstance(df_prox_toas, (pd.Series, pl.Series)) else df_prox_toas\n            )\n\n            blade_dfs_recombined.append(\n                pivot_blade_AoAs_along_revolutions(\n                    transform_prox_AoAs_to_blade_AoAs(\n                        df_prox = df_prox, \n                        B = B,\n                        **tramsform_prox_AoAs_to_blade_AoAs_kwargs,\n                    )\n                )\n            )\n    else:\n        for df_prox_toas in prox_probe_toas:\n            try:\n                df_prox = transform_ToAs_to_AoAs_mpr(\n                    df_encoder.to_frame() if isinstance(df_encoder, (pd.Series, pl.Series)) else df_encoder, \n                    df_prox_toas.to_frame() if isinstance(df_prox_toas, (pd.Series, pl.Series)) else df_prox_toas\n                )\n            except AssertionError as e:\n                print(\"It looks like you did not pass the correct MPR encoder DataFrame.\")\n                print(\"Please ensure you pass df_encoder as the result of the bladesight.ias.calculate_mpr function.\")\n                raise e\n\n            blade_dfs_recombined.append(\n                pivot_blade_AoAs_along_revolutions(\n                    transform_prox_AoAs_to_blade_AoAs(\n                        df_prox = df_prox, \n                        B = B,\n                        **tramsform_prox_AoAs_to_blade_AoAs_kwargs,\n                    )\n                )\n            )\n\n    rotor_AoA_dfs = assemble_rotor_AoA_dfs(\n        prox_aligned_dfs=blade_dfs_recombined,\n        probe_spacing=probe_spacings\n    )\n    return rotor_AoA_dfs\n</code></pre>"},{"location":"reference/btt/#bladesight.btt.verbose_print","title":"<code>verbose_print(verbose, text)</code>","text":"<p>Print the text if the verbose flag is True.</p>"},{"location":"reference/btt/#bladesight.btt.verbose_print--parameters","title":"Parameters","text":"<p>verbose : bool     A flag indicating whether to print the text or not. text : str     The f-string for the text to print. Returns</p> <p>None, only prints the text if the verbose flag is True.</p> Source code in <code>bladesight/btt/__init__.py</code> <pre><code>def verbose_print(verbose: bool, text: str):\n    \"\"\"\n    Print the text if the verbose flag is True.\n\n    Parameters\n    ----------\n    verbose : bool\n        A flag indicating whether to print the text or not.\n    text : str\n        The f-string for the text to print.\n    Returns\n    -------\n    None, only prints the text if the verbose flag is True.\n    \"\"\"\n    if verbose:\n        print(text)\n</code></pre>"},{"location":"reference/btt/triggering_criteria/","title":"Triggering criteria","text":""},{"location":"reference/btt/triggering_criteria/#bladesight.btt.triggering_criteria.get_constant_thresholds","title":"<code>get_constant_thresholds(sensor_array, sensor_type, threshold_hysteresis_dict, threshold_category='correct', verbose=False)</code>","text":"<p>Determine the threshold level to use for the constant threshold trigger method.</p>"},{"location":"reference/btt/triggering_criteria/#bladesight.btt.triggering_criteria.get_constant_thresholds--parameters","title":"Parameters","text":"<p>sensor_array : np.ndarray     The time signal to determine the threshold level for. sensor_type : str     The type of sensor. threshold_hysteresis_dict : dict[str, float]     The dictionary of threshold levels for each category. The keys must be in the format     \" &lt;\"threshold\" or \"hysteresis\" keyword&gt; \". The level is a keyword     between \"low\", \"correct\", or \"high\" that can be used for different triggering threshold studies.     The float associated with each key is the threshold or hysteresis level expressed as a percentage value.     Note that if no \"hysteresis\" keyword is found in the dictionary, the hysteresis level is set to None. threshold_category : Optional[str], optional     The category of threshold level to use ('low', 'correct', or 'high'), by default 'correct'."},{"location":"reference/btt/triggering_criteria/#bladesight.btt.triggering_criteria.get_constant_thresholds--returns","title":"Returns","text":"<p>Tuple[float, float]     The threshold voltage level and hysteresis voltage level.</p>"},{"location":"reference/btt/triggering_criteria/#bladesight.btt.triggering_criteria.get_constant_thresholds--raises","title":"Raises","text":"<p>ValueError     If threshold_category is not one of the following: \"low\", \"correct\", \"high\". ValueError     If threshold_category_array contains values outside the range of 0 to 100.</p>"},{"location":"reference/btt/triggering_criteria/#bladesight.btt.triggering_criteria.get_constant_thresholds--notes","title":"Notes:","text":"<p>This function is modified/developed by Justin Smith using existing bladesight code (see References).    </p>"},{"location":"reference/btt/triggering_criteria/#bladesight.btt.triggering_criteria.get_constant_thresholds--example-usage","title":"Example Usage:","text":"<p>tacho_threshold_hysteresis_category_dict = {         'tacho OPR threshold correct': 60,         'tacho OPR hysteresis correct': 10,         'tacho MPR threshold correct': 60,         'tacho MPR hysteresis correct': 55,         } sensor_type = \"Tacho OPR\" OPR_signal = np.array([0, 0, 0, 0.2, 0.4, 0.6, 0.8, 1, 1, 1, 0.7, 0.3, 0, 0, 0]) threshold_OPR, hysteresis_OPR = get_constant_thresholds(OPR_signal, sensor_type = sensor_type, threshold_hysteresis_dict = tacho_threshold_hysteresis_category_dict)</p> <p>(0.6, 0.06)</p>"},{"location":"reference/btt/triggering_criteria/#bladesight.btt.triggering_criteria.get_constant_thresholds--references","title":"References","text":"<p>This function is adapted from determine_threshold_level in Chapter 2 of the bladesight tutorial (https://docs.bladesight.com/tutorials/intro_to_btt/ch2/#problem-1-automatic-range-detection). [1] D. H. Diamond, \u201cIntroduction to Blade Tip Timing,\u201d Bladesight Learn. Accessed: Feb. 12, 2024. [Online]. Available: docs.bladesight.com</p> Source code in <code>bladesight/btt/triggering_criteria.py</code> <pre><code>def get_constant_thresholds(\n    sensor_array: np.ndarray,\n    sensor_type: str,\n    threshold_hysteresis_dict: dict[str, float],\n    threshold_category: Optional[str] = \"correct\",\n    verbose: Optional[bool] = False,\n    ) -&gt; Tuple[float, float]:\n    \"\"\"\n    Determine the threshold level to use for the constant threshold trigger method.\n\n    Parameters\n    ----------\n    sensor_array : np.ndarray\n        The time signal to determine the threshold level for.\n    sensor_type : str\n        The type of sensor.\n    threshold_hysteresis_dict : dict[str, float]\n        The dictionary of threshold levels for each category. The keys must be in the format\n        \"&lt;sensor type&gt; &lt;\"threshold\" or \"hysteresis\" keyword&gt; &lt;level&gt;\". The level is a keyword\n        between \"low\", \"correct\", or \"high\" that can be used for different triggering threshold studies.\n        The float associated with each key is the threshold or hysteresis level expressed as a percentage value.\n        Note that if no \"hysteresis\" keyword is found in the dictionary, the hysteresis level is set to None.\n    threshold_category : Optional[str], optional\n        The category of threshold level to use ('low', 'correct', or 'high'), by default 'correct'.\n\n    Returns\n    -------\n    Tuple[float, float]\n        The threshold voltage level and hysteresis voltage level.\n\n    Raises\n    ------\n    ValueError\n        If threshold_category is not one of the following: \"low\", \"correct\", \"high\".\n    ValueError\n        If threshold_category_array contains values outside the range of 0 to 100.\n\n    Notes:\n    ------\n    This function is modified/developed by Justin Smith using existing bladesight code (see References).    \n\n    Example Usage:\n    --------------\n\n\n    tacho_threshold_hysteresis_category_dict = {\n            'tacho OPR threshold correct': 60,\n            'tacho OPR hysteresis correct': 10,\n            'tacho MPR threshold correct': 60,\n            'tacho MPR hysteresis correct': 55,\n            }\n    sensor_type = \"Tacho OPR\"\n    OPR_signal = np.array([0, 0, 0, 0.2, 0.4, 0.6, 0.8, 1, 1, 1, 0.7, 0.3, 0, 0, 0])\n    threshold_OPR, hysteresis_OPR = get_constant_thresholds(OPR_signal, sensor_type = sensor_type, threshold_hysteresis_dict = tacho_threshold_hysteresis_category_dict)\n\n    &gt;&gt;&gt;&gt;(0.6, 0.06)\n\n    References\n    ----------\n    This function is adapted from determine_threshold_level in Chapter 2 of the bladesight tutorial\n    (https://docs.bladesight.com/tutorials/intro_to_btt/ch2/#problem-1-automatic-range-detection).\n    [1] D. H. Diamond, \u201cIntroduction to Blade Tip Timing,\u201d Bladesight Learn. Accessed: Feb. 12, 2024.\n    [Online]. Available: docs.bladesight.com\n    \"\"\"\n    # Checking theshold_category and threshold values are appropriate\n    if threshold_category not in [\"low\", \"correct\", \"high\"]:\n        raise ValueError(\n            \"threshold_category must be one of the following: 'low', 'correct', 'high'\"\n        )\n    if (\n        any(value &lt; 0 for value in threshold_hysteresis_dict.values()) &lt; 0\n        or any(value &lt; 0 for value in threshold_hysteresis_dict.values()) &gt; 100\n    ):\n        raise ValueError(\"threshold_category_array must be between 0 and 100\")\n\n    sensor_threshold_keys = [\n    key for key in threshold_hysteresis_dict.keys() if key.lower().startswith(sensor_type.lower())\n    ]\n\n    if not sensor_threshold_keys:\n        avail_keys = f\"Available Keys: {threshold_hysteresis_dict.keys()}\"\n        raise ValueError(f\"{avail_keys}\\n\" + f\"No keys found in threshold_hysteresis_dict for sensor type '{sensor_type}'\")\n\n\n    threshold_keys = [key for key in sensor_threshold_keys if \"threshold\" in key]\n\n    if not threshold_keys:\n        avail_keys = f\"Available Keys: {threshold_hysteresis_dict.keys()}\"\n        raise ValueError(f\"{avail_keys}\\n\" + f\"No threshold keys found in threshold_hysteresis_dict for sensor type '{sensor_type}'\")\n\n    sensor_hysteresis_keys = [\n        key for key in threshold_hysteresis_dict.keys() if key.lower().startswith(sensor_type.lower())\n    ]\n\n\n    hysteresis_keys = [key for key in sensor_hysteresis_keys if \"hysteresis\" in key.lower()]\n    if not hysteresis_keys:\n        avail_keys = f\"Available Keys: {threshold_hysteresis_dict.keys()}\"\n        raise ValueError(f\"{avail_keys}\\n\" + f\"No hysteresis keys found in threshold_hysteresis_dict for sensor type '{sensor_type}'\")\n\n    threshold_level_key = [key for key in threshold_keys if threshold_category.lower() in key.lower()]\n    if not threshold_level_key:\n        raise ValueError(f\"No threshold level key found for category '{threshold_category}' in threshold_hysteresis_dict for sensor type '{sensor_type}'\")\n\n\n    threshold_level_percent = threshold_hysteresis_dict[threshold_level_key[0]]\n\n    if (not hysteresis_keys) != True: #if hysteresis_keys is not empty, then dont assign a hysteresis level\n        hysteresis_level_key = [key for key in hysteresis_keys if threshold_category.lower() in key.lower()]\n        hysteresis_level_percent = threshold_hysteresis_dict[hysteresis_level_key[0]]\n\n    if (not hysteresis_keys) != False:\n        hysteresis_level_key = None\n        hysteresis_level_percent = None\n\n    min_value = np.min(sensor_array)\n    max_value = np.max(sensor_array)\n    signal_range = max_value - min_value\n\n    verbose_print(verbose, f\"sensor_type: {sensor_type}\")\n    verbose_print(verbose, f\"Min Value: {min_value} Volts\")\n    verbose_print(verbose, f\"Max Value: {max_value} Volts\")\n    # verbose_print(verbose, f\"mean value: {np.mean(sensor_array)} Volts\")\n    # verbose_print(verbose, f\"10th percentile value: {np.percentile(sensor_array, 10)} Volts\")\n    verbose_print(verbose, f\"Signal Range: {signal_range} Volts\")\n\n    threshold_level = min_value + signal_range * threshold_level_percent / 100 # Volts\n\n    if hysteresis_level_percent is None:\n        hysteresis_level = None\n\n    if hysteresis_level_percent is not None:\n        hysteresis_level = threshold_level * hysteresis_level_percent / 100 # Volts\n\n    verbose_print(verbose, f\"Sensor Type: {sensor_type}\")\n    verbose_print(verbose, f\"THRESHOLD_LEVEL: {threshold_level_percent}% =&gt; {threshold_level} Volts\")\n    verbose_print(verbose, f\"HYSTERESIS_LEVEL: {hysteresis_level_percent}% =&gt; {hysteresis_level} Volts\")\n\n    return threshold_level, hysteresis_level\n</code></pre>"},{"location":"reference/btt/triggering_criteria/#bladesight.btt.triggering_criteria.threshold_crossing_hysteresis_falling","title":"<code>threshold_crossing_hysteresis_falling(arr_t, arr_s, threshold, hysteresis_height, n_est=None)</code>","text":"<p>This function implements the constant threshold triggering method with hysteresis on the falling edge. The hysteresis height is specified in the same units as the signal.</p> <p>Parameters:</p> Name Type Description Default <code>arr_t</code> <code>ndarray</code> <p>The time values of the signal.</p> required <code>arr_s</code> <code>ndarray</code> <p>The signal to determine the threshold level for.</p> required <code>threshold</code> <code>float</code> <p>The threshold level to use for the constant threshold triggering method.</p> required <code>hysteresis_height</code> <code>float</code> <p>The height of the hysteresis. It has the same units as the signal.</p> required <code>n_est</code> <code>Optional[float]</code> <p>The estimated number of ToAs in this signal. Defaults to None. This number is used to pre-allocate the array containing the ToAs. If this number is not provided, the array will be pre-allocated as the same dimension as arr_t and arr_s. You should specify this value for large signals.</p> <code>None</code> Source code in <code>bladesight/btt/triggering_criteria.py</code> <pre><code>@njit\ndef threshold_crossing_hysteresis_falling(\n    arr_t : np.ndarray,\n    arr_s : np.ndarray,\n    threshold : float,\n    hysteresis_height : float,\n    n_est : Optional[float] = None,\n) -&gt; np.ndarray:\n    \"\"\" This function implements the constant threshold triggering\n    method with hysteresis on the falling edge. The hysteresis\n    height is specified in the same units as the signal.\n\n    Args:\n        arr_t (np.ndarray): The time values of the signal.\n        arr_s (np.ndarray): The signal to determine the threshold\n            level for.\n        threshold (float): The threshold level to use for the\n            constant threshold triggering method.\n        hysteresis_height (float): The height of the hysteresis.\n            It has the same units as the signal.\n        n_est (Optional[float]): The estimated number of ToAs in\n            this signal. Defaults to None. This number is used to\n            pre-allocate the array containing the ToAs. If this\n            number is not provided, the array will be pre-allocated\n            as the same dimension as arr_t and arr_s. You should\n            specify this value for large signals.\n    \"\"\"\n    threshold_upper = threshold + hysteresis_height\n    trigger_state = True if arr_s[0] &lt; threshold_upper else False\n\n    # Pre-allocate the array containing the ToAs\n    if n_est is None:\n        arr_toa = -1 * np.ones(arr_t.shape)\n    else:\n        arr_toa = -1 * np.ones(n_est)\n\n    # Initialise the index of the ToA array\n    i_toa = 0\n\n    # Initialise the previous sample value\n    prev_sample = arr_s[0]\n\n    # Loop through all the samples\n    for i_sample in range(1, arr_s.shape[0]):\n        # Get the current sample value\n        curr_sample = arr_s[i_sample]\n\n        # Check if the threshold is crossed\n        if trigger_state is True:\n            if curr_sample &gt;= threshold_upper:\n                trigger_state = False\n        else:\n            if curr_sample &lt;= threshold:\n                trigger_state = True\n                # Interpolate the ToA\n                arr_toa[i_toa] = (\n                    arr_t[i_sample - 1] \n                    + (arr_t[i_sample] - arr_t[i_sample - 1]) \n                    * (threshold - prev_sample) \n                    / (curr_sample - prev_sample)\n                )\n                i_toa += 1\n\n        # Update the previous sample value\n        prev_sample = curr_sample\n\n    # Return the array containing the ToAs\n    return arr_toa[:i_toa]\n</code></pre>"},{"location":"reference/btt/triggering_criteria/#bladesight.btt.triggering_criteria.threshold_crossing_hysteresis_rising","title":"<code>threshold_crossing_hysteresis_rising(arr_t, arr_s, threshold, hysteresis_height, n_est=None)</code>","text":"<p>A sequential threshold crossing algorithm that interpolates     the ToA between the two samples where the signal crosses     the threshold.</p> <p>Parameters:</p> Name Type Description Default <code>arr_t</code> <code>ndarray</code> <p>The array containing the time values.</p> required <code>arr_s</code> <code>ndarray</code> <p>The array containing the signal voltage values corresponding to the time values.</p> required <code>threshold</code> <code>float</code> <p>The threshold value.</p> required <code>hysteresis_height</code> <code>float</code> <p>The height of the hysteresis, in the same units as the signal.</p> required <code>n_est</code> <code>float</code> <p>The estimated number of ToAs in this signal. Defaults to None. This number is used to pre-allocate the array containing the ToAs. If this number is not provided, the array will be pre-allocated as the same dimension as arr_t and arr_s.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the ToAs.</p> Source code in <code>bladesight/btt/triggering_criteria.py</code> <pre><code>@njit\ndef threshold_crossing_hysteresis_rising(\n    arr_t: np.ndarray,\n    arr_s: np.ndarray,\n    threshold: float,\n    hysteresis_height: float,\n    n_est: Optional[float] = None,\n) -&gt; np.ndarray:\n    \"\"\"A sequential threshold crossing algorithm that interpolates\n        the ToA between the two samples where the signal crosses\n        the threshold.\n\n    Args:\n        arr_t (np.ndarray): The array containing the time values.\n        arr_s (np.ndarray): The array containing the signal voltage values\n            corresponding to the time values.\n        threshold (float): The threshold value.\n        hysteresis_height (float): The height of the hysteresis, in the same\n            units as the signal.\n        n_est (float, optional): The estimated number of ToAs in this\n            signal. Defaults to None. This number is used to pre-allocate the array\n            containing the ToAs. If this number is not provided, the array will\n            be pre-allocated as the same dimension as arr_t and arr_s.\n\n    Returns:\n        np.ndarray: An array containing the ToAs.\n    \"\"\"\n    threshold_lower = threshold - hysteresis_height\n    trigger_state = True if arr_s[0] &gt; threshold_lower else False\n\n    # Pre-allocate the array containing the ToAs\n    if n_est is None:\n        arr_toa = -1 * np.ones(arr_t.shape)\n    else:\n        arr_toa = -1 * np.ones(n_est)\n\n    # Initialise the index of the ToA array\n    i_toa = 0\n\n    # Initialise the previous sample value\n    prev_sample = arr_s[0]\n\n    # Loop through all the samples\n    for i_sample in range(1, arr_s.shape[0]):\n        # Get the current sample value\n        curr_sample = arr_s[i_sample]\n\n        # Check if the threshold is crossed\n        if trigger_state is True:\n            if curr_sample &lt;= threshold_lower:\n                trigger_state = False\n        else:\n            if curr_sample &gt;= threshold:\n                trigger_state = True\n                # Interpolate the ToA\n                arr_toa[i_toa] = arr_t[i_sample - 1] + (\n                    arr_t[i_sample] - arr_t[i_sample - 1]\n                ) * (threshold - prev_sample) / (curr_sample - prev_sample)\n                i_toa += 1\n\n        # Update the previous sample value\n        prev_sample = curr_sample\n\n    # Return the array containing the ToAs\n    return arr_toa[:i_toa]\n</code></pre>"},{"location":"reference/btt/triggering_criteria/#bladesight.btt.triggering_criteria.threshold_crossing_interp","title":"<code>threshold_crossing_interp(arr_t, arr_s, threshold, n_est=None, trigger_on_rising_edge=True)</code>","text":"<p>A sequential threshold crossing algorithm that interpolates     the ToA between the two samples where the signal crosses     the threshold.</p> <p>Parameters:</p> Name Type Description Default <code>arr_t</code> <code>ndarray</code> <p>The array containing the time values.</p> required <code>arr_s</code> <code>ndarray</code> <p>The array containing the signal voltage values corresponding to the time values.</p> required <code>threshold</code> <code>float</code> <p>The threshold value.</p> required <code>n_est</code> <code>float</code> <p>The estimated number of ToAs in this signal. Defaults to None. This number is used to pre-allocate the array containing the ToAs. If this number is not provided, the array will be pre-allocated as the same dimension as arr_t and arr_s.</p> <code>None</code> <code>trigger_on_rising_edge</code> <code>bool</code> <p>Whether to trigger ToAs on the rising or falling edge. Defaults to True. If True, the ToA is triggered on the rising edge.</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array containing the ToAs.</p> Source code in <code>bladesight/btt/triggering_criteria.py</code> <pre><code>@njit\ndef threshold_crossing_interp(\n    arr_t: np.ndarray,\n    arr_s: np.ndarray,\n    threshold: float,\n    n_est: Optional[float] = None,\n    trigger_on_rising_edge: bool = True,\n) -&gt; np.ndarray:\n    \"\"\"A sequential threshold crossing algorithm that interpolates\n        the ToA between the two samples where the signal crosses\n        the threshold.\n\n    Args:\n        arr_t (np.ndarray): The array containing the time values.\n        arr_s (np.ndarray): The array containing the signal voltage values\n            corresponding to the time values.\n        threshold (float): The threshold value.\n        n_est (float, optional): The estimated number of ToAs in this signal. Defaults\n            to None. This number is used to pre-allocate the array containing the\n            ToAs. If this number is not provided, the array will be pre-allocated as\n            the same dimension as arr_t and arr_s.\n        trigger_on_rising_edge (bool, optional): Whether to trigger ToAs on the rising\n            or falling edge. Defaults to True. If True, the ToA is triggered on\n            the rising edge.\n\n    Returns:\n        np.ndarray: An array containing the ToAs.\n    \"\"\"\n\n    # Pre-allocate the array containing the ToAs\n    if n_est is None:\n        arr_toa = -1 * np.ones(arr_t.shape)\n    else:\n        arr_toa = -1 * np.ones(n_est)\n\n    # Initialise the index of the ToA array\n    i_toa = 0\n\n    # Initialise the previous sample value\n    prev_sample = arr_s[0]\n\n    # Loop through all the samples\n    for i_sample in range(1, arr_s.shape[0]):\n        # Get the current sample value\n        curr_sample = arr_s[i_sample]\n\n        # Check if the threshold is crossed\n        if trigger_on_rising_edge:\n            if (prev_sample &lt; threshold) and (curr_sample &gt;= threshold):\n                # Interpolate the ToA\n                if i_toa &gt;= arr_toa.shape[0]:\n                    raise ValueError(\n                        \"The number of ToAs has exceeded the estimated number of ToAs. \"\n                        f\"n_est is currently {n_est}. You must increase it. This error occurred\"\n                        f\" at the sample index {i_sample} out of {arr_s.shape[0]}. \"\n                        f\"Your ToA array has therefore been filled within {round(100 * i_sample/arr_s.shape[0])} % \"\n                        \"of the signal.\"\n                    )\n                arr_toa[i_toa] = arr_t[i_sample - 1] + (\n                    arr_t[i_sample] - arr_t[i_sample - 1]\n                ) * (threshold - prev_sample) / (curr_sample - prev_sample)\n                i_toa += 1\n        else:\n            if (prev_sample &gt; threshold) and (curr_sample &lt;= threshold):\n                if i_toa &gt;= arr_toa.shape[0]:\n                    raise ValueError(\n                        \"The number of ToAs has exceeded the estimated number of ToAs. \"\n                        f\"n_est is currently {n_est}. You must increase it. This error occurred\"\n                        f\" at the sample index {i_sample} out of {arr_s.shape[0]}. \"\n                        f\"Your ToA array has therefore been filled within {round(100 * i_sample/arr_s.shape[0])} % \"\n                        \"of the signal.\"\n                    )\n                # Interpolate the ToA\n                arr_toa[i_toa] = arr_t[i_sample - 1] + (\n                    arr_t[i_sample] - arr_t[i_sample - 1]\n                ) * (threshold - prev_sample) / (curr_sample - prev_sample)\n                i_toa += 1\n\n        # Update the previous sample value\n        prev_sample = curr_sample\n\n    # Return the array containing the ToAs\n    return arr_toa[:i_toa]\n</code></pre>"},{"location":"tutorials/","title":"Signal processing tutorials","text":"<p>With our signal processing tutorials, we aim to take users through advanced signal processing techniques using a hands-on approach. We provide code for all examples, so you can try them out yourself. We also provide a Jupyter notebook for each tutorial, so you can easily run the code and experiment with it.</p>"},{"location":"tutorials/datasets/","title":"Index","text":"<ul> <li>Diamond et al (2024)[/tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/index.md] varying ramp rates with a 45 degree angle pipe as a forcing mechanism</li> </ul>"},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/","title":"Diamond et al 2024 ramp rates at 45 degrees","text":"","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#why-did-we-conduct-these-tests","title":"Why did we conduct these tests?","text":"<p>It's always felt like there's a stone lodged under my heel when fitting curves to transient synchronous resonances. The resonant frequencies recovered by curve fitting algorithms have always struck me as imprecise. A prime example of this is when you measure the resonant frequency during a run-up vs the same frequency during a run-down. Logic dictates that such frequencies should be the same. </p> <p>I've found they are never the same.</p> <p>To investigate this, we set about to conduct measurements where we varied the ramp rate of run ups and run-downs.</p> <p>Unfortunately, about a fortnight prior to completing our first draft, I found a paper by (Zhi et al., 2022)<sup>1</sup> that investigated this phenomenon. It could be that most BTT practitioners know about this. But I doubt it. </p> <p>I believe most people subscribe to the classical view that synchronous resonances are integrally proportional to the shaft speed. This is not the case. I still want to publish on this work, but we'll need more tests. </p> <p>I've decided to publish the dataset to Bladesight under the Creative Commons license. </p> <p>I hope you find it useful. There's a lot of data here.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#experimental-setup-and-method","title":"Experimental setup and method","text":"<p>The main purpose of these tests are to investigate if the commonly held synchronous vibration relationship, given below,</p> \\[\\begin{equation} f = \\Omega EO \\end{equation}\\] <p>holds true for different ramp rates.</p> <p>The BTT test bench at the University of Pretoria's Sasol laboratory was used for this investigation.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#rotor-motor-and-blade-excitation","title":"Rotor, motor, and blade excitation","text":"<p>The test bench consists of a five blade blisk. The blades of the blisk have an outer radius of 164 mm. These blades are rectangular, thereby allowing us to study pure bending modes. The motor is controlled with an analogue signal that varies between 0 - 10 Volts, corresponding to the minimum and maximum speed, respectively. </p> <p>The maximum speed of the rotor is approximately 1450 RPM. Compressed air was used to excite the blades. The pipe, presented in Figure 1, was placed at approximately a 45 \u00b0 angle with respect to the blades. </p> <p>Note</p> <p>The choice of 45 degrees was in truth accidental. Prior to positioning the pipe at a 45 \u00b0 angle it was placed at close to a 90 \u00b0 angle. I hypothesized that, because the air was directed perpendicular to the blade's chord, the largest tip deflections would be observed. </p> <p>After an entire day of testing, we conducted a single test with the pipe at a 45 \u00b0 angle. The tip deflections were significantly larger than those observed at 90 \u00b0. It was like finding out there's another 5 km left after running a marathon. </p> <p>We repeated all the tests at 45 \u00b0, yielding the present dataset.</p> <p>The rotor blades\u2019 first three natural frequencies at rest are approximately 125 Hz, 512 Hz, 723 Hz.</p> <p> Figure 1: The experimental setup at the University of Pretoria's Sasol Laboratory.     </p> <p>Note</p> <p>We had every intent to return to the test bench in pursuit of better photos. </p> <p>We never did. We apologize for this.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#sensors","title":"Sensors","text":"<p>Three  MEGGIT TQ401 eddy current proximity probes were used. Two were used as proximity probes and one as an OPR sensor. </p> <p>Aditionally, an Optel Thevon 152G8 optical fibre sensor was installed in conjunction with a zebra-tape to serve as a Multiple Pulses per Revolution (MPR) shaft encoder.</p> <p>We instrumented one blade with a strain gauge at its root. The strain gauge was attached so as to be sensitive to bending.</p> <p>Info</p> <p>The probes are installed 20.1 \u00b0 apart. The strain gauge'd blade is the last blade to arrive at the OPR sensor.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#data-acquisition-and-control","title":"Data acquisition and control","text":"<p>In addition to understanding the effects of ramp rates and directions on blade vibration, we also included new/unproven sensors and Data Acquisition Systems (DAQs). Ultimately, four different DAQs and control systems were used.</p> <p>The four DAQs and control systems are shown in Figure 2 below.</p> <p> Figure 2: The four DAQs and control systems used in the tests.      </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#kraken-x4","title":"Kraken X4","text":"<p>My under-development BTT DAQ, the Bladesight Kraken X4 \ud83d\udc19 , was used to acquire the Time-of-Arrivals (ToAs) from the TQ401 eddy current sensors. </p> <p>Why did we use the Kraken? </p> <ul> <li>Because it's mine and it makes me happy.</li> <li>It has the ability to condition a -24 V to 0 V signal to a -1 to 1 V signal, thereby enabling digitization.</li> <li>It has the ability to trigger at multiple thresholds per pulse, not just one threshold.</li> <li>It digitizes the incoming signals at 125 MHz, much faster than the other systems in our lab.</li> </ul>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#hbk-quantum","title":"HBK Quantum","text":"<p>An HBK Quantum (MX410) was used to excite and measure the strain gauge. Excitation and communication to and from the strain gauge ocurred through a slip ring.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#oros-or35","title":"OROS OR35","text":"<p>An OROS OR35 DAQ was used to measure the Multiple Per Revolution (MPR), strain gauge, and three other inductive probes (TURCK BI10U-M18-AP6X). </p> <p>The OROS' sampling rate was set to 25.6 kHz.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#coco-80x-analyzer","title":"CoCo-80x analyzer","text":"<p>The motor was controlled using the output from a CoCo-80x analyzer. We could set different ramp rates using this system.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#experimental-method","title":"Experimental method","text":"<p>We define a ramp rate as the time taken to move from 0 RPM to 1450 RPM. The ramp rates for the tests were as follows: 30s, 40s, 50s, 60s, 70s, 80s, 90s, 100s, 110s, 120s. </p> <p>For each test, acquisition was performed for at least 4 cycles. Giving 4 run-ups and run-downs per test.</p> <p>Figure 3 below exhibits the first cycle of each test case.</p> <p> Figure 3: The ramp rates of each test case.     </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#multiple-triggering-levels","title":"Multiple Triggering levels","text":"<p>I've always thought it nonsensical to pick only one threshold level per channel. Some blades are longer than others. It makes sense that you should use different triggering levels for different blades.</p> <p>The Kraken X4 was programmed to trigger at 4 different levels on both the rising and falling slopes. The four levels were -0.3, -0.2, 0.1 and 0.3 V. These voltage levels are only approximate, because the Kraken conditions the signals prior to acquisition, and each signal can be conditioned differently to yield the best pulse.</p> <p>Note</p> <p>The voltage levels may be approximate, but you can bank on one thing: The triggering thresholds on the rising and falling slopes are identical.</p> <p>We therefore have 8 different ToA types per channel. Some channels do not have all 8 ToAs, depending on each blade's distance from each sensor. If the 8 triggering levels are displayed for each channel, it reveals something of the pulse shape, as indicated in Figure 4 below.  </p> <p> Figure 4: The ramp rates of each test case.     </p> <p>I believe having multiple triggering levels can be used for new kinds of analyses. This is a topic for another day.</p> <p>Note</p> <p>We did not extract multiple triggering levels for the signals acquired with the OROS.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#strain-gauge-data","title":"Strain gauge data","text":"<p>The strain gauge signals are genuinely beautiful - as you will see.</p> <p>We endeavored to calibrate the strain gauge after the tests. As things go, we put this off, and at some stage Murphy intervened by damaging the  strain gauge's attachment to the blade.</p> <p>There is no calibration data that we can use to convert the strain gauge data to tip displacement. This is a pity. We will have to make do with the raw strain gauge data.</p> <p>Fortunately, it is still a most rich dataset. The strain gauge values are in units of millivolts.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#dataset-usage","title":"Dataset usage","text":"<p>If you have not installed Bladesight, please follow the instructions in the the BTT tutorial.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#duckdb-or-pandas","title":"DuckDB or Pandas?","text":"<p>You can now use DuckDB SQL to query your datasets. Why would you want to do this? Because you can be more deliberate with which data you materialize into memory. Memory is a precious resource.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#download-the-dataset","title":"Download the dataset","text":"<p>You can download the dataset using the below code. Note that the database is ~290 Mb in size, so it may take a while to download.</p>  Pandas only I like DuckDB as well <pre><code>from bladesight import Datasets\n\nds = Datasets[\"data/diamond_et_al/2024_ramp_rates_45_deg\"]\n\nprint(ds)\n</code></pre> <p>Output:</p> <pre><code>If you use this dataset in published work, please use the below citation:\n\nDiamond, D.H (2024) Dataset - Diamond et al 2024 ramp rates at 45 degrees. https://docs.bladesight.com/tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/\nLink to paper: https://docs.bladesight.com/tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/\nDOI: None\nDataset(C:\\Users\\Dawie Diamond\\.bladesight\\data\\diamond_et_al\\2024_ramp_rates_45_deg.db),\n\nTables: \n[\n  'table/sg_100_s',\n  'table/sg_110_s',\n  'table/sg_120_s',\n  'table/sg_30_s',\n  'table/sg_40_s',\n  'table/sg_50_s',\n  'table/sg_60_s',\n  'table/sg_70_s',\n  'table/sg_80_s',\n  'table/sg_90_s',\n  'table/toas_100_s',\n  'table/toas_110_s',\n  'table/toas_120_s',\n  'table/toas_30_s',\n  'table/toas_40_s',\n  'table/toas_50_s',\n  'table/toas_60_s',\n  'table/toas_70_s',\n  'table/toas_80_s',\n  'table/toas_90_s',\n]\n</code></pre> <pre><code>from bladesight import Datasets\n\nds = Datasets[\"data/diamond_et_al/2024_ramp_rates_45_deg\"]\n\nprint(ds.query(\"DESCRIBE TABLES\"))\n</code></pre> <p>Output: <pre><code>If you use this dataset in published work, please use the below citation:\n\nDiamond, D.H (2024) Dataset - Diamond et al 2024 ramp rates at 45 degrees. https://docs.bladesight.com/tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/\nLink to paper: https://docs.bladesight.com/tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/\nDOI: None\nDataset(C:\\Users\\Dawie Diamond\\.bladesight\\data\\diamond_et_al\\2024_ramp_rates_45_deg.db),\n\n          name\n0     metadata\n1     sg_100_s\n2     sg_110_s\n3     sg_120_s\n4      sg_30_s\n5      sg_40_s\n6      sg_50_s\n7      sg_60_s\n8      sg_70_s\n9      sg_80_s\n10     sg_90_s\n11  toas_100_s\n12  toas_110_s\n13  toas_120_s\n14   toas_30_s\n15   toas_40_s\n16   toas_50_s\n17   toas_60_s\n18   toas_70_s\n19   toas_80_s\n20   toas_90_s\n</code></pre></p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#tables","title":"Tables","text":"<p>As you can see above, there are many tables in the dataset. The different tables contain the ToAs and strain gauge data for the different ramp rates.</p> <p>The tables containing the toas are:</p> <ul> <li><code>toas_30_s</code></li> <li><code>toas_40_s</code></li> <li><code>toas_50_s</code></li> <li><code>toas_60_s</code></li> <li><code>toas_70_s</code></li> <li><code>toas_80_s</code></li> <li><code>toas_90_s</code></li> <li><code>toas_100_s</code></li> <li><code>toas_110_s</code></li> <li><code>toas_120_s</code></li> </ul> <p>Let's take a look at the first 10 rows of the <code>toas_30_s</code> table:</p>  Pandas only I like DuckDB as well <pre><code>df_toas_30_s = ds[\"toas_30_s\"]\nprint(df_toas_30_s.head(10))\n</code></pre> <p>Output:</p> <pre><code>      channel        toa  voltage  is_rising\n0  Kraken OPR  10.170276     -0.3       True\n1  Kraken OPR  10.170459     -0.2       True\n2  Kraken OPR  10.170639      0.1       True\n3  Kraken OPR  10.170820      0.3       True\n4  Kraken OPR  10.179263      0.3      False\n5  Kraken OPR  10.179440      0.1      False\n6  Kraken OPR  10.179612     -0.2      False\n7  Kraken OPR  10.179777     -0.3      False\n8  Kraken OPR  10.269662     -0.3       True\n9  Kraken OPR  10.269845     -0.2       True\n</code></pre> <pre><code>df_toas_30_s = ds.query(\"SELECT * FROM toas_30_s LIMIT 10\")\nprint(df_toas_30_s)\n</code></pre> <p>Output:</p> <pre><code>      channel        toa  voltage  is_rising\n0  Kraken OPR  10.170276     -0.3       True\n1  Kraken OPR  10.170459     -0.2       True\n2  Kraken OPR  10.170639      0.1       True\n3  Kraken OPR  10.170820      0.3       True\n4  Kraken OPR  10.179263      0.3      False\n5  Kraken OPR  10.179440      0.1      False\n6  Kraken OPR  10.179612     -0.2      False\n7  Kraken OPR  10.179777     -0.3      False\n8  Kraken OPR  10.269662     -0.3       True\n9  Kraken OPR  10.269845     -0.2       True\n</code></pre> <p>The <code>toa</code>, <code>voltage</code> and <code>is_rising</code> columns are self-explanatory. The <code>channel</code> column contains the acquisition channel. The following channels exist:</p> <ul> <li><code>Kraken OPR</code> : The OPR sensor as measured by the Kraken X4.</li> <li><code>OROS OPR</code>: The OPR sensor as measured by the OROS OR35. Only one threshold level, on the rising edge at 0V was extracted.</li> <li><code>OROS MPR</code>: The MPR sensor as measured by the OROS OR35. Only one threshold level, on the rising edge at 2.5V was extracted.</li> <li><code>Kraken Probe 1</code>: The first proximity probe as measured by the Kraken X4.</li> <li><code>Kraken Probe 2</code>: The second proximity probe as measured by the Kraken X4.</li> <li><code>OROS IP Probe 1</code>: The first TURCK BI10U-M18-AP6X inductive proximity probe as measured by the OROS OR35.</li> <li><code>OROS IP Probe 2</code>: The second inductive proximity probe as measured by the OROS OR35.</li> <li><code>OROS IP Probe 3</code>: The third inductive proximity probe as measured by the OROS OR35.</li> </ul> <p>The tables containing the strain gauge data are:</p> <ul> <li><code>sg_30_s</code></li> <li><code>sg_40_s</code></li> <li><code>sg_50_s</code></li> <li><code>sg_60_s</code></li> <li><code>sg_70_s</code></li> <li><code>sg_80_s</code></li> <li><code>sg_90_s</code></li> <li><code>sg_100_s</code></li> <li><code>sg_110_s</code></li> <li><code>sg_120_s</code></li> </ul> <p>Let's consider the first 10 rows of the <code>sg_30_s</code> table:</p>  Pandas only I like DuckDB as well <pre><code>df_toas_30_s = ds[\"table/sg_30_s\"]\nprint(df_toas_30_s.head(10))\n</code></pre> <p>Output:</p> <pre><code>  voltage\n0    -1.28\n1    -1.31\n2    -1.17\n3    -0.85\n4    -0.90\n5    -0.93\n6    -0.98\n7    -0.93\n8    -0.89\n9    -0.89\n</code></pre> <pre><code>df_toas_30_s = ds.query(\"SELECT * FROM sg_30_s LIMIT 10\")\nprint(df_toas_30_s)\n</code></pre> <p>Output:</p> <pre><code>  voltage\n0    -1.28\n1    -1.31\n2    -1.17\n3    -0.85\n4    -0.90\n5    -0.93\n6    -0.98\n7    -0.93\n8    -0.89\n9    -0.89\n</code></pre> <p>You will note that there is no time column in the strain gauge data. You need to create your own time column. Here's an example of how you can do this:</p>  Pandas only I like DuckDB as well <pre><code>df_toas_30_s = ds[\"table/sg_30_s\"]\ndf_toas_30_s[\"t\"] = pd.Series(range(len(df_toas_30_s))) * 1/25.6e3\nprint(df_toas_30_s.head(10))\n</code></pre> <p>Output:</p> <pre><code>  voltage         t\n0    -1.28  0.000000\n1    -1.31  0.000039\n2    -1.17  0.000078\n3    -0.85  0.000117\n4    -0.90  0.000156\n5    -0.93  0.000195\n6    -0.98  0.000234\n7    -0.93  0.000273\n8    -0.89  0.000313\n9    -0.89  0.000352\n</code></pre> <pre><code>df_toas_30_s = ds.query(\n\"\"\"\n  SELECT\n    (row_number() OVER () -  1)*(1/25.6e3) as t,\n    voltage,\n  FROM \n    sg_30_s\n  LIMIT 10\n\"\"\"\n)\nprint(df_toas_30_s)\n</code></pre> <p>Output:</p> <pre><code>          t  voltage\n0  0.000000    -1.28\n1  0.000039    -1.31\n2  0.000078    -1.17\n3  0.000117    -0.85\n4  0.000156    -0.90\n5  0.000195    -0.93\n6  0.000234    -0.98\n7  0.000273    -0.93\n8  0.000313    -0.89\n9  0.000352    -0.89\n</code></pre>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#full-analyses","title":"Full analyses \ud83d\udc47","text":"","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#opr-encoder","title":"OPR encoder","text":"<p>Here's some code to get you started with this dataset using the OPR encoder.</p>  Pandas only I like DuckDB as well <pre><code>from bladesight import Datasets #(1)!\nfrom bladesight.btt import get_rotor_blade_AoAs\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport numpy as np\n\nTACHO_CHANNEL, TACHO_VOLTAGE, TACHO_RISING = \"Kraken OPR\" ,0.1, True #(2)!\nPROBE1_CHANNEL, PROBE1_VOLTAGE, PROBE1_RISING = \"Kraken Probe 1\", 0.1, True #(3)!\nPROBE2_CHANNEL, PROBE2_VOLTAGE, PROBE2_RISING = \"Kraken Probe 2\", 0.1, True #(4)!\nTEST_CASE_NAME = 'toas_30_s' #(5)!\nR, B, probe_spacing = 164_000, 5, 20.1 #(6)!\n\nds = Datasets[\"data/diamond_et_al/2024_ramp_rates_45_deg\"] #(7)!\ndf_toas = ds[f'table/{TEST_CASE_NAME}'] #(8)!\n\nblades_AoAs = get_rotor_blade_AoAs(\n    df_toas.query(\"(channel == @TACHO_CHANNEL) &amp; (voltage == @TACHO_VOLTAGE) &amp; (is_rising == @TACHO_RISING)\")['toa'],\n    [\n        df_toas.query(\"(channel == @PROBE1_CHANNEL) &amp; (voltage == @PROBE1_VOLTAGE) &amp; (is_rising == @PROBE1_RISING)\")['toa'],\n        df_toas.query(\"(channel == @PROBE2_CHANNEL) &amp; (voltage == @PROBE2_VOLTAGE) &amp; (is_rising == @PROBE2_RISING)\")['toa']\n    ],\n    probe_spacings=np.deg2rad([probe_spacing]),\n    B=B,\n    is_mpr=False\n)#(9)!\n\ndf_blade_sg = blades_AoAs[-1]#(10)!\ndf_blade_sg['x1'] = (df_blade_sg[\"AoA_p1\"] - df_blade_sg[\"AoA_p1\"].median()) * R#(11)!\ndf_blade_sg['x2'] = (df_blade_sg[\"AoA_p2\"] - df_blade_sg[\"AoA_p2\"].median()) * R\n\nfig = make_subplots(specs=[[{\"secondary_y\": True}]]) #(12)!\n\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"ToA_p1\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"x1\"],\n        mode=\"lines+markers\",\n        name=\"Blade 5 Probe 1 deflection\"\n    ),\n    secondary_y=False\n)\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"ToA_p2\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"x2\"],\n        mode=\"lines+markers\",\n        name=\"Blade 5 Probe 2 deflection\"\n    ),\n    secondary_y=False\n)\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"n_start_time\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"Omega\"]*60/(2*np.pi),\n        mode=\"lines+markers\",\n        name=\"Shaft speed [RPM]\"\n    ),\n    secondary_y=True\n)\n\nfig.update_layout(\n    title=\"Blade 5 deflection for the first cycle on the 30s ramp rate test case\",\n    xaxis_title=\"Time [s]\",\n    yaxis_title=\"x [\u03bcm]\"\n)\n</code></pre> <ol> <li>Import the necessary libraries.</li> <li>Take the OPR from the Kraken at 0.1V on the rising edge.</li> <li>Take the first Probe from the Kraken at 0.1V on the rising edge.</li> <li>Take second Probe from the Kraken at 0.1V on the rising edge.</li> <li>The 30s ramp test case.</li> <li>The blade radius, number of blades and probe spacing.</li> <li>Load the dataset.</li> <li>Load the ToAs for the 30s ramp test case.</li> <li>Get the rotor blade AoAs.</li> <li>Get the strain gauge data for the last blade.</li> <li>Calculate the deflection.</li> <li>Create the plot.</li> </ol> <p>Output:</p> <p> Figure 5: The first cycle of the 30s ramp rate test case.      </p> <pre><code>from bladesight import Datasets #(1)!\nfrom bladesight.btt import get_rotor_blade_AoAs\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport numpy as np\n\nTACHO_CHANNEL, TACHO_VOLTAGE, TACHO_RISING = \"Kraken OPR\" ,0.1, True #(2)!\nPROBE1_CHANNEL, PROBE1_VOLTAGE, PROBE1_RISING = \"Kraken Probe 1\", 0.1, True #(3)!\nPROBE2_CHANNEL, PROBE2_VOLTAGE, PROBE2_RISING = \"Kraken Probe 2\", 0.1, True #(4)!\nTEST_CASE_NAME = 'toas_30_s' #(5)!\nR, B, probe_spacing = 164_000, 5, 20.1 #(6)!\n\nds = Datasets[\"data/diamond_et_al/2024_ramp_rates_45_deg\"] #(7)!\nduckdb_query = \"\"\"\nSELECT \n    toa\nFROM \n    {0}\nWHERE\n    channel = '{1}' AND voltage = {2} AND is_rising = {3}\n\"\"\" #(8)!\nblades_AoAs = get_rotor_blade_AoAs(\n    ds.query(duckdb_query.format(TEST_CASE_NAME, TACHO_CHANNEL, TACHO_VOLTAGE, TACHO_RISING)),\n    [\n        ds.query(duckdb_query.format(TEST_CASE_NAME, PROBE1_CHANNEL, PROBE1_VOLTAGE, PROBE1_RISING)),\n        ds.query(duckdb_query.format(TEST_CASE_NAME, PROBE2_CHANNEL, PROBE2_VOLTAGE, PROBE2_RISING))\n    ],\n    probe_spacings=np.deg2rad([probe_spacing]),\n    B=B,\n    is_mpr=False\n) #(9)!\n\ndf_blade_sg = blades_AoAs[-1] #(10)!\ndf_blade_sg['x1'] = (df_blade_sg[\"AoA_p1\"] - df_blade_sg[\"AoA_p1\"].median()) * R #(11)!\ndf_blade_sg['x2'] = (df_blade_sg[\"AoA_p2\"] - df_blade_sg[\"AoA_p2\"].median()) * R\n\n# Start a two y axis plot\nfig = make_subplots(specs=[[{\"secondary_y\": True}]]) #(12)!\n\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"ToA_p1\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"x1\"],\n        mode=\"lines+markers\",\n        name=\"Blade 5 Probe 1 deflection\"\n    ),\n    secondary_y=False\n)\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"ToA_p2\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"x2\"],\n        mode=\"lines+markers\",\n        name=\"Blade 5 Probe 2 deflection\"\n    ),\n    secondary_y=False\n)\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"n_start_time\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"Omega\"]*60/(2*np.pi),\n        mode=\"lines+markers\",\n        name=\"Shaft speed [RPM]\"\n    ),\n    secondary_y=True\n)\n\nfig.update_layout(\n    title=\"Blade 5 deflection for the first cycle on the 30s ramp rate test case\",\n    xaxis_title=\"Time [s]\",\n    yaxis_title=\"x [\u03bcm]\",\n    template=\"plotly_white\",\n    xaxis=dict(showgrid=True, gridcolor='rgb(217, 217, 217)', gridwidth=1),\n    yaxis=dict(showgrid=True, gridcolor='rgb(217, 217, 217)', gridwidth=1),\n)\n</code></pre> <ol> <li>Import the necessary libraries.</li> <li>Take the OPR from the Kraken at 0.1V on the rising edge.</li> <li>Take the first Probe from the Kraken at 0.1V on the rising edge.</li> <li>Take second Probe from the Kraken at 0.1V on the rising edge.</li> <li>The 30s ramp test case.</li> <li>The blade radius, number of blades and probe spacing.</li> <li>Load the dataset.</li> <li>Define a formattable DuckDB query.</li> <li>Get the rotor blade AoAs.</li> <li>Get the strain gauge data for the last blade.</li> <li>Calculate the deflection.</li> <li>Create the plot.</li> </ol> <p>Output:</p> <p> Figure 6: The first cycle of the 30s ramp rate test case.      </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#mpr-encoder","title":"MPR encoder","text":"<p>Only the OROS was used to capture the MPR data. The MPR data is stored in the 'OROS MPR' channel.</p>  Pandas only I like DuckDB as well <pre><code>from bladesight import Datasets\nfrom bladesight.btt import get_rotor_blade_AoAs\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport numpy as np\nfrom bladesight.ias import calculate_ias #(1)!\n\nTACHO_CHANNEL, TACHO_VOLTAGE, TACHO_RISING = \"OROS MPR\" , 2.5, True #(2)!\nPROBE1_CHANNEL, PROBE1_VOLTAGE, PROBE1_RISING = \"Kraken Probe 1\", 0.1, True\nPROBE2_CHANNEL, PROBE2_VOLTAGE, PROBE2_RISING = \"Kraken Probe 2\", 0.1, True\nTEST_CASE_NAME = 'toas_30_s'\nR, B, probe_spacing = 164_000, 5, 20.1\n\nds = Datasets[\"data/diamond_et_al/2024_ramp_rates_45_deg\"]\ndf_toas = ds[f'table/{TEST_CASE_NAME}']\n\nblades_AoAs = get_rotor_blade_AoAs(\n    calculate_ias(#(3)!\n        df_toas.query(\"(channel == @TACHO_CHANNEL) &amp; (voltage == @TACHO_VOLTAGE) &amp; (is_rising == @TACHO_RISING)\")['toa'],\n        80\n    ),\n    [\n        df_toas.query(\"(channel == @PROBE1_CHANNEL) &amp; (voltage == @PROBE1_VOLTAGE) &amp; (is_rising == @PROBE1_RISING)\")['toa'],\n        df_toas.query(\"(channel == @PROBE2_CHANNEL) &amp; (voltage == @PROBE2_VOLTAGE) &amp; (is_rising == @PROBE2_RISING)\")['toa']\n    ],\n    probe_spacings=np.deg2rad([probe_spacing]),\n    B=B,\n    is_mpr=True #(4)!\n)\n\ndf_blade_sg = blades_AoAs[3] #(5)!\ndf_blade_sg['x1'] = (df_blade_sg[\"AoA_p1\"] - df_blade_sg[\"AoA_p1\"].median()) * R\ndf_blade_sg['x2'] = (df_blade_sg[\"AoA_p2\"] - df_blade_sg[\"AoA_p2\"].median()) * R\n\n# Start a two y axis plot\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"ToA_p1\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"x1\"],\n        mode=\"lines+markers\",\n        name=\"Blade 5 Probe 1 deflection\"\n    ),\n    secondary_y=False\n)\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"ToA_p2\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"x2\"],\n        mode=\"lines+markers\",\n        name=\"Blade 5 Probe 2 deflection\"\n    ),\n    secondary_y=False\n)\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"section_start_time\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"Omega\"]*60/(2*np.pi),\n        mode=\"lines+markers\",\n        name=\"Shaft speed [RPM]\"\n    ),\n    secondary_y=True\n)\n\nfig.update_layout(\n    title=\"Blade 5 deflection for the first cycle on the 30s ramp rate test case\",\n    xaxis_title=\"Time [s]\",\n    yaxis_title=\"x [\u03bcm]\",\n    template=\"plotly_white\",\n    xaxis=dict(showgrid=True, gridcolor='rgb(217, 217, 217)', gridwidth=1),\n    yaxis=dict(showgrid=True, gridcolor='rgb(217, 217, 217)', gridwidth=1),\n)\n</code></pre> <ol> <li>Note that we import the <code>calculate_ias</code> function.</li> <li>Take the MPR from the OROS at 2.5V on the rising edge.</li> <li>Calculate the IAS.</li> <li>Set the <code>is_mpr</code> parameter to <code>True</code>.</li> <li>The MPR <code>calculate_ias</code> function aligns the MPR so that the largest (or smallest) section is always the start of the revolution. As it happens, our strain gauge data is now the 4th element in the <code>blades_AoAs</code> list. How do I know this? I just flipped through the blades until I found the blade with the same ToAs as the OPR case.</li> </ol> <p>Output:</p> <p> Figure 7: The first cycle of the 30s ramp rate test case using the MPR encoder.      </p> <pre><code>from bladesight import Datasets\nfrom bladesight.btt import get_rotor_blade_AoAs\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport numpy as np\nfrom bladesight.ias import calculate_ias #(1)!\n\nTACHO_CHANNEL, TACHO_VOLTAGE, TACHO_RISING = \"OROS MPR\" , 2.5, True #(2)!\nPROBE1_CHANNEL, PROBE1_VOLTAGE, PROBE1_RISING = \"Kraken Probe 1\", 0.1, True\nPROBE2_CHANNEL, PROBE2_VOLTAGE, PROBE2_RISING = \"Kraken Probe 2\", 0.1, True\nTEST_CASE_NAME = 'toas_30_s'\nR, B, probe_spacing = 164_000, 5, 20.1\n\nds = Datasets[\"data/diamond_et_al/2024_ramp_rates_45_deg\"]\n\nduckdb_query = \"\"\"\nSELECT \n    toa\nFROM \n    {0}\nWHERE\n    channel = '{1}' AND voltage = {2} AND is_rising = {3}\n\"\"\"\nblades_AoAs = get_rotor_blade_AoAs(\n    calculate_ias( #(3)!\n        ds.query(duckdb_query.format(TEST_CASE_NAME, TACHO_CHANNEL, TACHO_VOLTAGE, TACHO_RISING)),\n        80\n    ),\n    [\n        ds.query(duckdb_query.format(TEST_CASE_NAME, PROBE1_CHANNEL, PROBE1_VOLTAGE, PROBE1_RISING)),\n        ds.query(duckdb_query.format(TEST_CASE_NAME, PROBE2_CHANNEL, PROBE2_VOLTAGE, PROBE2_RISING))\n    ],\n    probe_spacings=np.deg2rad([probe_spacing]),\n    B=B,\n    is_mpr=True #(4)!\n)\n\ndf_blade_sg = blades_AoAs[3] #(5)!\ndf_blade_sg['x1'] = (df_blade_sg[\"AoA_p1\"] - df_blade_sg[\"AoA_p1\"].median()) * R\ndf_blade_sg['x2'] = (df_blade_sg[\"AoA_p2\"] - df_blade_sg[\"AoA_p2\"].median()) * R\n\n# Start a two y axis plot\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"ToA_p1\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"x1\"],\n        mode=\"lines+markers\",\n        name=\"Blade 5 Probe 1 deflection\"\n    ),\n    secondary_y=False\n)\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"ToA_p2\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"x2\"],\n        mode=\"lines+markers\",\n        name=\"Blade 5 Probe 2 deflection\"\n    ),\n    secondary_y=False\n)\nfig.add_trace(\n    go.Scattergl(\n        x=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"section_start_time\"],\n        y=df_blade_sg.query(\"ToA_p1 &gt; 15 and ToA_p1 &lt; 41 \")[\"Omega\"]*60/(2*np.pi),\n        mode=\"lines+markers\",\n        name=\"Shaft speed [RPM]\"\n    ),\n    secondary_y=True\n)\n\nfig.update_layout(\n    title=\"Blade 5 deflection for the first cycle on the 30s ramp rate test case\",\n    xaxis_title=\"Time [s]\",\n    yaxis_title=\"x [\u03bcm]\",\n    template=\"plotly_white\",\n    xaxis=dict(showgrid=True, gridcolor='rgb(217, 217, 217)', gridwidth=1),\n    yaxis=dict(showgrid=True, gridcolor='rgb(217, 217, 217)', gridwidth=1),\n)\n</code></pre> <ol> <li>Note that we import the <code>calculate_ias</code> function.</li> <li>Take the MPR from the OROS at 2.5V on the rising edge.</li> <li>Calculate the IAS.</li> <li>Set the <code>is_mpr</code> parameter to <code>True</code>.</li> <li>The MPR <code>calculate_ias</code> function aligns the MPR so that the largest (or smallest) section is always the start of the revolution. As it happens, our strain gauge data is now the 4th element in the <code>blades_AoAs</code> list. How do I know this? I just flipped through the blades until I found the blade with the same ToAs as the OPR case.</li> </ol> <p>Output:</p> <p> Figure 8: The first cycle of the 30s ramp rate test case using the MPR encoder.      </p> <p>Hint</p> <p>The <code>calculate_ias</code> function is used to calculate the IAS from the MPR data. You can save the result of this calculation for posterity like so:</p> <pre><code>ds[\"ias_30_s\"] = calculate_ias(\n    ds.query(duckdb_query.format(TEST_CASE_NAME, TACHO_CHANNEL, TACHO_VOLTAGE, TACHO_RISING)),\n    80\n)\n</code></pre> <p>Then simply query the <code>ias_30_s</code> table to get the IAS data.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#conclusion","title":"Conclusion","text":"<p>I hope you have fun. I believe there are many unexplored avenues in this dataset.</p> <p>If you have any questions or need help with the dataset, please feel free to reach out to me at dawie.diamond@bladesight.com . Also, if you find any bugs in the library, please reach out to me \ud83d\ude4f.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/datasets/diamond_et_al_2024_vary_ramp_rates_45/#acknowledgements","title":"Acknowledgements","text":"<p>A big thanks to the University of Pretoria for providing the test bench and the laboratory space to conduct these tests.</p> 2024-03-12 <p> Dawie Diamond </p> <p> Justin Smith </p> <p> Alex Brocco </p> <ol> <li> <p>Zhi, F., Duan, F., Liu, M., Niu, G., Jiao, J., Deng, Z., Jiang, J., Fu, X., 2022. Error revising of blade tip-timing parameter identification caused by frequency sweep rate. Measurement 201, 111681.\u00a0\u21a9</p> </li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/afterword/","title":"Afterword","text":"<p>Thank you so much for sticking with me on this tutorial. I know everyone's time is valuable, and I appreciate you spending some of yours with me. </p> <p>If you're new to Python, I hope you've learned a lot. If you're a Python veteran, I hope you've learned a little.</p> <p>I hope the material has put you in a position to start your BTT journey.</p> <p>If you have any suggestions, questions, or comments, please feel free to reach out to me at dawie.diamond@bladesight.com.</p> <p>If you've found this tutorial helpful, please consider sharing it with your friends and colleagues. It would also be awesome if you can start the Github repo for this tutorial:  https://github.com/Bladesight/Bladesight.</p> <p> Dawie Diamond </p> <p>             2024-03-26         </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch1/","title":"1. Blade Tip Timing's fundamental principle","text":"Reviews <p>Please read through the chapter prior to activating a review as I have kept the chapters deliberately terse. </p> <p>Click to activate a review \ud83d\udc47 for more detailed comments from other experts.</p> <p>     Miros\u0142aw Wito\u015b </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch1/#blade-tip-timings-fundamental-principle","title":"Blade Tip Timing's fundamental principle","text":"","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch1/#whos-this-tutorial-for","title":"Who's this tutorial for?","text":"<p>This tutorial is for graduate students who want to use Blade Tip Timing (BTT) to measure rotor blade vibration. One of the earliest prominent BTT references is a 1967 article by Rudolph Hohenberg (Hohenberg, 1967)<sup>1</sup>. There are, however, much older references found in patents (Campbell, 1924)<sup>2</sup> (Mershon, 1937)<sup>3</sup> (Hardigg, 1949)<sup>4</sup> (Shapiro, 1958)<sup>5</sup>. BTT has therefore been around for approximately 100 years. It is strange that so few getting-started resources for BTT exist. There have been academic publications that serve this end (Bouckaert, 2007)<sup>6</sup> (Witos, 2011)<sup>7</sup>, but I am unaware of a single book or tutorial dedicated to BTT. </p> <p>Instead, students are expected to deep dive into old journal articles and figure it out for themselves. I have no doubt that most mechanical engineering graduate students are intellectually gifted enough to achieve this. The pressure to finish your studies on time, however, can be immense. BTT is a great discipline. You should be excited to learn it. We cannot permit submission dates to ruin the subject.</p> <p>That's why I've created this tutorial. To help others learn the fundamentals as fast as possible.</p> <p>I have compiled the most fundamental BTT concepts into a single resource. The core concepts are explained alongside code and example datasets. The Python  programming language won the challenge as the language of choice. Python's popularity has surged in recent years, mostly due to its adoption in Machine Learning (ML) and Artificial Intelligence (AI). It is well poised to also take over the other engineering disciplines. Any time spent coding in Python is an excellent investment... and its value scales well beyond BTT.</p> <p>The coding exercises might take more time than simply reading through the text and nodding along. However, when you grant yourself permission to spend time on the fundamentals, it leads to exponential progress later on.</p> <p>By the end of this tutorial, you'll have been exposed to the fundamental theory and code that will enable you to process raw BTT data into vibration frequency, amplitude, and phase estimates.</p> <p>What qualifies me to write a tutorial about BTT?</p> <p>I do not claim to be the authority on BTT data processing. I have, however, wrestled with BTT for longer than 10 years. I have rewritten BTT algorithms and approaches from scratch several times. Each time, I uncovered something more fundamental. I learned how to cut away unnecessary steps and focus on the essentials. </p> <p>Hopefully, you can use what I've started with here... and take it further.</p> <p>Chapter outcomes</p> <p> Understand that this tutorial is for graduate students who seek a code-first treatment of the fundamentals of BTT .</p> <p> Understand that the entire discipline of BTT is built from time stamps.</p> <p> Understand that each time stamp has several attributes associated with it. BTT is concerned with figuring out these attributes.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch1/#blade-tip-timing-and-time-stamps","title":"Blade Tip Timing and Time Stamps","text":"<p>George Berkely, an 18th century philosopher, created beautiful literature while criticizing Newton's approach to calculus. Puzzled by one of the entities introduced by Newton, he wrote:</p> <p>Quote (Berkeley, 1754)<sup>8</sup></p> <p>And what are these Fluxions? The velocities of evanescent increments? ... They are neither finite Quantities nor Quantities infinitely small, nor yet nothing. May we not call them the Ghosts of departed Quantities?</p> <p>I admire the way he confers a sense of mystery onto infinitesimal entities (i.e. fluxions). This quote often comes to mind when I process BTT data. BTT measurements are not directly proportional to the output of the measurement device. This stands in contrast to, for example, accelerometer or strain gauge measurements. You only need to scale these raw voltages to produce the engineering quantity of interest. </p> <p>BTT measurements are the ghosts of departed time stamps.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch1/#time-shifts-and-tip-deflections","title":"Time shifts and tip deflections","text":"<p>Rotor blades, being rigid structures, vibrate in response to dynamic loads.  They vibrate because of the aerodynamic forces experienced during operation. BTT exploits the fact that the tips move relative to the shaft's position.</p> <p>The fundamental concept behind BTT is illustrated in Figure 1 below. </p> <p> Figure 1: An illustration of the fundamental principle behind BTT. </p> <p>On the left hand side of Figure 1, a rotor is shown. Positions A and B indicate the top blade's minimum and maximum deflections due to vibration. </p> <p>A sensor is mounted in the rotor's casing. The sensor generates a voltage pulse in its output signal in response to the presence of the passing blade.</p> <p>Tip deflections cause the pulse to shift relative to the signal produced by a \"non-vibrating\" blade. If the tip is deflected backward (position A), it causes the pulse to lag. If the tip is deflected forward (position B), it causes the pulse to lead.</p> <p>The Time of Arrival (ToA) is extracted from each pulse. A ToA is the exact time, in seconds, that a blade is said to have arrived at the sensor.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch1/#each-toa-is-a-puzzle-to-be-solved","title":"Each ToA is a puzzle to be solved","text":"<p>ToAs have other attributes that must be determined. Each ToA has 6 attributes associated with it. </p> <p>These attributes are best defined by a series of questions, as shown in Figure 2 below.</p> <p> Figure 1: The outline of this tutorial. Each ToA  has 6 attributes associated with it. Extraction of each ToA is covered in Chapter 2. Chapters 3 - 9 determines the other attributes. </p> <p>I've structured this tutorial to sequentially answer these questions. Each chapter will focus on one or more of the ToA's attributes.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch1/#conclusion","title":"Conclusion","text":"<p>If you grasp Figure 1, you grasp the fundamental concept at the heart of BTT. However, don't underestimate the challenge that lies ahead. If tip deflections are, in fact, the ghosts of departed timestamps, they do not reveal themselves easily.    </p> <p>Chapter Outcomes</p> <p> Understand that this tutorial is for graduate students who seek a code-first treatment of the fundamentals of BTT .</p> <p> Understand that the entire discipline of BTT is built from time stamps.</p> <p> Understand that each time stamp has several attributes associated with it. BTT is concerned with figuring out these attributes.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch1/#acknowledgements","title":"Acknowledgements","text":"<p>A big thanks to Justin Smith and Alex Brocco for their feedback and suggestions regarding this chapter.</p> <p>A special thanks to Miros\u0142aw Wito\u015b for his detailed review of this chapter.</p> <p> Dawie Diamond </p> <p> 2024-01-30 2025-01-30              </p> <ol> <li> <p>Hohenberg, R., 1967. Detection and study of compressor-blade vibration. Experimental Mechanics 7, 19A--24A.\u00a0\u21a9</p> </li> <li> <p>Campbell, W., 1924. Elastic-fluid turbine rotor and method of avoiding tangential bucket vibration therein. Patent US 1,502,904. https://patents.google.com/patent/US1502904.\u00a0\u21a9</p> </li> <li> <p>Mershon, A.V., 1937. Vibration indicator. US Patent 2,204,425A. https://patents.google.com/patent/US2204425.\u00a0\u21a9</p> </li> <li> <p>Hardigg, G.W., 1949. Apparatus for measuring rotor blade vibration. Patent US 2,575,710. https://patents.google.com/patent/US2575710.\u00a0\u21a9</p> </li> <li> <p>Shapiro, H., 1958. Vibration detector and measuring instrument. US Patent 3,058,339A. https://patents.google.com/patent/US3058339.\u00a0\u21a9</p> </li> <li> <p>Bouckaert, J.F., 2007. Tip timing and tip clearance problem in turbomachines. VKI Lecture Series 2007-03 03.\u00a0\u21a9</p> </li> <li> <p>Witos, M., 2011. Increasing the durability of turbine engines through active diagnostics and control (pol.). Research Works of Air Force Institute of Technology 29, 1--324(http://dx.doi.org/10.13140/RG.2.1.4341.4560.).\u00a0\u21a9</p> </li> <li> <p>Berkeley, G., 1754. The analyst, or, a discourse addressed to an infidel mathematician... J.; R. Tonson; S. Draper.\u00a0\u21a9</p> </li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/","title":"2. Time of Arrival (ToA)","text":"You are here Reviews <p>Please read through the chapter prior to activating a review as I have kept the chapters deliberately terse. </p> <p>Click to activate a review \ud83d\udc47 for more detailed comments from other experts.</p> <p>     Miros\u0142aw Wito\u015b </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#time-of-arrival-toa","title":"Time of Arrival (ToA)","text":"<p>In the previous chapter, we've established that blade vibration causes the tips to move relative to the shaft's position. A deflected tip causes a shift in the proximity probe's waveform. The size of the shift is proportional to the deflection.</p> <p>So, how do we calculate the size of the shift?</p> <p>To determine this, we need the exact instant a blade moved past a probe. This instant is referred to as the Time of Arrival (ToA). Each ToA is the result of applying a trigger criterion to each pulse. Let's consider four trigger criteria.</p> <p>Chapter outcomes</p> <p> Understand that we need to implement a trigger criterion to determine the ToA of each pulse.</p> <p> Understand the constant-threshold trigger method's principle.</p> <p> Understand the detrimental effects of noise on the trigger criterion.</p> <p> Understand how to implement hysteresis to prevent multiple trigger events.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#trigger-criteria","title":"Trigger criteria","text":"<p>Several ToA trigger criteria have been discussed in literature (Zimmer, 2008)<sup>1</sup> (Diamond et al., 2021)<sup>2</sup>. Four of the most common ones are shown in Figure 1 below.</p> <p> Figure 1: Four common trigger criteria. They are A) the constant threshold trigger method, B) the maximum-slope method, C) the constant-fraction crossing method, and D) the maximum amplitude method.</p> <p>Here's the principle behind each criterion:</p> <ol> <li> The constant threshold trigger method: A ToA is triggered when the signal crosses a predefined threshold.     </li> <li> The maximum slope method: A ToA is registered when the pulse's rate of change, or slope, is at its maximum.     </li> <li> The constant-fraction crossing method: Similar to method A), but the threshold level is calculated as a percentage drop from the pulse's maximum voltage level.     </li> <li> The maximum voltage method: The ToA occurs when the pulse is at its maximum.      </li> </ol> <p>We start our journey to convert raw BTT data into blade frequency, amplitude and phase by selecting one of these methods. Based on its simplicity, accuracy (Diamond et al., 2021)<sup>2</sup> and widespread adoption, we choose the constant threshold method.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#constant-threshold-trigger-method","title":"Constant threshold trigger method","text":"<p>This method continuously compares a probe's signal to a voltage threshold. Each time the threshold is crossed, a ToA is recorded.</p> <p>An idealized pulse generated by a blade as it passes a probe is shown in Figure 2. A trigger threshold of 0.4 V has been set. The moment the voltage signal crosses this level, at approximately 40 \\(\\mu\\)s, the ToA is registered. </p> Figure 2: An illustration of the constant threshold method applied to an idealized pulse. A ToA is registered when the signal crosses the 0.4 V threshold level.  <p>Before we get into the code, let's get you operational with Python and this tutorial's supplementary material.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#bladesight-package","title":"Bladesight package","text":"<p>I have released a  <code>pip</code> installable package, called <code>bladesight</code>, you can use to access this tutorial's datasets and functions.</p> <p>The Pypi package can be found here: https://pypi.org/project/bladesight/. The Github repo can be found here: https://github.com/Bladesight/Bladesight.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#follow-along-with-the-worksheet","title":"Follow along with the worksheet","text":"<p>This BTT tutorial is code-centric. </p> <p>The concepts are explained with reproducible code. I've collected the code examples for each chapter into its own Jupyter worksheet. The worksheets can be accessed at this Github repo:</p> <p>     https://github.com/Bladesight/bladesight-worksheets </p> <p>Please resist the urge to skip the worksheets. The biggest stumbling block to learning BTT (and many subjects for that matter) is not the theory. It's to understand how the theory is implemented. Getting into the code will pay off in the long run.</p> <p>You can execute the worksheets in two environments:</p> <ol> <li>Google Colab, and </li> <li>a local installation</li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#google-colab","title":"Google Colab","text":"<p>Google Colab allows you to run Jupyter notebooks in the cloud. You can open the Google Colab notebook for this chapter by clicking on the link below:</p> <p></p> <p>You need a Google account to use Colab. If you don't have one, you can create one for free here.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#local-python-installation","title":"Local Python installation","text":"<p>At some stage you'll want to set up your local environment to do your own development. I'll guide you through the process. If you can already set up a local Python environment, skip this section.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#python-version","title":"Python version","text":"<p>Here is an excellent (and entertaining)  video on how to install Python on Windows. Please note: the <code>bladesight</code> package only works on Python 3.9, 3.10 and 3.11. It does not yet work on versions 3.12 and 3.13. If you do not have a compatible version of Python installed, you can download it here.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#virtual-environments","title":"Virtual environments","text":"<p>Virtual environments are an excellent way to isolate different Python projects from one another. I highly recommend setting one up. </p> <p>On Windows, you can use these steps to set up a virtual environment:</p> <ol> <li> <p>Go to the directory where you want to create the virtual environment. In my case it is <code>\"C:\\Users\\Dawie Diamond\\intro_to_btt\\\"</code>. </p> </li> <li> <p>Open a command prompt in the directory. In Windows 11, this can be achieved in one of two ways: </p> <ol> <li> <p>Type <code>cmd</code> in the address bar of the directory:</p> <p></p> <p> Press enter after typing <code>cmd</code>. </p> <p>A command prompt should open.</p> </li> <li> <p>You can also right click in the directory and select \"Open in Terminal\":</p> <p></p> </li> </ol> </li> <li> <p>Type the following command into the command prompt to create a virtual environment called <code>venv</code>:     <pre><code>python -m venv venv\n</code></pre></p> </li> <li> <p>Run the below command to activate the virtual environment:     <pre><code>venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Execute the below instruction to install the bladesight package:     <pre><code>pip install bladesight\n</code></pre></p> </li> <li> <p>Install Jupyter:     <pre><code>pip install jupyter\n</code></pre></p> </li> <li> <p>We make extensive use of <code>plotly</code> for plotting:     <pre><code>pip install plotly\n</code></pre></p> </li> <li> <p>Now you can launch Jupyter:     <pre><code>jupyter notebook\n</code></pre></p> </li> </ol> <p>Tip</p> <p>One of the first people to test drive this tutorial told me he almost punched a hole through his screen when trying to set up the virtual environment.</p> <p>I understand this. Setting up a virtual environment is often the most difficult part of starting with a new project.</p> <p>Please reach out to me at dawie.diamond@bladesight.com and I'd be happy to help you get set up.</p> <p>If you're on a different platform, here's an excellent  video on how to set up virtual environments. The video covers different kinds of operating systems. I've created links for each operating system below:</p> <ul> <li> Windows</li> <li>  Mac</li> <li> Linux</li> </ul>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#vectorized-implementation-of-the-constant-threshold-trigger-method","title":"Vectorized implementation of the constant threshold trigger method","text":"<p>Here's an artificial signal that contains three pulses: </p> Figure 3: A signal that contains three pulses.  <p>Let's extract the ToAs.</p> <p>How the code is presented</p> <p>These are the tutorial's first code examples. I therefore repeatedly display the complete code. Different lines are highlighted and discussed each time.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#step-1-load-the-probe-signal","title":"Step 1: Load the probe signal","text":"<pre><code>from bladesight import Datasets\n\nds_ch2 = Datasets[\"data/intro_to_btt/intro_to_btt_ch02\"]\n\ndf_proximity_probe = ds_ch2[\"table/three_generated_pulses\"] # (1)!\n\nTRIGGER_ON_RISING_EDGE = True\nTHRESHOLD_LEVEL = 0.4 # Volts\n\nif TRIGGER_ON_RISING_EDGE:\n    sr_threshold_over = (\n        df_proximity_probe['data'] &gt;= THRESHOLD_LEVEL\n    ).astype(int)\nelse:\n    sr_threshold_over = (\n        df_proximity_probe['data'] &lt;= THRESHOLD_LEVEL\n    ).astype(int)\n\ndiff_sr_threshold = sr_threshold_over.diff()\n\ndiff_sr_threshold = diff_sr_threshold.bfill()\n\nsr_threshold_change = diff_sr_threshold &gt; 0\n\nsr_toas = df_proximity_probe['time'][sr_threshold_change]\n</code></pre> <ol> <li>This line loads the table into memory. It returns a <code>Pandas DataFrame</code>. We will be making extensive use of Pandas DataFrames throughout this tutorial. Its documentation can be found here: https://pandas.pydata.org/docs/</li> </ol> <p>On Line 1, we import the <code>bladesight</code> package. In addition to hosting the functions developed in this tutorial, the package makes it simple to download and open the datasets.</p> <p>On lines 3 and 5, we download this chapter's dataset and read the <code>three_generated_pulses</code> table. The first ten rows of the table are shown below:</p> time data 0 -0.000594587 0.0333444 0.00106139 0.0666889 2.60792e-05 0.100033 -0.00232804 0.133378 -0.00056633 0.166722 0.00040294 0.200067 -0.000591657 0.233411 -0.000962895 0.266756 0.000452657 0.3001 -8.50727e-05 Units Column Units <code>time</code> seconds <code>data</code> Volt <p>The DataFrame has 2 columns: <code>time</code> and <code>data</code>. The <code>time</code> column contains each data value's timestamp. </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#step-2-set-the-threshold-direction-and-value","title":"Step 2: Set the threshold direction and value","text":"<pre><code>from bladesight import Datasets\n\nds_ch2 = Datasets[\"data/intro_to_btt/intro_to_btt_ch02\"]\n\ndf_proximity_probe = ds_ch2[\"table/three_generated_pulses\"]\n\nTRIGGER_ON_RISING_EDGE = True\nTHRESHOLD_LEVEL = 0.4 # Volts\n\nif TRIGGER_ON_RISING_EDGE:\n    sr_threshold_over = (\n        df_proximity_probe['data'] &gt;= THRESHOLD_LEVEL\n    ).astype(int)\nelse:\n    sr_threshold_over = (\n        df_proximity_probe['data'] &lt;= THRESHOLD_LEVEL\n    ).astype(int)\n\ndiff_sr_threshold = sr_threshold_over.diff()\n\ndiff_sr_threshold = diff_sr_threshold.bfill()\n\nsr_threshold_change = diff_sr_threshold &gt; 0\n\nsr_toas = df_proximity_probe['time'][sr_threshold_change]\n</code></pre> <p>In Line 7, we specify the direction of the trigger. If <code>TRIGGER_ON_RISING_EDGE</code> is <code>True</code>, we trigger when the signal crosses the threshold on the rising edge. If <code>TRIGGER_ON_RISING_EDGE</code> is <code>False</code>, we trigger when the signal crosses the threshold on the falling edge.</p> <p>In Line 8 we set the threshold level to 0.4 Volt.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#step-3-determine-when-the-signal-has-crossed-the-threshold","title":"Step 3: Determine when the signal has crossed the threshold","text":"<pre><code>from bladesight import Datasets\n\nds_ch2 = Datasets[\"data/intro_to_btt/intro_to_btt_ch02\"]\n\ndf_proximity_probe = ds_ch2[\"table/three_generated_pulses\"]\n\nTRIGGER_ON_RISING_EDGE = True\nTHRESHOLD_LEVEL = 0.4 # Volts\n\nif TRIGGER_ON_RISING_EDGE:\n    sr_threshold_over = (\n        df_proximity_probe['data'] &gt;= THRESHOLD_LEVEL\n    ).astype(int) # (1)!\nelse:\n    sr_threshold_over = (\n        df_proximity_probe['data'] &lt;= THRESHOLD_LEVEL\n    ).astype(int)\n\ndiff_sr_threshold = sr_threshold_over.diff()\n\ndiff_sr_threshold = diff_sr_threshold.bfill()\n\nsr_threshold_change = diff_sr_threshold &gt; 0\n\nsr_toas = df_proximity_probe['time'][sr_threshold_change]\n</code></pre> <ol> <li>We use the method <code>.astype(int)</code> at the end of this line because, by default, comparison operators such as <code>&gt;=</code> and <code>&lt;=</code> result in boolean values. We need an integer column for the steps that follow.</li> </ol> <p>In lines 10 - 17, we determine when the signal is \"over\" the threshold level. The definition of \"over\" depends on the direction of the trigger. If we trigger on a rising edge, the signal is \"over\" when it is larger than the threshold. If we trigger on a falling edge, the signal is \"over\" when it is smaller than the threshold.</p> <p>The variable <code>sr_threshold_over</code> contains an array of ones and zeros that indicate whether the signal is above or below the threshold. This variable is shown on top of the original signal in Figure 4 below:</p> Figure 4: The over/under indicator overlayed on the original signal. The indicator goes to 1 (boolean True) when the signal is larger than the threshold and stays 0 otherwise.","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#step-4-determine-when-the-indicator-has-changed","title":"Step 4: Determine when the indicator has changed","text":"<pre><code>from bladesight import Datasets\n\nds_ch2 = Datasets[\"data/intro_to_btt/intro_to_btt_ch02\"]\n\ndf_proximity_probe = ds_ch2[\"table/three_generated_pulses\"]\n\nTRIGGER_ON_RISING_EDGE = True\nTHRESHOLD_LEVEL = 0.4 # Volts\n\nif TRIGGER_ON_RISING_EDGE:\n    sr_threshold_over = (\n        df_proximity_probe['data'] &gt;= THRESHOLD_LEVEL\n    ).astype(int)\nelse:\n    sr_threshold_over = (\n        df_proximity_probe['data'] &lt;= THRESHOLD_LEVEL\n    ).astype(int)\n\ndiff_sr_threshold = sr_threshold_over.diff()\n\ndiff_sr_threshold = diff_sr_threshold.bfill() # (1)!\n\nsr_threshold_change = diff_sr_threshold &gt; 0\n\nsr_toas = df_proximity_probe['time'][sr_threshold_change]\n</code></pre> <ol> <li>The <code>bfill</code> method is used to backward fill any missing values in a pandas Series. We do this because the first value of <code>diff_sr_threshold</code> is <code>NaN</code>. Why is it <code>NaN</code>? Because the first value, by definition, has no prior value to be compared with. We use <code>bfill</code> here to force the first value equal to the second value. </li> </ol> <p>Since we are interested in the exact instant the signal crosses the threshold, we calculate the change in <code>sr_threshold_over</code>. In Line 19, the <code>diff</code> method calculates the consecutive differences between adjacent measurements. In Line 23, the <code>&gt;</code> operator is used to find where the indicator has changed from zero to one. </p> <p>The result of this operation is shown in Figure 5 below:</p> Figure 5: The original signal, along with the change in over/under indicator. The change indicator is 1 when the threshold is crossed, and -1 when the signal falls below the threshold again.","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#step-5-select-the-toas","title":"Step 5: Select the ToAs","text":"<pre><code>from bladesight import Datasets\n\nds_ch2 = Datasets[\"data/intro_to_btt/intro_to_btt_ch02\"]\n\ndf_proximity_probe = ds_ch2[\"table/three_generated_pulses\"]\n\nTRIGGER_ON_RISING_EDGE = True\nTHRESHOLD_LEVEL = 0.4 # Volts\n\nif TRIGGER_ON_RISING_EDGE:\n    sr_threshold_over = (\n        df_proximity_probe['data'] &gt;= THRESHOLD_LEVEL\n    ).astype(int)\nelse:\n    sr_threshold_over = (\n        df_proximity_probe['data'] &lt;= THRESHOLD_LEVEL\n    ).astype(int)\n\ndiff_sr_threshold = sr_threshold_over.diff()\n\ndiff_sr_threshold = diff_sr_threshold.bfill() # (1)!\n\nsr_threshold_change = diff_sr_threshold &gt; 0\n\nsr_toas = df_proximity_probe['time'][sr_threshold_change]\n</code></pre> <p>Line 25 is the culmination of our algorithm. We select only the time stamps where our over/under indicator has changed from zero to one. These time stamps are our ToAs. </p> <p>These are the values in <code>sr_toas</code>:</p> <pre><code>&gt;&gt;&gt; print(sr_toas)\n[27.44248083, 52.45081694, 77.45915305]\n</code></pre> <p>How can we set the ideal threshold level?</p> <p>I don't have a one-size-fits-all answer. Here are some general guidelines I use:</p> <ol> <li> <p>The threshold level must intersect the pulse where its slope is steep. Do not set the threshold near a turning point. You can read about it in my paper (Diamond et al., 2021)<sup>2</sup>.</p> <p></p> </li> <li> <p>The blades on your rotor have different lengths. The pulse shape depends on how far the tip is from the probe. Some pulses are noticeably shorter than others. The threshold level must be set to enable the maximum number of blades to be \"seen\".</p> <p></p> </li> <li> <p>Many BTT probes produce a first-derivative shaped signal, such as the one described in (Rokicki et al., 2021)<sup>3</sup>. In other words, each pulse:</p> <ol> <li> <p>starts at zero</p> </li> <li> <p>increases in the positive direction</p> </li> <li> <p>rapidly dips through zero again</p> </li> <li> <p>extends into the negative direction</p> </li> <li> <p>returns back to zero</p> </li> </ol> <p>It is tempting to set the threshold level at zero, because you want to capture the ToA when the signal dips through zero in the middle. However, this is a bad idea. You are almost guaranteed of spurious ToAs because of noise around zero before and after the pulse settles.</p> <p></p> <p>If you do want to set the threshold level at zero in the  middle of the pulse, you should implement hysteresis. We discuss hysteresis later in this chapter.</p> </li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#sequential-implementation-of-the-constant-threshold-trigger-method","title":"Sequential implementation of the constant threshold trigger method","text":"<p>The vectorized implementation shown above is great... but we can do better. We now implement a sequential version of the constant threshold trigger method.</p> <p>The sequential implementation is the preferred one for two reasons:</p> <ol> <li>Contrary to how many people (...I'm referring to myself here) have been trained to think, it is faster than the vectorized implementation.</li> <li>It is simpler to understand.</li> </ol> <p>How can a sequential, for-loop based approach be faster than the vectorized method? Python is frequently regarded as a slow language. This is false. It is only slow if you use it like nobody ever intended for it to be used.</p> <p>Many approaches exist to enhance its speed. One can often achieve performance levels comparable to compiled languages.</p> <p>We use Numba. Numba is a powerful Just-In-Time (JIT) compiler for Python, compiling portions of your code into machine code at runtime. This often leads to blistering fast functions. Numba is a dependency of the bladesight package, so its already installed if you've followed the installation instructions at the start of this chapter.</p> <p>To use Numba, we import the <code>njit</code> decorator from the package, and wrap our function in it.</p> <pre><code>from numba import njit\n</code></pre>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#simple-example","title":"Simple example","text":"<p>The simplest implementation of a sequential algorithm involves a <code>for</code> loop to monitor when the signal passes a constant threshold.</p> <pre><code>@njit\ndef seq_simple_threshold_crossing(\n    arr_t : np.ndarray, #(1)!\n    arr_s : np.ndarray, #(2)!\n    threshold : float, #(3)!\n    n_est : Optional[float] = None,#(4)!\n    trigger_on_rising_edge : bool = True#(5)!\n) -&gt; np.ndarray: #(6)!   \n    if n_est is None:\n        arr_toa = -1 * np.ones(arr_t.shape)\n    else:\n        arr_toa = -1 * np.ones(n_est)#(7)!\n\n    i_toa = 0#(8)!\n\n    prev_sample = arr_s[0]#(9)!\n\n    for i_sample in range(1, arr_s.shape[0]):#(10)!\n\n        curr_sample = arr_s[i_sample]\n\n        if trigger_on_rising_edge:\n            if (prev_sample &lt; threshold) and (curr_sample &gt;= threshold):#(11)!\n                arr_toa[i_toa] = arr_t[i_sample]#(12)!\n                i_toa += 1#(13)!\n        else:\n            if (prev_sample &gt; threshold) and (curr_sample &lt;= threshold):#(14)!\n                arr_toa[i_toa] = arr_t[i_sample]\n                i_toa += 1\n\n        prev_sample = curr_sample#(15)!\n\n    return arr_toa[:i_toa]#(16)!\n</code></pre> <ol> <li>The array of time values. Must be a Numpy array.</li> <li>The array of voltage values. Must be a Numpy array.</li> <li>The threshold value. Must be a float.</li> <li>The estimated number of ToAs in this signal. Defaults to None. This number is used to pre-allocate the array of ToAs. If this number is not provided, the array will be pre-allocated as the same dimension as arr_t and arr_s. You should specify this value for large signals.</li> <li>Whether to trigger ToAs on the rising or falling edge. Defaults to True. If True, the ToA is triggered on the rising edge.</li> <li>This type annotation <code>-&gt; np.ndarray</code> indicates the return value of the function is a Numpy array.</li> <li>We pre-allocate the array of ToAs. This is a performance optimization. If we don't pre-allocate the array, the function will have to resize the array each time a ToA is found. It's easy to estimate the expected number of ToAs in the signal, and should be done for any real signal.</li> <li>Initialize the number of ToAs found in this signal. <code>i_toa</code> will increase by one each time a ToA has been found.</li> <li>The sequential approach compares each sample to the previous sample. Here, we initialize the <code>prev_sample</code> value to the first value in the array.</li> <li>We loop through the entire signal and compare each sample to its predecessor.</li> <li>Here, we check if the threshold has been crossed. If so, we store the ToA in the <code>arr_toa</code> array. This if-clause is executed for a rising edge trigger.</li> <li>If the threshold has been crossed, we store the ToA in the <code>arr_toa</code> array.</li> <li>Increment the <code>i_toa</code> value by one.</li> <li>The check for a falling edge trigger.</li> <li>We're done with this sample. This command prepares us for the comparison in the next loop pass.</li> <li>Return only the ToAs that have been registered. The rest of the array is filled with -1 values.</li> </ol> <p>Type annotations in Python</p> <p>Throughout this tutorial, you'll notice in many of the functions, the function arguments are accompanied by type annotations. In the first argument above, <code>arr_t : np.ndarray</code>, <code>arr_t</code> is the variable name and <code>: np.ndarray</code> is the type annotation . These type annotations specify the expected data types of the arguments.</p> <p>It's important to note Python itself does not enforce these type annotations. They are primarily utilized by type checkers and serve as a helpful guide for users of the function.</p> <p>We often need to import annotations from the <code>typing</code> library. In the example above, we need to import the <code>Optional</code> type with the statement <code>from typing import Optional</code>.</p> <p>If we pass our three pulses signal through this function, we get the same result as the vectorized implementation:</p> <pre><code>&gt;&gt;&gt; toas = seq_simple_threshold_crossing(\n    df_proximity_probe['time'].values, #(1)!\n    df_proximity_probe['data'].values, \n    threshold=0.4\n)\n&gt;&gt;&gt; print(toas)\n[27.44248083 52.45081694 77.45915305]\n</code></pre> <ol> <li>Note how we use the <code>.values</code> attribute of the Pandas object. This returns a Numpy array, which is required by the function.</li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#interpolate-on-voltage","title":"Interpolate on voltage","text":"<p>Our signals are sampled by a data acquisition system (DAQ). Suppose the DAQ's sampling rate is 100 kHz. This means one sample is acquired every 10 \\(\\mu\\)s. What happens if the threshold is crossed between two samples? The methods derived up to this point will miss the exact ToA. The ToA will only be triggered at the first available sample after the threshold has been crossed.</p> <p>If we have the raw analogue signal stored on disk, it's wise to capitalize on the continuous nature of the signal.</p> <p>To improve the accuracy of ToA determination, we employ interpolation between the two nearest samples when the threshold is crossed.</p> <p>The below function adds interpolation to the trigger algorithm. It is a modified version of the previous function. The only difference is the interpolation step, marked with a comment <code>(+)</code>:</p> <pre><code>@njit\ndef seq_threshold_crossing_interp(\n    arr_t : np.ndarray,\n    arr_s : np.ndarray,\n    threshold : float,\n    n_est : Optional[float] = None,\n    trigger_on_rising_edge : bool = True\n) -&gt; np.ndarray:\n    if n_est is None:\n        arr_toa = -1 * np.ones(arr_t.shape)\n    else:\n        arr_toa = -1 * np.ones(n_est)\n\n    i_toa = 0\n\n    prev_sample = arr_s[0]\n\n    for i_sample in range(1, arr_s.shape[0]):\n\n        curr_sample = arr_s[i_sample]\n\n        if trigger_on_rising_edge:\n            if (prev_sample &lt; threshold) and (curr_sample &gt;= threshold):\n                # Interpolate the ToA\n                arr_toa[i_toa] = (\n                    arr_t[i_sample - 1] \n                    + (arr_t[i_sample] - arr_t[i_sample - 1]) \n                    * (threshold - prev_sample) \n                    / (curr_sample - prev_sample)\n                ) # (1)!\n                i_toa += 1\n        else:\n            if (prev_sample &gt; threshold) and (curr_sample &lt;= threshold):\n                arr_toa[i_toa] = (\n                    arr_t[i_sample - 1] \n                    + (arr_t[i_sample] - arr_t[i_sample - 1]) \n                    * (threshold - prev_sample) \n                    / (curr_sample - prev_sample)\n                )\n                i_toa += 1\n\n        prev_sample = curr_sample\n\n    return arr_toa[:i_toa]\n</code></pre> <ol> <li>This part performs linear interpolation between the two samples either side of the threshold. It is the only difference between this function and the previous one.</li> </ol> Why use linear interpolation? <p>Linear interpolation is the simplest form of interpolation. It is also the fastest. In my experience, the accuracy gain from a higher order interpolation method is marginal. It's not worth the additional code complexity.</p> <p>Let's use this function on the same signal:</p> <pre><code>&gt;&gt;&gt; toas = seq_threshold_crossing_interp(\n    df_proximity_probe['time'].values, \n    df_proximity_probe['data'].values, \n    threshold=0.4\n)\n&gt;&gt;&gt; print(toas)\n[27.42940329 52.44126697 77.45548277]\n</code></pre> <p>These values are slightly different than the previous ones ( the previous ones are <code>[27.44248083 52.45081694 77.45915305]</code> ). The new values are more accurate than the old ones.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#hysteresis","title":"Hysteresis","text":"<p>The signals we've used so far contain minimal noise. In the absence of noise, the ToAs are easily extracted. However, in real-world scenarios, signals contain non-negligible noise components. </p> <p>Sometimes, excessive noise is consistently present throughout the signal. Other times it appears in short, sporadic bursts. </p> <p>To illustrate this point vividly, I've generated a noisy signal that contains three pulses, shown in Figure 6 below: </p> <p>Zoom</p> <p>If there is a \"Reset zoom\" button on the bottom of the figure, you can zoom and pan on the plot. Drag across the screen to zoom , hold <code>ctrl</code> and drag across the screen to pan.</p> Reset Zoom Figure 6: A noisy signal that contains three pulses. Zoom into the areas around 0.4 V to observe the signal crosses the threshold multiple times.    <p>If you zoom into each pulse around 0.4 V, you'll observe the signal crosses the threshold multiple times. Let's apply our trigger algorithm to this signal. We first need to load the noisy signal dataframe:</p> <pre><code>df_proximity_probe = ds_ch2[\"table/three_generated_pulses_noisy\"]\n</code></pre> <p>Having applied our algorithm to the noisy signal, these are the ToAs: </p> <pre><code>[27.20280579, 27.26724046, 27.45521975, 27.54516822, 32.4110573,  32.48523812,\n 32.59630977, 32.73320484, 52.10882236, 52.46204252, 52.59380688, 57.42079388,\n 57.64309888, 57.69638523, 57.78086048, 57.87833845, 77.46723661, 77.66015932,\n 78.09842428, 82.3623517,  82.50989437, 82.74746473]\n</code></pre> <p>Our algorithm incorrectly returns many ToAs around the 0.4 V level.</p> <p>We can implement hysteresis to solve the issue. Hysteresis introduces a second threshold and a state variable to our algorithm. The algorithm therefore uses a lower and an upper threshold. The state can only change based on certain rules. The rules are:</p> <ol> <li>If the state is low and the current sample is above the upper threshold, the state becomes high. A ToA is triggered when the state moves from low to high.</li> <li>If the state is high and the current sample falls below the lower threshold, the state becomes low.</li> <li>Otherwise, the state is maintained.</li> </ol> <p>Figure 7 below illustrates the state variable and ToA trigger events for a (absurdly) noisy signal. </p> <p> Figure 7: An illustration of hysteresis in our trigger criterion.</p> <p>The below algorithm implements hysteresis to determine the ToAs on the rising edge:</p> <pre><code>@njit\ndef seq_threshold_crossing_hysteresis_rising(\n    arr_t : np.ndarray,\n    arr_s : np.ndarray,\n    threshold : float,\n    hysteresis_height : float, #(1)!\n    n_est : Optional[float] = None,\n) -&gt; np.ndarray:\n    threshold_lower = threshold - hysteresis_height\n    trigger_state = ( # (2)!\n        True \n        if arr_s[0] &gt; threshold_lower \n        else False\n    )\n\n    if n_est is None:\n        arr_toa = -1 * np.ones(arr_t.shape)\n    else:\n        arr_toa = -1 * np.ones(n_est)\n\n    i_toa = 0\n\n    prev_sample = arr_s[0]\n\n    for i_sample in range(1, arr_s.shape[0]):\n        curr_sample = arr_s[i_sample]\n\n        if trigger_state is True:\n            if curr_sample &lt;= threshold_lower: #(3)!\n                trigger_state = False\n        else:\n            if curr_sample &gt;= threshold:#(4)!\n                trigger_state = True\n                arr_toa[i_toa] = (\n                    arr_t[i_sample - 1] \n                    + (arr_t[i_sample] - arr_t[i_sample - 1]) \n                    * (threshold - prev_sample) \n                    / (curr_sample - prev_sample)\n                )\n                i_toa += 1\n\n        prev_sample = curr_sample\n\n    return arr_toa[:i_toa]\n</code></pre> <ol> <li>The height of the hysteresis. It has the same units as the signal. This value is used to calculate the lower threshold.</li> <li>The trigger state is a boolean value indicating whether the trigger is currently high or low. We initialize it to True if the first sample is above the lower threshold, and False otherwise.</li> <li>If the trigger state is True, we check if the current sample is below the lower threshold. If it is, we set the trigger state to False.</li> <li>If the trigger state is False, we check if the current sample is above the upper threshold. If it is, we set the trigger state to True and calculate the ToA using interpolation.</li> </ol> <p>We can use this function to extract the ToAs from the noisy signal:</p> <p><pre><code>&gt;&gt;&gt; toas = seq_threshold_crossing_hysteresis_rising(\n    df_proximity_probe_noisy['time'].values, \n    df_proximity_probe_noisy['data'].values, \n    threshold=0.4, \n    hysteresis_height=0.2\n)\n&gt;&gt;&gt; print(taos)\n[27.20280579 52.10882236 77.46723661]\n</code></pre> Implementation of hysteresis stops multiple trigger events. It does not, however, guarantee accurate ToAs for noisy signals. We might end up with the correct number of ToAs, but each ToA will be the first one where the signal crosses the upper threshold. This may not be the best ToA. It may therefore be beneficial to incorporate a filter into the algorithm. We don't cover filters in this chapter.</p> How to select <code>hysteresis height</code> and <code>n_est</code> <ol> <li> <p>The hysteresis height should be at least twice as large as the noise. A sufficient estimate can usually be made by observing the largest noise spikes.</p> </li> <li> <p>The <code>n_est</code> value should be larger than the number of pulses in the signal. I use this calculation:</p> </li> </ol> <pre><code>n_est = (\n    MAX_SHAFT_SPEED_IN_HZ \n    * NUMBER_OF_BLADES_ON_ROTOR \n    * TIME_IN_SECONDS_OF_MEASUREMENT\n) * 2\n</code></pre> <p>The <code>*2</code> at the end of the equation doubles the pre-allocated array length. We can therefore be sure there's enough space for all the ToAs.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#performance-of-sequential-vs-vectorized-implementations","title":"Performance of sequential vs vectorized implementations","text":"<p>We've now implemented vectorized and sequential algorithms to extract the ToAs. Which one is faster? Let's use both approaches on a real signal.</p> <p>The dataset used here contains a signal acquired from an eddy current probe. It is stored in the table <code>table/aluminium_blisk_1200_rpm</code>. The signal was acquired for a five blade rotor running at 1200 RPM. The acquisition was performed at a sampling rate of 2 MHz. The signal is shown in Figure 8 below:</p> Reset Zoom Figure 8: An eddy current probe signal acquired for a five blade aluminium rotor rotating at 1200 RPM. The sampling rate of the DAQ was 2 MHz. For this figure, the data points are heavily decimated. <p>We can use the Jupyter <code>%%timeit</code> magic method to time a piece of code. Here's the result:</p> Vectorized Sequential 301 ms 18 ms <p>The sequential approach is almost 20 times faster than the vectorized method. The sequential algorithm also contains hysteresis and interpolation that the vectorized function does not.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#real-time-hardware","title":"Real Time Hardware","text":"<p>This chapter assumes you can store large analogue signals on your disk. If your rotor is small and turns slowly, this method is suitable.</p> <p>When your blades are large or your rotor spins fast, you'll need to determine the ToAs in real-time. This typically requires custom hardware. Here are some providers of BTT hardware:</p> <ul> <li>  Bladesight</li> <li>  EMTD Measurement</li> <li>  Hood Technologies</li> <li>  Agilis</li> </ul>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#conclusion","title":"Conclusion","text":"<p>Congratulations, you've completed the second chapter of this tutorial. You're approximately 30% of the way through. You've now learned how ToA extraction works. </p> <p>In my experience, getting your Python version set up is a massive challenge. From here, we can churn out code to our heart's content.</p> <p>Lets push on...</p> <p>Chapter outcomes</p> <p> Understand that we need to implement a trigger criterion to determine the ToA of each pulse.</p> <p> Understand the constant-threshold trigger method's principle.</p> <p> Understand the detrimental effects of noise on the trigger criterion.</p> <p> Understand how to implement hysteresis to prevent multiple trigger events.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to Justin Smith and Alex Brocco for reviewing this chapter and providing feedback.</p> <p>A special thanks to Miros\u0142aw Wito\u015b for his detailed review of this chapter.</p> <p> Dawie Diamond </p> <p> 2024-02-06 2025-02-17              </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#coding-exercises","title":"Coding exercises","text":"<p>Here are two coding exercises to solidify your understanding of the material covered in this chapter. Please attempt them before you expand the solution bar.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#problem-1-automatic-range-detection","title":"Problem 1: Automatic range detection","text":"<p>So far, the threshold level has been set manually from eyeballing the signal. This is often fine, but we can do better...</p> <p> Write a new function, called <code>determine_threshold_level</code>, that receives the signal and the % of the range to use as the threshold level. The function should return the threshold level. </p> Reveal answer (Please try it yourself before peeking) <p><pre><code>def determine_threshold_level(\n    arr_s : np.ndarray,\n    threshold_percent : float = 50\n) -&gt; float:\n    \"\"\" This function determines the threshold level to use for the\n    constant threshold trigger method. The threshold level is\n    determined as a percentage between the maximum and minimum\n    value of the signal.\n\n    Args:\n        arr_s (np.ndarray): The signal to determine the threshold\n            level for.\n        threshold_percent (float): The percentage of the maximum\n            value to use as the threshold level. Must be a number\n            between 0 and 100.\n\n    \"\"\"\n    if threshold_percent &lt; 0 or threshold_percent &gt; 100:\n        raise ValueError(\"threshold_percent must be between 0 and 100\")\n    min_value = np.min(arr_s)\n    max_value = np.max(arr_s)\n    signal_range = max_value - min_value\n    threshold_level = min_value + signal_range * threshold_percent/100\n    return threshold_level\n</code></pre> Example usage: <pre><code>&gt;&gt;&gt; threshold_level = determine_threshold_level(\n    df_proximity_probe['data'].values, \n    threshold_percent=30\n)\n&gt;&gt;&gt; print(threshold_level)\n0.3\n</code></pre></p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch2/#problem-2-hysteresis-on-the-falling-edge","title":"Problem 2: Hysteresis on the falling edge","text":"<p>We've showcased how a trigger criterion with hysteresis works on the rising edge. Implement a trigger criterion that uses hysteresis on the falling edge.</p> <p> Write a new function, called <code>seq_threshold_crossing_hysteresis_falling</code>, that extracts the ToAs on the falling edge using hysteresis.</p> Reveal answer (Please try it yourself before peeking) <p><pre><code>@njit\ndef seq_threshold_crossing_hysteresis_falling(\n    arr_t : np.ndarray,\n    arr_s : np.ndarray,\n    threshold : float,\n    hysteresis_height : float,\n    n_est : Optional[float] = None,\n) -&gt; np.ndarray:\n    \"\"\" This function implements the constant threshold trigger\n    method with hysteresis on the falling edge. The hysteresis\n    height is specified in voltage.\n\n    Args:\n        arr_t (np.ndarray): The time values of the signal.\n        arr_s (np.ndarray): The signal to determine the threshold\n            level for.\n        threshold (float): The threshold level to use for the\n            constant threshold trigger method.\n        hysteresis_height (float): The height of the hysteresis.\n            It has the same units as the signal.\n        n_est (Optional[float]): The estimated number of ToAs in\n            this signal. Defaults to None. This number is used to\n            pre-allocate the array containing the ToAs. If this\n            number is not provided, the array will be pre-allocated\n            as the same dimension as arr_t and arr_s. You should\n            specify this value for large signals.\n    \"\"\"\n    threshold_upper = threshold + hysteresis_height\n    trigger_state = True if arr_s[0] &lt; threshold_upper else False\n\n    # Pre-allocate the array containing the ToAs\n    if n_est is None:\n        arr_toa = -1 * np.ones(arr_t.shape)\n    else:\n        arr_toa = -1 * np.ones(n_est)\n\n    # Initialise the index of the ToA array\n    i_toa = 0\n\n    # Initialise the previous sample value\n    prev_sample = arr_s[0]\n\n    # Loop through all the samples\n    for i_sample in range(1, arr_s.shape[0]):\n        # Get the current sample value\n        curr_sample = arr_s[i_sample]\n\n        # Check if the threshold is crossed\n        if trigger_state is True:\n            if curr_sample &gt;= threshold_upper:\n                trigger_state = False\n        else:\n            if curr_sample &lt;= threshold:\n                trigger_state = True\n                # Interpolate the ToA\n                arr_toa[i_toa] = (\n                    arr_t[i_sample - 1] \n                    + (arr_t[i_sample] - arr_t[i_sample - 1]) \n                    * (threshold - prev_sample) \n                    / (curr_sample - prev_sample)\n                )\n                i_toa += 1\n\n        # Update the previous sample value\n        prev_sample = curr_sample\n\n    # Return the array containing the ToAs\n    return arr_toa[:i_toa]\n</code></pre> Example usage: <pre><code>&gt;&gt;&gt; toas = seq_threshold_crossing_hysteresis_falling(\n    df_proximity_probe_noisy['time'].values, \n    df_proximity_probe_noisy['data'].values, \n    threshold=0.4, \n    hysteresis_height=0.1\n)\n</code></pre></p> <ol> <li> <p>Zimmer, A.K., 2008. Investigation of the impact of turbine blade geometry on near-field microwave blade tip time of arrival measurements (PhD thesis).\u00a0\u21a9</p> </li> <li> <p>Diamond, D., Heyns, P.S., Oberholster, A., 2021. Constant speed tip deflection determination using the instantaneous phase of blade tip timing data. Mechanical Systems and Signal Processing 150, 107151.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Rokicki, E., Przysowa, R., Kotkowski, J., Majewski, P., 2021. High temperature magnetic sensors. Preprints (DOI:10.20944/preprints202107.0077.v1 ).\u00a0\u21a9</p> </li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/","title":"3. Angle of Arrival (AoA)","text":"You are here Reviews <p>Please read through the chapter prior to activating a review as I have kept the chapters deliberately terse. </p> <p>Click to activate a review \ud83d\udc47 for more detailed comments from other experts.</p> <p>     Miros\u0142aw Wito\u015b </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#angle-of-arrival-aoa","title":"Angle of Arrival (AoA)","text":"<p>We are 30% through the tutorial. At this stage, we've learned how to process the raw analogue waveforms into a vector of Time of Arrivals (ToAs). We've said that, at the end of this tutorial, we will be able to infer vibration characteristics of each blade's tip deflections. This presents an interesting challenge.</p> <p>Tip deflections are entities of distance.</p> <p>ToAs represent time.</p> <p>The two quantities are in different domains.</p> <p>We therefore need to convert from time to distance. How on earth will we do this? You may as well open a file full of accelerometer measurements and attempt to infer the temperature of the instrumented structure.</p> <p> Figure 1: We need to convert our ToAs from seconds into some unit of distance. </p> <p>Fortunately, a fundamental mathematical property of bodies that rotate about an axis is known to us. A body that rotates an entire circle has traveled 360 degrees, or \\(2\\pi\\) radians. </p> <p>Radians may not yet be in units of mm or meters. It does, however, transport us into the distance domain.</p> <p>To perform this conversion, we use a shaft encoder.</p> <p>Outcomes</p> <p> Understand we use a shaft encoder to calculate the shaft speed, \\(\\Omega\\), and the start and end of each revolution. </p> <p> Understand we need to find the shaft revolution in which each ToA occurs.</p> <p> Understand each ToA is used to calculate the precise shaft circumferential displacement in said revolution. This is the AoA of each ToA.</p> <p> Write a function that calculates a matrix of AoAs from the shaft encoder zero-crossing times and the ToAs.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#shaft-encoder","title":"Shaft encoder","text":"<p>Most BTT systems rely on a shaft encoder installed on the rotor. A shaft encoder produces a pulse train, similar to the proximity probes discussed in the last chapter.</p> <p>A typical shaft encoder is shown in Figure 2 below. It consists of a rotating shaft with a key and a stationary sensor mounted next to the key.</p> <p> Figure 2: A shaft encoder consists of a rotating shaft with a key and a stationary sensor mounted next to the key. The sensor \"picks up\" the presence of the key as it rotates by. A voltage pulse train is produced that is processed to find the zero-crossing times. </p> <p>The sensor in this case produces One Pulse per Revolution (OPR). Some shaft encoders produce Multiple Pulses per Revolution (MPR). This tutorial considers the OPR case. OPR encoders are more prevalent than their MPR counterparts.</p> <p>We extract the ToAs from the OPR signal with a trigger criteria, just like we used for the blade ToAs in the previous chapter. The OPR timestamps are often referred to as zero-crossing times. This terminology creates the impression they are registered only when the signal crosses 0 V. Though this is often the case, these timestamps can be extracted using any trigger criteria. Each timestamp therefore corresponds to the start of a new shaft revolution.</p> <p>Zero-crossing times</p> <p>A zero-crossing time is the exact timestamp a revolution starts. The next timestamp is, by definition, the exact time the revolution ends and the next one starts.</p> <p>Do not confuse zero-crossing times and ToAs:</p> <ol> <li> <p>Zero-crossing times refer to timestamps captured by the shaft encoder. They are the start of each revolution. I've added the subscript \\(\\mathbf{\\textrm{zc}}\\) to all zero-crossing times to differentiate them from the ToAs.</p> </li> <li> <p>ToAs refer to the timestamps captured by the proximity probes in the casing. They are the times the blades passed the probes.</p> </li> </ol> <p>After processing the shaft encoder's analogue waveform, we have a vector of zero-crossing times. The shaft speed between them can be calculated from Equation 1 below.</p> \\[\\begin{equation} \\Omega_n = \\frac{2 \\pi}{t_{\\textrm{zc}_{n+1}} - t_{\\textrm{zc}_{n}}} \\end{equation}\\] <p></p> Symbols Symbol Description \\(\\Omega_n\\) Shaft speed in the \\(n\\)th revolution \\(n\\) The revolution number \\(t_{\\textrm{zc}_{n}}\\) The \\(n\\)th zero-crossing time <p>An example of the shaft speed calculated from Equation 1 is presented in Figure 3 below.</p> Reset Zoom Figure 3: A shaft accelerating from 950 RPM to 1325 RPM and back again over a time of 41 seconds.  <p>The figure above presents the run-up and run-down of a shaft between 950 RPM and 1325 RPM over approximately 41 seconds.</p> Encoder-less techniques <p>Some publications refer to encoder-less BTT systems. These are advanced techniques normally used when there's no encoder. The techniques are beyond the scope of this tutorial. </p> Which probes can you use for the shaft encoder? <p>You can use any probe capable of responding to the presence of a discontinuity on the shaft. I often use eddy current probes or optical pickups. </p> At which circumferential position should the probe be installed? <p>It makes no difference where the probe is installed. The only requirement is the probe must be able to detect the presence of the shaft's discontinuity.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#angle-of-arrival-aoa_1","title":"Angle of Arrival (AoA)","text":"<p>The shaft's circumferential position when the ToA is registered is referred to as the Angle of Arrival (AoA). It is calculated with respect to the revolution in which it occurs. In other words, it is always a quantity between 0 and \\(2 \\pi\\) within each revolution. </p> <p>We use Equation 2 below to calculate the AoA.</p> \\[\\begin{equation} \\textrm{AoA} (\\textrm{ToA}) = \\Omega_n \\times (\\textrm{ToA} - t_{\\textrm{zc}_{n}}) \\end{equation}\\] <p></p> Symbols Symbol Description \\(\\textrm{AoA} (\\textrm{ToA})\\) The AoA corresponding to the ToA \\(n\\) The revolution number in which the ToA occurs \\(\\textrm{ToA}\\) The ToA. It must occur within revolution \\(n\\) \\(\\Omega_n\\) The shaft speed in the \\(n\\)th revolution \\(t_{\\text{zc}_{n}}\\) The zero-crossing time at the start of the \\(n\\)th revolution <p>Our algorithm must perform two cardinal tasks to calculate AoAs from ToAs:</p> <ol> <li> <p>Determine the revolution number in which each ToA occurs.</p> </li> <li> <p>Calculate the AoA of each ToA within its revolution.</p> </li> </ol> <p>This two-step process can be performed with a single function. In this chapter, we write a function receiving a vector of ToAs and a vector of zero-crossing times as inputs. It returns a matrix of values that includes the AoAs and identified revolution numbers. We will, once again, use Numba to speed things up. Learning how to leverage Numba gives you a skill with applications in most code-centric industries.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#following-along","title":"Following along","text":"<p>The worksheet for this chapter can be downloaded here .</p> <p>You can open a Google Colab session of the worksheet here: .</p> <p>You need to use one of these Python versions to run the worksheet:   .</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#algorithm","title":"Algorithm","text":"<p>To perform this conversion from time to angle, our algorithm calculates several quantities for each ToA:</p> <ol> <li> <p>The revolution number, \\(n\\), in which the ToA occurs.</p> </li> <li> <p>The zero-crossing times at the start and end of the ToA's revolution, referred to as \\(zc_n\\) and \\(zc_{n+1}\\) respectively.</p> </li> <li> <p>The angular velocity of the shaft in the revolution, \\(\\Omega_n\\).</p> </li> <li> <p>The shaft's angular position when the ToA was triggered. This is referred to as the AoA of the ToA. Each ToA therefore has one AoA.</p> </li> </ol> <p>Let's consider a simple example. We have measured 6 ToAs and 3 zero-crossing times:</p> <pre><code>ToAs = [0.3,0.5,0.7,1.3,1.5,1.7]\nt_zc_times = [0.0, 1.0, 2.0]\n</code></pre> <p>We place the ToAs and the zero-crossing times on a horizontal axis. This makes it simpler to visualize.</p> <p>The clickable tabs below present the calculations for each ToA.</p> ToA no 1ToA no 2ToA no 3ToA no 4ToA no 5ToA no 6 <pre><code>ToAs           = [       0.3     0.5     0.7            1.3     1.5     1.7         ]\n                          |\n                          | \n                          \u2193 \n                 __|_______________________________|______________________________|__\nt_zc_times     = [0.0                             1.0                            2.0]\nrevolution_no  = [0                               1                              2  ]\nCalculated values:\n\ncurrent_revolution = 0\nt_zc_start         = 0.0\nt_zc_end           = 1.0\nOmega              = 2 \u03c0 / (t_zc_end - t_zc_start) = 2 \u03c0 / 1.0       = 2.0 \u03c0\nAoA                = Omega * (ToA - t_zc_start)  = 2 \u03c0 * (0.3 - 0.0) = 0.6 \u03c0\n</code></pre> <p>The allocated values after the first ToA is shown below \ud83d\udc47.</p> n n_start_time n_end_time Omega ToA AoA 0 0.0 1.0 2.0\u03c0 0.3 0.6 \u03c0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? <pre><code>ToAs           = [       0.3     0.5     0.7            1.3     1.5     1.7         ]\n                                  |\n                                  | \n                                  \u2193 \n                 __|_______________________________|______________________________|__\nt_zc_times     = [0.0                             1.0                            2.0]\nrevolution_no  = [0                               1                              2  ]\nCalculated values:\n\ncurrent_revolution = 0\nt_zc_start         = 0.0\nt_zc_end           = 1.0\nOmega              = 2 \u03c0 / (t_zc_end - t_zc_start) = 2 \u03c0 / 1.0       = 2.0 \u03c0\nAoA                = Omega * (ToA - t_zc_start)  = 2 \u03c0 * (0.5 - 0.0) = 1.0 \u03c0\n</code></pre> <p>The allocated values after the second ToA is shown below \ud83d\udc47.</p> n n_start_time n_end_time Omega ToA AoA 0 0.0 1.0 2.0\u03c0 0.3 0.6 \u03c0 0 0.0 1.0 2.0\u03c0 0.5 1.0 \u03c0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? <pre><code>ToAs           = [       0.3     0.5     0.7            1.3     1.5     1.7         ]\n                                          |\n                                          | \n                                          \u2193 \n                 __|_______________________________|______________________________|__\nt_zc_times     = [0.0                             1.0                            2.0]\nrevolution_no  = [0                               1                              2  ]\nCalculated values:\n\ncurrent_revolution = 0\nt_zc_start         = 0.0\nt_zc_end           = 1.0\nOmega              = 2 \u03c0 / (t_zc_end - t_zc_start) = 2 \u03c0 / 1.0       = 2.0 \u03c0\nAoA                = Omega * (ToA - t_zc_start)  = 2 \u03c0 * (0.7 - 0.0) = 1.4 \u03c0\n</code></pre> <p>The allocated values after the third ToA is shown below \ud83d\udc47.</p> n n_start_time n_end_time Omega ToA AoA 0 0.0 1.0 2.0\u03c0 0.3 0.6 \u03c0 0 0.0 1.0 2.0\u03c0 0.5 1.0 \u03c0 0 0.0 1.0 2.0\u03c0 0.7 1.4 \u03c0 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? <pre><code>ToAs           = [       0.3     0.5     0.7            1.3     1.5     1.7         ]\n                                                         |\n                                                         | \n                                                         \u2193 \n                 __|_______________________________|______________________________|__\nt_zc_times     = [0.0                             1.0                            2.0]\nrevolution_no  = [0                               1                              2  ]\nCalculated values:\n\ncurrent_revolution = 1\nt_zc_start         = 1.0\nt_zc_end           = 2.0\nOmega              = 2 \u03c0 / (t_zc_end - t_zc_start) = 2 \u03c0 / 1.0       = 2.0 \u03c0\nAoA                = Omega * (ToA - t_zc_start)  = 2 \u03c0 * (1.3 - 1.0) = 0.6 \u03c0\n</code></pre> <p>The allocated values after the fourth ToA is shown below \ud83d\udc47.</p> n n_start_time n_end_time Omega ToA AoA 0 0.0 1.0 2.0\u03c0 0.3 0.6 \u03c0 0 0.0 1.0 2.0\u03c0 0.5 1.0 \u03c0 0 0.0 1.0 2.0\u03c0 0.7 1.4 \u03c0 1 1.0 2.0 2.0\u03c0 1.3 0.6 \u03c0 ? ? ? ? ? ? ? ? ? ? ? ? <pre><code>ToAs           = [       0.3     0.5     0.7            1.3     1.5     1.7         ]\n                                                                 |\n                                                                 | \n                                                                 \u2193 \n                 __|_______________________________|______________________________|__\nt_zc_times     = [0.0                             1.0                            2.0]\nrevolution_no  = [0                               1                              2  ]\nCalculated values:\n\ncurrent_revolution = 1\nt_zc_start         = 1.0\nt_zc_end           = 2.0\nOmega              = 2 \u03c0 / (t_zc_end - t_zc_start) = 2 \u03c0 / 1.0       = 2.0 \u03c0\nAoA                = Omega * (ToA - t_zc_start)  = 2 \u03c0 * (1.5 - 1.0) = 1.0 \u03c0\n</code></pre> <p>The allocated values after the fifth ToA is shown below \ud83d\udc47.</p> n n_start_time n_end_time Omega ToA AoA 0 0.0 1.0 2.0\u03c0 0.3 0.6 \u03c0 0 0.0 1.0 2.0\u03c0 0.5 1.0 \u03c0 0 0.0 1.0 2.0\u03c0 0.7 1.4 \u03c0 1 1.0 2.0 2.0\u03c0 1.3 0.6 \u03c0 1 1.0 2.0 2.0\u03c0 1.5 1.0 \u03c0 ? ? ? ? ? ? <pre><code>ToAs           = [       0.3     0.5     0.7            1.3     1.5     1.7         ]\n                                                                         |\n                                                                         | \n                                                                         \u2193 \n                 __|_______________________________|______________________________|__\nt_zc_times     = [0.0                             1.0                            2.0]\nrevolution_no  = [0                               1                              2  ]\nCalculated values:\n\ncurrent_revolution = 1\nt_zc_start         = 1.0\nt_zc_end           = 2.0\nOmega              = 2 \u03c0 / (t_zc_end - t_zc_start) = 2 \u03c0 / 1.0       = 2.0 \u03c0\nAoA                = Omega * (ToA - t_zc_start)  = 2 \u03c0 * (1.7 - 1.0) = 1.4 \u03c0\n</code></pre> <p>The allocated values after the sixth ToA is shown below \ud83d\udc47.</p> n n_start_time n_end_time Omega ToA AoA 0 0.0 1.0 2.0\u03c0 0.3 0.6 \u03c0 0 0.0 1.0 2.0\u03c0 0.5 1.0 \u03c0 0 0.0 1.0 2.0\u03c0 0.7 1.4 \u03c0 1 1.0 2.0 2.0\u03c0 1.3 0.6 \u03c0 1 1.0 2.0 2.0\u03c0 1.5 1.0 \u03c0 1 1.0 2.0 2.0\u03c0 1.7 1.4 \u03c0 <p>Each calculation is performed sequentially. The results of each calculation are appended to the output matrix.</p> <p>The blade count is unknown</p> <p>You'll notice I have not stated how many blades are on the rotor for this simple example. This was by choice. At this stage of analysis, we do not need to incorporate the number of blades. We simply need to determine the revolution in which a ToA occurs and the corresponding AoA.</p> <p>You may be able to guess there are 3 blades. You should, however, not adapt your algorithm to expect a specific number of them. The reason for this is there can be missing or double ToAs and zero-crossing times. If you expect a certain number of time stamps but the measurement does not contain exactly what you require, your analysis will be corrupted.</p> <p>The algorithm presented in this chapter may be more complex than slicing the ToAs equally into bins, but it will save you from a lot of headaches in the future.</p> <p>Based on the above example, we can write the code to calculate the AoA of each ToA. I have included comments that can be opened by clicking on the  symbols. </p> <p>If these symbols are not visible, refresh the page. If they're still not visible, download Google Chrome and try again \ud83d\ude01.</p> <pre><code>from numba import njit #(1)!\nimport numpy as np\n\n@njit\ndef calculate_aoa(#(2)!\n    arr_opr_zero_crossing : np.ndarray, \n    arr_probe_toas : np.ndarray\n):\n    \"\"\"\n    This function calculates the angle of arrival of \n    each ToA value relative to the revolution in \n    which it occurs.\n\n    Args:\n        arr_opr_zero_crossing (np.array): An array of \n            OPR zero-crossing times. \n        arr_probe_toas (np.array): An array of \n            ToA values.\n\n    Returns:\n        np.array: A matrix of AoA values. Each row in the \n            matrix corresponds to a ToA value. The columns \n            are:\n            0: The revolution number\n            1: The zero-crossing time at the start of the revolution\n            2: The zero-crossing time at the end of the revolution\n            3: The angular velocity of the revolution\n            4: The ToA\n            5: The AoA of the ToA value\n    \"\"\"\n    num_toas = len(arr_probe_toas)\n    AoA_matrix = np.zeros( (num_toas, 6))\n    #(3)!\n    AoA_matrix[:, 0] = -1\n\n    current_revolution_start_time = arr_opr_zero_crossing[0]\n    current_revolution_end_time = arr_opr_zero_crossing[1]\n    current_n = 0\n    #(4)!\n    for i, toa in enumerate(arr_probe_toas):\n        #(5)!\n        while toa &gt; current_revolution_end_time:\n            current_n += 1\n            if current_n &gt;= (len(arr_opr_zero_crossing) - 1):\n                break\n            current_revolution_start_time = arr_opr_zero_crossing[current_n]\n            current_revolution_end_time = arr_opr_zero_crossing[current_n + 1]\n\n        if current_n &gt;= (len(arr_opr_zero_crossing) - 1):\n            break\n        #(6)!\n        if toa &gt; current_revolution_start_time:\n            AoA_matrix[i, 0] = current_n\n            AoA_matrix[i, 1] = current_revolution_start_time\n            AoA_matrix[i, 2] = current_revolution_end_time\n            Omega = 2 * np.pi / (\n                current_revolution_end_time \n                - current_revolution_start_time\n            )\n            AoA_matrix[i, 3] = Omega\n            AoA_matrix[i, 4] = toa\n            AoA_matrix[i, 5] = Omega * (\n                toa \n                - current_revolution_start_time\n            )\n    #(7)!\n    return AoA_matrix\n</code></pre> <ol> <li> <p> Imports </p> <pre><code>from numba import njit\nimport numpy as np\n</code></pre> <p>There are two imports:</p> <ol> <li> <p><code>njit</code> from the <code>numba</code> library. <code>njit</code> instructs <code>numba</code> to compile the function to machine code.</p> </li> <li> <p><code>numpy</code>. We rename as <code>np</code>. This means we can access the Numpy library through <code>np</code>. This is a common convention. Numpy is a numerical computation library. </p> </li> </ol> </li> <li> <p> Function definition </p> <pre><code>@njit\ndef calculate_aoa(\n    arr_opr_zero_crossing : np.ndarray, \n    arr_probe_toas : np.ndarray\n):\n</code></pre> <p>In Python, you define a function with the <code>def</code> keyword. We define a function called <code>calculate_aoa</code> in Line 5. This function has two arguments (an argument is a fancy word for an input):</p> <ol> <li> <p><code>arr_opr_zero_crossing</code> : the array of OPR zero-crossing times.</p> </li> <li> <p><code>arr_probe_toas</code>: the array of ToAs from a single probe.</p> </li> </ol> </li> <li> <p> Initialize the AoA matrix and other variables  <pre><code>num_toas = len(arr_probe_toas)\nAoA_matrix = np.zeros( (num_toas, 6) )\n\nAoA_matrix[:, 0] = -1\n\ncurrent_revolution_start_time = arr_opr_zero_crossing[0]\ncurrent_revolution_end_time = arr_opr_zero_crossing[1]\ncurrent_n = 0\n</code></pre></p> <p>Here we initialize constants and variables required in the rest of the function: </p> <ul> <li> <p>In Line 31, we calculate the number of ToAs in <code>arr_probe_toas</code>. We need this length to initialize the output matrix. </p> </li> <li> <p>In Line 32 we instantiate the output matrix. The output matrix will contain the algorithm's results. This matrix is called <code>AoA_matrix</code>. The AoA matrix is a (<code>num_toas</code> \\(\\times\\) 6) matrix. Its columns represent:</p> <ul> <li>column 1: The revolution number within which each ToA falls</li> <li>column 2: The start time of the revolution</li> <li>column 3: The end time of the revolution</li> <li>column 4: The angular velocity of the shaft within the revolution</li> <li>column 5: The ToA</li> <li>column 6: The AoA of the ToA</li> </ul> </li> <li> <p>In Line 34 we set the entire revolution number column to -1. We use -1 to flag the ToAs that could not be converted to AoAs.</p> </li> <li> <p>In Line 36-38 we introduce the concept of the current revolution. Since this is a sequential function, we process each shaft revolution in turn. <code>current_n</code> is the revolution number the ToAs are currently in, <code>current_revolution_start_time</code> and <code>current_revolution_end_time</code>  is the start and end zero-crossing times of the current revolution. </p> </li> </ul> <p>These \"current\" values are updated as we iterate through the ToAs.</p> </li> <li> <p> Master loop </p> <pre><code>for i, toa in enumerate(arr_probe_toas):\n</code></pre> <p>This <code>for</code> loop iterates through each ToA in <code>arr_probe_toas</code>. The counter, <code>i</code>, starts at <code>0</code>- corresponding to the first ToA value - and increments after each iteration. The variable <code>toa</code> is the current ToA value being considered.</p> </li> <li> <p> Search for the correct shaft revolution </p> <pre><code>while toa &gt; current_revolution_end_time:\n    current_n += 1\n    if current_n &gt;= (len(arr_opr_zero_crossing) - 1):\n        break\n    current_revolution_start_time = arr_opr_zero_crossing[current_n]\n    current_revolution_end_time = arr_opr_zero_crossing[current_n + 1]\n\nif current_n &gt;= (len(arr_opr_zero_crossing) - 1):\n    break\n</code></pre> <p>Here we find the shaft revolution within which the current ToA occurs. It repeatedly checks, in Line 42, if the current ToA is larger than the current revolution's end time. If it is, the shaft has completed a revolution since the previous ToA. We therefore increment the current revolution (<code>current_n</code>) variable. We also update the current revolution's start and end times in lines 46 and 47.</p> <p>The statements in Lines 44 and 49 checks whether we have iterated over all the zero-crossing times. If this happens, our algorithm cannot perform any more comparisons. We therefore break out of the loop.</p> </li> <li> <p> Calculate the AoA matrix values for each ToA </p> <pre><code>if toa &gt; current_revolution_start_time:\n    AoA_matrix[i, 0] = current_n\n    AoA_matrix[i, 1] = current_revolution_start_time\n    AoA_matrix[i, 2] = current_revolution_end_time\n    Omega = 2 * np.pi / (\n        current_revolution_end_time \n        - current_revolution_start_time\n    )\n    AoA_matrix[i, 3] = Omega\n    AoA_matrix[i, 4] = toa\n    AoA_matrix[i, 5] = Omega * (\n        toa \n        - current_revolution_start_time\n    )\n\nreturn AoA_matrix\n</code></pre> <p>This is where we calculate the AoAs. In Line 52 we check whether the current ToA is larger than the current revolution's start time. If this test is passed, it means this ToA falls within the <code>current_n</code>th revolution. We assign the current revolution's start and end time to the AoA matrix in lines 53 - 55.</p> <p>In lines 56 - 65 the shaft speed and AoA as defined in Equation 1 and Equation 2 are calculated.</p> </li> <li> <p>When we reach Line 67, it means we have either iterated over all ToAs, or we have reached the end of the encoder's timestamps. </p> <p>The output matrix is returned.</p> </li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#example-usage","title":"Example usage","text":"<p>We'll use some real experimental data to test this function. We use a shaft run-up and run-down from Du Toit et al. (Du Toit et al., 2019)<sup>1</sup>. In the experiment, a five blade rotor was run-up and run-down, as already indicated in Figure 3. Four eddy current probes were used to measure the ToAs. </p> <p>The ToAs have already been extracted in this dataset. </p> <p>We use only one probe's data for this example:</p> <pre><code>dataset = Datasets[\"data/intro_to_btt/intro_to_btt_ch03\"] #(1)!\ndf_opr_zero_crossings = (\n    dataset['table/du_toit_2017_test_1_opr_zero_crossings'] #(2)!\n)\n\ndf_probe_toas = dataset['table/du_toit_2017_test_1_prox_1_toas'] #(3)!\nAoA_matrix = calculate_aoa(#(4)!\n    df_opr_zero_crossings[\"time\"].to_numpy(),\n    df_probe_toas[\"time\"].to_numpy()\n)\ndf_AoA = pd.DataFrame(#(5)!\n    AoA_matrix, \n    columns=[\n        \"n\",\n        \"n_start_time\",\n        \"n_end_time\",\n        \"Omega\",\n        \"ToA\",\n        \"AoA\"\n    ]\n)\n</code></pre> <ol> <li>Download the data from Bladesight's repository. The dataset comprises 6 measurements. Each test has one set of OPR zero-crossing times and four sets of ToAs. There is also a set of MPR values not used in this chapter.</li> <li>Load the OPR zero-crossing times from Test 1 as a Pandas DataFrame.</li> <li>Load the first proximity probe's ToAs from Test 1 as a Pandas DataFrame.</li> <li>Call the <code>calculate_aoa</code> function with the OPR zero-crossing times and the ToAs as inputs. Note we convert the Pandas columns to Numpy arrays with <code>.to_numpy()</code></li> <li>The algorithm returns a matrix. Numpy matrices and arrays do not have column names. Here we convert the matrix into a DataFrame. DataFrames are much simpler to work with.</li> </ol> <p>The first 10 rows of the AoA DataFrame are presented in Table 1 below.</p> Table 1: The first 10 rows of the AoA DataFrame.  n n_start_time n_end_time Omega ToA AoA -1 0 0 0 0 0 -1 0 0 0 0 0 0 0.0269571 0.0897037 100.136 0.0297463 0.279297 0 0.0269571 0.0897037 100.136 0.042336 1.53997 0 0.0269571 0.0897037 100.136 0.05479 2.78707 0 0.0269571 0.0897037 100.136 0.0673586 4.04564 0 0.0269571 0.0897037 100.136 0.079938 5.30528 1 0.0897037 0.152247 100.462 0.0924866 0.279575 1 0.0897037 0.152247 100.462 0.105059 1.54262 1 0.0897037 0.152247 100.462 0.117489 2.79133 <p>We note two observations:</p> <ul> <li>The first two rows have <code>n</code> values of -1. This means the first two ToAs were recorded before the first zero-crossing time. We can therefore not calculate the AoAs for these ToAs. You'll find a couple of these values at the end of the DataFrame as well.</li> <li>The <code>AoA</code> values repeat themselves every 5 rows. This is because the rotor has 5 blades.</li> </ul> <p>We drop the ToAs we could not convert to AoAs. These values are identified where <code>n</code> equals -1.</p> <pre><code>df_AoA = df_AoA[df_AoA[\"n\"] != -1]\ndf_AoA.reset_index(inplace=True, drop=True) #(1)!\n</code></pre> <ol> <li>Because we dropped the first two rows of data, the DataFrame's index starts at 2. It's always best to reset the index after dropping rows, unless the index contains important information.</li> </ol> <p>In Figure 4 below, we present a plot of the AoAs for the first blade over all revolutions. We also plot the angular velocity on a secondary y-axis.</p> Reset Zoom Figure 4: The AoAs of the first blade at the first proximity probe.  <p>In Figure 4 above, the AoAs are not constant. Why not? In a sense, the entire discipline of BTT is about understanding what causes the AoAs to change.</p> <p>We briefly discuss six topics that may be responsible for the AoAs to change:</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#discussion","title":"Discussion","text":"","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#sensor-limited-bandwidth-noise","title":"Sensor limited bandwidth noise","text":"<p>The drift in Figure 4 appears to be correlated to the rotor's angular velocity. In other words, as the shaft speeds up, the AoAs increase proportionally to the rotational speed. The moment the rotor starts to run down, the AoAs decrease. </p> <p>This is not related to blade vibration. This is related to the bandwidth of the sensor you are using. Any sensor has a limited frequency response. As the tips move faster, their presence inside your sensor's field of view become shorter. This causes the input function experienced by the sensor to contain more energy at higher frequencies.</p> <p>If your sensor's bandwidth is limited, it cuts out these high frequency components. This results in lower amplitude pulses. A lower amplitude pulse will manifest itself as delayed ToA triggering, and hence a larger AoA value.</p> <p>This is not a problem, though, because our resonance events occur at higher frequencies than this phenomenon. In later chapters, we remove this noise with a detrending algorithm.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#blade-vibration","title":"Blade vibration","text":"<p>There are four clear resonance events in this signal. They occur at 7.5, 17.83, 24.3, and 34.5 seconds respectively. We delve into the theory of resonance in Chapter 7. For now, we highlight there are just two unique resonances. The two resonances occur at 1087 RPM and 1275 RPM on both the run-up and the run-down.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#high-frequency-noise","title":"High frequency noise","text":"<p>The signal also contains high-frequency random noise. It has many possible causes such as electrical noise, shaft torsional vibration, casing vibration, or higher frequency blade vibration. This noise may be filtered out. You can also construct your inference algorithms to handle them. </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#non-constant-shaft-speed","title":"Non-Constant shaft speed","text":"<p>In Equation 1 we assumed the rotor's speed was constant within a revolution. This assumption, though not strictly correct, simplifies our processing and often incurs acceptably small errors. If you're interested in the effect of non-constant shaft speed on the AoAs, you can read about it here (Diamond et al., 2019)<sup>2</sup>.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#untwist-and-centrifugal-stiffening","title":"Untwist and centrifugal stiffening","text":"<p>As the rotor speeds up, the blades are subjected to increased centrifugal force. Most blade designs react to the centrifugal force by twisting. The twisting of the blade causes the AoA to change, because the blade's tip is now in a different static position.</p> <p>You need to understand your blade's design to understand how it reacts to centrifugal forces.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#increased-pressure-on-blades","title":"Increased pressure on blades","text":"<p>Increased rotor speed will cause increased fluid pressure on the blades. This will result in a static deflection of the blade. This deflection will cause the AoA to change. How much the AoA changes depends on the blade's stiffness and the fluid pressure.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#conclusion","title":"Conclusion","text":"<p>In this chapter, we have converted ToAs to AoAs. We are now firmly positioned in the distance domain, where we can reason about deflection, not time. At this stage we have not used any information about the rotor's characteristics. In the next chapter, we start to make the analysis specific to our rotor. We use the blade count to allocate the AoAs to the correct blades. </p> <p>Outcomes</p> <p> Understand we use a shaft encoder to calculate the shaft speed, \\(\\Omega\\), and the start and end of each revolution. </p> <p> Understand we need to find the revolution in which each ToA occurs.</p> <p> Understand each ToA is used to calculate the precise shaft circumferential displacement in said revolution. This is the AoA of each ToA.</p> <p> Write a function that calculates a matrix of AoAs from the shaft encoder zero-crossing times and the ToAs.</p> <p>I present coding exercises \ud83d\udc47 to solidify your the concepts covered in this chapter. </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to Justin Smith and Alex Brocco for reviewing this chapter and providing feedback.</p> <p>A special thanks to Miros\u0142aw Wito\u015b for his detailed review of this chapter.</p> <p> Dawie Diamond </p> <p> 2024-02-13 2025-02-17              </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#coding-exercises","title":"Coding Exercises","text":"<p>Here are some coding exercises to solidify the concepts we've covered in this chapter.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#problem-1","title":"Problem 1","text":"<p>In this chapter, we've written the <code>calculate_aoa</code> function. This function receives and returns Numpy arrays, though we work with Pandas DataFrames natively. We therefore needed to use the <code>.to_numpy()</code> method to convert the Pandas objects to numpy arrays. We also needed to cast the resulting matrix into a Pandas DataFrame, and drop the ToAs we could not convert to AoAs. </p> <p>In future, we do not want to do this every time we call the function.</p> <p> Write a new function, called <code>transform_ToAs_to_AoAs</code>, accepting Pandas DataFrames as inputs and returning a Pandas DataFrame as output. The function should call the <code>calculate_aoa</code> function to do the actual work.</p> Reveal answer (Please try it yourself before revealing the solution) <pre><code>def transform_ToAs_to_AoAs(\n    df_opr_zero_crossings : pd.DataFrame,\n    df_probe_toas : pd.DataFrame,\n) -&gt; pd.DataFrame:\n    \"\"\" This function transforms the ToA values to AoA values for a \n    single probe, given the OPR zero-crossing times and the proximity\n    probe's ToA values.\n\n    The timestamps are assumed to reside in the first column of\n    each DataFrame.\n\n    Args:\n        df_opr_zero_crossings (pd.DataFrame): A DataFrame with the \n            OPR zero-crossing times.\n        df_probe_toas (pd.DataFrame): A DataFrame with the probe's \n            ToA values.\n\n    Returns:\n        pd.DataFrame: A DataFrame with the AoA values.\n    \"\"\"\n    AoA_matrix = calculate_aoa(\n        df_opr_zero_crossings.iloc[:, 0].to_numpy(), #(1)!\n        df_probe_toas.iloc[:, 0].to_numpy()\n    )\n    df_AoA = pd.DataFrame(\n        AoA_matrix, \n        columns=[\n            \"n\",\n            \"n_start_time\",\n            \"n_end_time\",\n            \"Omega\",\n            \"ToA\",\n            \"AoA\"\n        ]\n    )\n    df_AoA = df_AoA[df_AoA[\"n\"] != -1]\n    df_AoA.reset_index(inplace=True, drop=True)\n    return df_AoA\n</code></pre> <ol> <li>We may want to pass in DataFrames with different column names than the ones we used in the example. We therefore use the <code>.iloc</code> method to get the first column of each DataFrame, regardless of what it is called.</li> </ol> <p>Example usage: <pre><code>&gt;&gt;&gt; dataset = Datasets[\"data/intro_to_btt/intro_to_btt_ch03\"]\n&gt;&gt;&gt; df_opr_zero_crossings = dataset['table/du_toit_2017_test_1_opr_zero_crossings']\n&gt;&gt;&gt; df_probe_toas = dataset['table/du_toit_2017_test_1_prox_1_toas']\n\n&gt;&gt;&gt; df_AoA = transform_ToAs_to_AoAs(\n    df_opr_zero_crossings,\n    df_probe_toas\n)\n</code></pre></p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#problem-2","title":"Problem 2","text":"<p>Because our Python functions are converted to C, one is tempted to treat code inefficiencies with a wink and a wry smile, as one does with a child that does something naughty you are secretly proud of.</p> <p>We must, however, resist this temptation. We must always strive to write efficient code. </p> <p> There are unnecessary calculations in the <code>calculate_aoa</code> function. Can you spot where? Rewrite the function to remove this inefficiency.</p> Reveal answer (Please try it yourself before revealing the solution) <p><pre><code>@njit\ndef calculate_aoa(\n    arr_opr_zero_crossing : np.ndarray, \n    arr_probe_toas : np.ndarray\n):\n    \"\"\"\n    This function calculates the angle of arrival of \n    each ToA value relative to the revolution in \n    which it occurs.\n\n    Args:\n        arr_opr_zero_crossing (np.array): An array of \n            OPR zero-crossing times. \n        arr_probe_toas (np.array): An array of \n            ToA values.\n\n    Returns:\n        np.array: A matrix of AoA values. Each row in the \n            matrix corresponds to a ToA value. The columns \n            are:\n            0: The revolution number\n            1: The zero-crossing time at the start of the revolution\n            2: The zero-crossing time at the end of the revolution\n            3: The angular velocity of the revolution\n            4: The ToA\n            5: The AoA of the ToA value\n    \"\"\"\n    num_toas = len(arr_probe_toas)\n    AoA_matrix = np.zeros( (num_toas, 6))\n\n    AoA_matrix[:, 0] = -1\n\n    current_revolution_start_time = arr_opr_zero_crossing[0]\n    current_revolution_end_time = arr_opr_zero_crossing[1]\n    Omega = 2 * np.pi / (\n        current_revolution_end_time \n        - current_revolution_start_time\n    )\n    current_n = 0\n\n    for i, toa in enumerate(arr_probe_toas):\n\n        while toa &gt; current_revolution_end_time:\n            current_n += 1\n            if current_n &gt;= (len(arr_opr_zero_crossing) - 1):\n                break\n            current_revolution_start_time = arr_opr_zero_crossing[current_n]\n            current_revolution_end_time = arr_opr_zero_crossing[current_n + 1]\n            Omega = 2 * np.pi / (\n                current_revolution_end_time \n                - current_revolution_start_time\n            )\n        if current_n &gt;= (len(arr_opr_zero_crossing) - 1):\n            break\n        #\n        if toa &gt; current_revolution_start_time:\n            AoA_matrix[i, 0] = current_n\n            AoA_matrix[i, 1] = current_revolution_start_time\n            AoA_matrix[i, 2] = current_revolution_end_time\n            AoA_matrix[i, 3] = Omega\n            AoA_matrix[i, 4] = toa\n            AoA_matrix[i, 5] = Omega * (\n                toa \n                - current_revolution_start_time\n            )\n\n    return AoA_matrix\n</code></pre> We have moved the calculation of \\(\\Omega\\) to the while loop from the if statement at the bottom. Now, every time we update the zero-crossing times, we calculate the rotor's speed only once. The previous method calculated the shaft speed once for every ToA.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch3/#problem-3","title":"Problem 3","text":"<p>The dataset we used in this chapter also has MPR zero-crossing times we did not use. These values can be loaded with this command:</p> <pre><code>df_mpr_zero_crossings = dataset['table/du_toit_2017_test_1_mpr_zero_crossings']\n</code></pre> <p>The MPR encoder used for this measurement has 79 sections. You can therefore assume each encoder section represents \\(\\frac{1}{79}\\)th of a rotation.</p> <p> Write a new function, <code>calculate_aoa_from_mpr</code>, accepting the MPR timestamps, the number of sections in the MPR, and the ToAs as inputs. The function should return a DataFrame with the AoAs. The resulting AoA matrix should also include the MPR section number within which each ToA occurs.</p> Reveal answer (Please try it yourself before revealing the solution) <p><pre><code>def calculate_aoa_from_mpr(\n    arr_mpr_zero_crossing : np.ndarray,\n    arr_probe_toas : np.ndarray,\n    mpr_sections : int = 1,\n) -&gt; np.ndarray:\n    \"\"\" This function calculates the angle of arrival of\n    each ToA value relative to the section and revolution in\n    which it occurs when using an MPR encoder.\n\n    Args:\n        arr_mpr_zero_crossing (np.ndarray): An array of MPR\n            zero-crossing times.\n        arr_probe_toas (np.ndarray): An array of ToA values.\n        mpr_sections (int, optional): The number of sections\n            in the MPR encoder. Defaults to 1, in this case,\n            this function will be treated as an OPR encoder.\n\n    Returns:\n        np.ndarray: A matrix of AoA values. Each row in the\n            matrix corresponds to a ToA value. The columns\n            are:\n            0: The revolution number\n            1: The section number\n            2: The zero-crossing time at the start of the revolution\n            3: The zero-crossing time at the end of the revolution\n            4: The angular velocity of the revolution\n            5: The ToA\n            6: The AoA of the ToA value\n    \"\"\"\n    num_toas = len(arr_probe_toas)\n    AoA_matrix = np.zeros((num_toas, 7))\n    rad_per_section = 2 * np.pi / mpr_sections\n    AoA_matrix[:, 0] = -1\n\n    current_revolution_start_time = arr_mpr_zero_crossing[0]\n    current_revolution_end_time = arr_mpr_zero_crossing[1]\n    Omega = rad_per_section / (\n        current_revolution_end_time \n        - current_revolution_start_time\n    )\n    current_n = 0\n    current_revo = 0\n    current_section = 0\n\n    for i, toa in enumerate(arr_probe_toas):\n\n        while toa &gt; current_revolution_end_time:\n            current_n += 1\n            if current_n &gt;= (len(arr_mpr_zero_crossing) - 1):\n                break\n            current_revolution_start_time = arr_mpr_zero_crossing[current_n]\n            current_revolution_end_time = arr_mpr_zero_crossing[current_n + 1]\n            Omega = rad_per_section / (\n                current_revolution_end_time \n                - current_revolution_start_time\n            )\n            current_section += 1\n            if current_section == mpr_sections:\n                current_section = 0\n                current_revo += 1\n\n\n        if current_n &gt;= (len(arr_mpr_zero_crossing) - 1):\n            break\n\n        if toa &gt; current_revolution_start_time:\n            AoA_matrix[i, 0] = current_revo\n            AoA_matrix[i, 1] = current_section\n            AoA_matrix[i, 2] = current_revolution_start_time\n            AoA_matrix[i, 3] = current_revolution_end_time\n            AoA_matrix[i, 4] = Omega\n            AoA_matrix[i, 5] = toa\n            AoA_matrix[i, 6] = Omega * (\n                toa\n                - current_revolution_start_time\n            ) + current_section * rad_per_section\n\n    return AoA_matrix\n\ndef transform_ToAs_to_AoAs_mpr(\n    df_mpr_zero_crossings : pd.DataFrame,\n    df_probe_toas : pd.DataFrame,\n    mpr_sections : int = 1,\n) -&gt; pd.DataFrame:\n    \"\"\" This function transforms the ToA values to AoA values for a \n    single probe, given the MPR zero-crossing times and the proximity\n    probe's ToA values.\n\n    The timestamps are assumed to reside in the first column of\n    each DataFrame.\n\n    Args:\n        df_opr_zero_crossings (pd.DataFrame): A DataFrame with the \n            OPR zero-crossing times.\n        df_probe_toas (pd.DataFrame): A DataFrame with the probe's \n            ToA values.\n        mpr_sections (int, optional): The number of sections\n            in the MPR encoder. Defaults to 1, in this case,\n            this function will be treated as an OPR encoder.\n\n    Returns:\n        pd.DataFrame: A DataFrame with the AoA values.\n    \"\"\"\n    AoA_matrix = calculate_aoa_from_mpr(\n        df_mpr_zero_crossings.iloc[:, 0].to_numpy(),\n        df_probe_toas.iloc[:, 0].to_numpy(),\n        mpr_sections\n    )\n    df_AoA = pd.DataFrame(\n        AoA_matrix, \n        columns=[\n            \"n\",\n            \"mpr_section\",\n            \"section_start_time\",\n            \"section_end_time\",\n            \"Omega\",\n            \"ToA\",\n            \"AoA\"\n        ]\n    )\n    df_AoA = df_AoA[df_AoA[\"n\"] != -1]\n    df_AoA.reset_index(inplace=True, drop=True)\n    return df_AoA\n</code></pre> </p> <p>Note</p> <p>MPR encoder signal processing is, however, nontrivial. For instance, we have assumed here all encoder sections have the same circumferential width. This is almost never the case. I have recently added a correct MPR approach to Bladesight. I'll write a short tutorial on how to use it soon.</p> <p>The function <code>calculate_aoa_from_mpr</code> increments each section, instead of each revolution. The function can, however, transform the ToAs with an OPR encoder if you set <code>mpr_sections</code> to 1.</p> <p>In Figure 5 below, we show the AoAs calculated from the MPR encoder vs the same values calculated from the OPR encoder. The AoAs from the MPR algorithm appear less noisy than the AoAs from the OPR algorithm.   Reset Zoom Figure 5: The AoAs of the fifth blade at the first proximity probe. The AoAs were calculated with both the MPR encoder and the OPR encoder.  </p> <p>MPR encoders will always produce more accurate BTT results than OPR encoders. One reason for this is because MPR encoders capture high frequency shaft torsional vibration. This allows us to remove it from the AoAs. An OPR encoder cannot capture this torsional vibration. High frequency shaft torsional vibration therefore appears as high-frequency content in our AoAs when we use OPR encoders.</p> <ol> <li> <p>Du Toit, R., Diamond, D., Heyns, P.S., 2019. A stochastic hybrid blade tip timing approach for the identification and classification of turbomachine blade damage. Mechanical Systems and Signal Processing 121, 389--411.\u00a0\u21a9</p> </li> <li> <p>Diamond, D., Heyns, P.S., Oberholster, A., 2019. Improved blade tip timing measurements during transient conditions using a state space model. Mechanical Systems and Signal Processing 122, 555--579.\u00a0\u21a9</p> </li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/","title":"4. Allocating AoAs to blades","text":"You are here","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#allocating-aoas-to-blades","title":"Allocating AoAs to blades","text":"<p>Taxonomy is the discipline of classifying entities. It is usually associated with the biological sciences. It is, however, a useful concept in many fields.</p> <p>This chapter deals with the taxonomy of AoA values. What exactly needs to be classified? We need to classify the AoAs into bins, such that each bin contains the AoAs of a single blade.</p> <p>Here's an illustration of what we've covered so far, and what we're about to cover:</p> <p> Figure 1:          An illustration of this chapter's theme. We have one proximity probe and one One Pulse per Revolution (OPR) sensor. In Chapter 3, we converted the ToAs into an array of AoAs. This chapter takes the next logical step: allocating the AoAs to specific blades.     </p> <p>Figure 1 restates that we converted ToAs into AoAs in the previous chapter. We still only have a large, unstructured array of AoAs. In this chapter, for the first time, we use information specific to the rotor: the number of blades.</p> <p>It may seem overly redundant to dedicate an entire chapter to identify which AoAs belong to which blades. Is it not obvious that the second blade arrives after the first? This may sometimes be the case, but it is too simplistic an approach. It's the kind of solution a Large Language Model(LLM) like ChatGPT would give. Real engineering problems do not bend to the whims of LLMs.</p> <p>This chapter develops a robust methodology to assign AoAs to specific blades. Giving yourself permission to study the fundamentals will pay dividends in the future.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#first-attempt","title":"First attempt","text":"<p>Let's generate example data to help us explore the problem space. I've generated AoAs for a 5 blade rotor using the code below. Do not get bogged down in the details of this code. The important thing is that we have 5 blades and one sensor. This produces a vector of AoAs. </p> <pre><code>import numpy as np\nimport pandas as pd\n\ndelta = -20\nblade_means = np.deg2rad([72, 144+delta, 216+delta, 288+delta, 360+delta])#(1)!\naoa_values = []\nBLADE_COUNT = 5\n# Set random seed for reproducibility\nnp.random.seed(0)#(2)!\nfor n in range(50):#(3)!\n    r = 0.5 + 0.5/50 * n#(4)!\n    for b in range(BLADE_COUNT):\n        aoa_current = blade_means[b] + np.random.uniform(-np.pi*0.07, np.pi*0.07)#(5)!\n        # Reject values with probability &lt; 0.05\n        if np.random.rand() &gt; 0.05:#(6)!\n            aoa_values.append({\n                \"n\" : n,\n                \"aoa\" : aoa_current,\n                \"plot_r\" : r,#(7)!\n            })\ndf_aoas = pd.DataFrame(aoa_values)\n</code></pre> <ol> <li> <p>We specify the mean AoA for each blade. We also specify a <code>delta</code> value that we use to shift the mean AoA for blades 2 through 5. </p> <p>This is to simulate the effect of blades that are not perfectly equidistant from one another. Our example shifts all except the first blade by 20 degrees. This is an extreme amount to shift. In practice, the blades will be more-or-less equidistant from one another. We use this <code>delta</code> to showcase the complexity introduced by non-equidistant blades.</p> </li> <li> <p>We set the random seed to ensure reproducibility. It ensures that our random values are the same every time we run the code.</p> </li> <li>We generate data for 50 shaft revolutions. Why 50? It's an arbitrary number that helps us make our point.</li> <li>This <code>radius</code> value has no physical meaning. It is simply a value that enables us to plot the AoAs on a polar plot. It is not related to the radius of the rotor.</li> <li>We generate a random AoA value for each blade, as if it passed by the proximity sensor. We add a random value between \\(-\\pi \\times 0.07\\) and \\(\\pi \\times 0.07\\) to the mean AoA value. This is to simulate the effect of noise and vibration. Why \\(-\\pi \\times 0.07\\) and \\(\\pi \\times 0.07\\)? Once again, these values are arbitrary but sufficient to illustrate the point.</li> <li>We reject 5% of the AoAs. This is to simulate the effect of 'missing pulses' in our data. Our BTT DAQ should, in theory, be able to capture all the pulses. In practice, however, this is often not the case. We need to develop an algorithm that can handle missing ToAs.</li> <li>We reiterate that the <code>radius</code> value has no physical meaning. It is simply a value that enables us to plot the AoAs on a polar plot.</li> </ol> <p>The AoAs are plotted in Figure 2 below.</p> <p> Figure 2: The raw AoAs are shown on a polar plot. The radial dimension is not related to the blade's radius. We've spread our AoAs radially because it's simpler to visualize. </p> <p>In Figure 2 above, there are five distinct \"groups\" of AoAs. Intuitively, we expect each group to correspond to a blade. We now develop an algorithm to assign each AoA to a blade.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#sequential-allocation","title":"Sequential allocation","text":"<p>To help us reason through the first approach, the first 10 AoAs are presented in Table 1 below:</p> Table 1: The first 10 AoAs.  n aoa plot_r 0 1.27811 0.5 0 2.20941 0.5 0 3.38727 0.5 0 4.65003 0.5 0 6.13805 0.5 1 1.38494 0.51 1 2.19414 0.51 1 3.23218 0.51 1 4.46646 0.51 1 6.05646 0.51 <p>Humans excel at pattern recognition. From Table 1 above, it's clear the AoAs arrive in a sequence. Each AoA in the table seems to increase by \\(\\frac{2 \\pi}{5}\\) radians until the fifth value, after which the pattern repeats itself. It seems obvious that we should be able to allocate the AoAs sequentially. In other words, blade 1's AoA is located in row 1, then blade 2, and so on.</p> <p>A reasonable strategy would be to assign every 5th AoA to the same blade:</p> <pre><code>df_aoa_sequential = df_aoas.copy(deep=True)\ndf_aoa_sequential['blade'] = None\ndf_aoa_sequential.loc[::5, 'blade'] = 1 #(1)!\ndf_aoa_sequential.loc[1::5, 'blade'] = 2\ndf_aoa_sequential.loc[2::5, 'blade'] = 3\ndf_aoa_sequential.loc[3::5, 'blade'] = 4\ndf_aoa_sequential.loc[4::5, 'blade'] = 5\n</code></pre> <ol> <li><code>[::5]</code> is Python notation for \"select every 5th value\".</li> </ol> <p>Every AoA is now assigned. We can therefore use a different style marker to discern between the assigned groups. The results are displayed in Figure 3 below.</p> <p> Figure 3: This plot indicates the results of sequential AoA allocation. In other words, we've grouped every 5th AoA value together.      </p> <p>Figure 3 is a disaster. </p> <p>We would expect five distinct groups clustered around different circumferential areas. Rather, each AoA group has members spread out over the entire circumferential range from 0 to 360 degrees.</p> <p>Why did this happen? Because we introduced \"missing pulses\" when we generated the AoAs. If only one pulse is missing, all of our AoAs will be incorrectly grouped. This is a common problem in BTT analysis. We must therefore develop a sequence-independent algorithm.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#binned-allocation","title":"Binned allocation","text":"<p>Let's rather group the AoAs into angular bins. We create five equally spaced bins and slice the AoA vector up into these bins. The first bin's edge starts at 0 degrees. Each bin is \\(\\frac{360}{5}\\) degrees wide. </p> <p><pre><code>bin_left_edges  -&gt;  [0,  72,  144, 216, 288]\nbin_right_edges -&gt; [72, 144, 216, 288, 360]\n</code></pre> The allocation is performed below:</p> <pre><code>df_aoa_binned = df_aoas.copy(deep=True)\ndf_aoa_binned['blade'] = None\nbin_edges = [0, 72, 144, 216, 288] #(1)!\nbin_edges_rad = np.deg2rad(bin_edges) #(2)!\nfor b, bin_left_edge in enumerate(bin_edges_rad): #(3)!\n    bin_right_edge = bin_left_edge + 2*np.pi/5 #(4)!\n    ix_in_bin = (\n        (df_aoa_binned['aoa'] &gt;= bin_left_edge) \n        &amp; (df_aoa_binned['aoa'] &lt; bin_right_edge)\n    ) #(5)!\n    df_aoa_binned.loc[ix_in_bin, 'blade'] = b + 1 #(6)!\n</code></pre> <ol> <li>We specify the left edges of the bins. They are all equally wide.</li> <li>We convert from degrees to radians to get them to the same unit as the AoAs.</li> <li>The <code>enumerate</code> function returns the index and left edge of the bin we are currently considering.</li> <li>We calculate the position of the right edge. It's always \\(\\frac{2 \\pi}{5}\\) radians larger than the left edge.</li> <li>We create a boolean mask to identify the AoAs that fall within the bin we are currently considering.</li> <li>We use the mask to allocate the appropriate AoAs to its corresponding blade.</li> </ol> <p>The groups are plotted in Figure 4 below. The group edges have been added to the plot.</p> <p> Figure 4: The AoA groups as a consequence of binning. The AoA allocation is better, but not perfect. The AoAs from blades 1 and 2 are mixed.     </p> <p>Figure 4 above is a significant improvement over Figure 3. The groups seem more sensible.</p> <p>However, some of blade 1's AoAs are grouped with blade 2. This is because the AoAs from blade 1 fall close to the first bin's edge. We cannot control where the AoAs fall. It is a function of the rotor's blade count and the location of our OPR sensor. Our algorithm should be able to adapt to this.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#rotated-bin-allocation","title":"Rotated bin allocation","text":"<p>Instead of the first bin starting at 0 degrees, we subtract an offset to each edge. Let's subtract an offset. We call the offset <code>d_theta</code>. Let's set <code>d_theta</code> equal to half the current bin width, 72\u00b0/2 = 36\u00b0, for this example. </p> <pre><code>bin_left_edges  -&gt; [-36,36,  108, 180, 252]\nbin_right_edges -&gt; [36, 108, 180, 252, 324]\n</code></pre> <p>The code to perform the allocation is similar to the previous example. We need, however, to include a second mask to check for the AoAs close to the 0\u00b0/360\u00b0 boundary. We'll discuss this in more depth later in the chapter. </p> <pre><code>df_aoa_rotated_binned = df_aoas.copy(deep=True)\ndf_aoa_rotated_binned['blade'] = None\nbin_edges_new = [-36, 36, 108, 180, 252]\nbin_edges_new_rad = np.deg2rad(bin_edges_new)\nfor b, bin_left_edge in enumerate(bin_edges_new_rad):\n    bin_right_edge = bin_left_edge + 2*np.pi/5\n    ix_in_bin = (\n        (\n                (df_aoa_rotated_binned['aoa'] &gt;= bin_left_edge) \n                &amp; (df_aoa_rotated_binned['aoa'] &lt; bin_right_edge)\n        )\n        | (\n                ((df_aoa_rotated_binned['aoa'] - 2*np.pi) &gt;= bin_left_edge) # (1)!\n                &amp; ((df_aoa_rotated_binned['aoa'] - 2*np.pi) &lt; bin_right_edge)\n        )\n    )\n    df_aoa_rotated_binned.loc[ix_in_bin, 'blade'] = b + 1\n</code></pre> <ol> <li>The second mask to check for AoAs close to the 0\u00b0/360\u00b0 boundary.</li> </ol> <p>We plot the result in Figure 5 below.</p> <p> Figure 5: The grouping as a consequence of a rotated bin approach. Our groups are finally correct  .     </p> <p>Finally our allocation is perfect. The AoAs from each blade are grouped together. This is the allocation we always want to achieve. </p> <p>In this example, we've manually chosen the offset. We would rather use an algorithm to automate the process. </p> <p>How can we determine the quality of the allocation? Intuitively, we expect the AoAs from each blade to occur in the middle of its bin. The closer it is to an edge, the higher the likelihood of misclassification.</p> <p>This chapter therefore develops an algorithm to identify the optimal offset, <code>d_theta</code>. The optimal offset causes each bin's AoAs to be located in the middle of the bin.</p> <p>Outcomes</p> <p> Calculate the optimal <code>d_theta</code> to group the AoAs into blade bins by minimizing a quality factor \\(Q\\).</p> <p> Understand that the first blade may arrive close to the OPR zero-crossing time. This can make the blade appear either at the start or end of the revolution. We need to cater for this scenario.</p> <p> Write a function that determines the optimal blade bins for a set of AoAs, and split the proximity probe AoA DataFrames into several individual blade DataFrames.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#follow-along","title":"Follow along","text":"<p>The worksheet for this chapter can be downloaded here .</p> <p>You can open a Google Colab session of the worksheet here: .</p> <p>You need to use one of these Python versions to run the worksheet:  .</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#load-the-data","title":"Load the data","text":"<p>We load the same dataset that we used for Chapter 3. We only get the AoAs from the first probe and store it in <code>df_prox_1</code>. </p> <pre><code>from bladesight import Datasets\nfrom bladesight.btt.aoa import transform_ToAs_to_AoAs\n\ndataset = Datasets['data/intro_to_btt/intro_to_btt_ch03']\ndf_opr_zero_crossings = dataset[f\"table/du_toit_2017_test_1_opr_zero_crossings\"]\ndf_prox_1_toas = dataset[f\"table/du_toit_2017_test_1_prox_1_toas\"]\n\ndf_prox_1 = transform_ToAs_to_AoAs(\n    df_opr_zero_crossings,\n    df_prox_1_toas\n)\n</code></pre>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#our-algorithm","title":"Our algorithm Initialization  Identify the AoAs inside each bin  Determine each bin's Q factor contributionSanity checks and return","text":"<p>We've discussed that a \"good\" allocation is one where the AoAs from each blade occur close to the center of its bin. To quantify this intuitive approach, we create a quality factor, \\(Q\\).</p> <p>\\(Q\\) is the sum of squared errors between the center of each bin and each AoA within it.</p> \\[\\begin{equation} Q = \\sum_{b=1}^{B} \\sum_{n=1}^{N_b} \\left (\\hat{AoA}_{b} (\\delta \\theta) - AoA_{b, n}\\right)^2 \\end{equation}\\] Symbols Symbol Description \\(Q\\) The blade bin quality factor \\(\\delta \\theta\\) <code>d_theta</code>, the offset we apply to the bin edges \\(b\\) The blade index \\(B\\) The total number of blades \\(n\\) The index of the AoA inside bin \\(b\\) \\(N\\) The total number of AoAs inside bin \\(b\\) \\(\\hat{AoA}_{b}\\) The center AoA of bin \\(b\\) \\(AoA_{b, n}\\) The \\(n\\)th AoA inside bin \\(b\\) <p>Below, we show the domains of the variables for this example:</p> \\[ \\begin{align}     Q &amp;\\in [0, \\infty] \\\\     b &amp;\\in [0,1,2,3,4] \\\\     B &amp;= 5 \\\\     n &amp;\\in [0, ..., N] \\\\     N &amp;\\rightarrow \\textrm{computed for each bin} \\\\     \\hat{AoA}_{b} &amp;\\in [0, 2 \\pi] \\\\     AoA_{b, n} &amp;\\in [0, 2 \\pi] \\\\ \\end{align} \\] <p>The below function calculates Q for a given blade number and offset. I've added detailed comments that can be opened by clicking on the  symbols. If they do not open, please refresh the page.</p> <pre><code>def calculate_Q( #(1)!\n    arr_aoas : np.ndarray,\n    d_theta : float,\n    N : int\n) -&gt; Tuple[float, np.ndarray]:\n    bin_edges = np.linspace(0 + d_theta, 2*np.pi + d_theta, N + 1)\n    Q = 0\n    for b in range(N):#(2)!\n        left_edge = bin_edges[b]\n        right_edge = bin_edges[b + 1]\n        bin_mask = (arr_aoas &gt; left_edge) &amp; (arr_aoas &lt;= right_edge)\n\n        bin_centre = (left_edge + right_edge)/2 #(3)!\n        Q += np.sum(\n            (\n                arr_aoas[bin_mask] \n                - bin_centre\n            )**2 \n        )\n    if np.sum(arr_aoas &lt; bin_edges[0]) &gt; 0:#(4)!\n        return np.nan, bin_edges\n    if np.sum(arr_aoas &gt; bin_edges[-1]) &gt; 0:\n        return np.nan, bin_edges\n    return Q, bin_edges\n</code></pre> <ol> <li> <p></p> <p><pre><code>def calculate_Q(\n    arr_aoas : np.ndarray,\n    d_theta : float,\n    N : int\n) -&gt; Tuple[float, np.ndarray]:\n    bin_edges = np.linspace(0 + d_theta, 2*np.pi + d_theta, N + 1)\n    Q = 0\n</code></pre> In lines 1 - 4, the function name and input arguments are defined. <code>arr_aoas</code> is a numpy array of AoAs, in radians, <code>d_theta</code> is our guess for the shift to apply to the \"standard\" edges, and <code>N</code> is the number of blades. </p> <p>In Line 5, we specify the function's return type. It's a tuple - a fancy word for an immutable list - with two values: <code>Q</code> and <code>bin_edges</code>. <code>Q</code> is the quality factor, and <code>bin_edges</code> are the edges caused by this choice of <code>d_theta</code>.</p> <p>Note</p> <p>You need to import the <code>Tuple</code> type from the <code>typing</code> library.</p> <pre><code>from typing import Tuple\n</code></pre> <p>In Line 6, we calculate the <code>bin_edges</code> based on the choice of <code>d_theta</code>.</p> <p>In Line 7, we initialize the quality factor to zero.</p> </li> <li> <p></p> <pre><code>for b in range(N):\n    left_edge = bin_edges[b]\n    right_edge = bin_edges[b + 1]\n    bin_mask = (arr_aoas &gt; left_edge) &amp; (arr_aoas &lt;= right_edge)\n</code></pre> <p>In Line 7, we enter our main loop, whereby we will consider each bin in turn.</p> <p>In lines 8 and 9, we select the left and right edges of the current bin.</p> <p>In Line 10, we determine which AoAs fall within the current bin. <code>bin_mask</code> is a boolean array, with the same length as <code>arr_aoas</code>. If the mask has a value of <code>True</code> at a given index, it means the corresponding AoA value falls within the current bin.</p> </li> <li> <p></p> <pre><code>bin_centre = (left_edge + right_edge)/2\nQ += np.sum(\n    (\n        arr_aoas[bin_mask] \n        - bin_centre\n    )**2 \n)\n</code></pre> <p>In Line 12, the center of the bin is calculated. This is \\(\\hat{AoA}_{b}\\) in Equation 1.</p> <p>In lines 13 - 18, we calculate the squared difference between each AoA and its corresponding bin's center. We sum these squared differences and add it to \\(Q\\). If the centre is close to the AoAs, \\(Q\\) will not increase much. If the centre is far from the AoAs, \\(Q\\) will increase significantly.</p> </li> <li> <p></p> <pre><code>if np.sum(arr_aoas &lt; bin_edges[0]) &gt; 0:\n    return np.nan, bin_edges\nif np.sum(arr_aoas &gt; bin_edges[-1]) &gt; 0:\n    return np.nan, bin_edges\nreturn Q, bin_edges\n</code></pre> <p>We've added sanity checks to the function. Why is it necessary to add sanity checks? Our code in lines 8 to 19 only consider AoAs between the left and right edges of the current bin. The offset <code>d_theta</code> will shift the edges such that some AoAs do not fall within any bin.</p> <p>For instance, if <code>d_theta</code> is -10\u00b0, the last bin's right edge will be at 350\u00b0. If the final blade is clustered around 355\u00b0, our algorithm will not consider it in the \\(Q\\) factor because every value in our <code>bin_mask</code> will be <code>False</code> for anything above 350\u00b0.</p> <p>We therefore check, in lines 20 and 22, if <code>d_theta</code> is valid. <code>d_theta</code> is invalid if any AoAs occur outside the far left or right bin edges. We return <code>np.nan</code> for <code>Q</code> to indicate <code>dtheta</code> is invalid.</p> <p>Finally, in Line 24, we return <code>Q</code> and <code>bin_edges</code>.</p> </li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#implementation-example","title":"Implementation example","text":"<p>We can now calculated \\(Q\\) for a range of possible <code>d_theta</code>s. We perform the calculation for <code>d_theta</code>s between \\(-\\frac{\\pi}{5}\\) and \\(\\frac{\\pi}{5}\\). This shifts the \"standard\" bins left and right by a maximum of 72\u00b0. </p> <p>The \\(Q\\) factor for each <code>d_theta</code> is calculated below.</p> <pre><code>B = 5#(1)!\nd_thetas = np.linspace(-np.pi/B, np.pi/B, 200) #(2)!\narr_aoas = df_prox_1[\"AoA\"].to_numpy()#(3)!\nQs = [] #(4)!\noptimal_Q, optimal_bin_edges, optimal_d_theta = np.inf, None, None#(5)!\nfor d_theta in d_thetas:#(6)!\n    Q, bin_edges = calculate_Q(arr_aoas, d_theta, B)\n    if Q &lt; optimal_Q:#(7)!\n        optimal_Q = Q*1\n        optimal_bin_edges = bin_edges\n        optimal_d_theta = d_theta*1\n    Qs.append(Q)#(8)!\n</code></pre> <ol> <li>The number of blades.</li> <li>We specify the range of offsets to consider. We'll consider 200 offsets between \\(-\\frac{\\pi}{5}\\) and \\(\\frac{\\pi}{5}\\).</li> <li>We convert the AoA DataFrame into a Numpy array because our function does not work with a Pandas series.</li> <li>We initialize an empty list to store the quality factors.</li> <li>We initialize the optimal Q value to infinity. This is a trick to ensure the first value we calculate is always the optimal value. It can be unseated by a better value later.</li> <li>We iterate over the range of offsets to consider.</li> <li>If the quality factor we just calculated is less than the best value so far, we update all the \"optimal\" values.</li> <li>We append the quality factor to a list. This will be used to plot the quality factor as a function of the offset.</li> </ol> <p>The <code>Q</code> factor for each <code>d_theta</code> is plotted in Figure 6 below.</p> Reset Zoom Figure 6:      The quality factor, Q, as a function of the offset, d_theta. The optimal offset is -20.08\u00b0.    <p>And voila! The optimal offset is -20.08 degrees.</p> How to choose the offset count <p>I've selected 200 values between \\(-\\frac{\\pi}{5}\\) and \\(\\frac{\\pi}{5}\\) to search through. The choice of 200 is arbitrary, you can choose your own value. You need to ensure, however, your grid is fine enough to capture the optimal offset. If you choose too few values, you may miss the optimal offset. If you choose too many values, you may waste time.</p> The effects of non-equidistant probe spacing <p>At this stage it may be unclear how probe spacing affects our analysis. Especially, how non-equidistant probe spacing affects our analysis.</p> <p>I cannot stress this enough: The algorithm we've developed here is only applied to AoAs from one probe. Multiple probes are combined using a different approach, which we discuss in the next chapter.</p> Why not use an optimization algorithm <p>To find the optimum <code>d_theta</code>, we've resorted to a simple one dimensional grid-search algorithm. This is because the problem is simple. </p> <p>We could use a more sophisticated optimization algorithm, but it would be overkill for this problem.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#one-dataframe-per-blade","title":"One DataFrame per blade","text":"<p>Now that we have the optimal bin edges, we cut the proximity probe AoA DataFrame into separate DataFrames for each blade:</p> <pre><code>blade_dfs = []#(1)!\nfor b in range(B):#(2)!\n    ix_bin = (#(3)!\n        (df_prox_1[\"AoA\"] &gt; optimal_bin_edges[b])\n        &amp; (df_prox_1[\"AoA\"] &lt;= optimal_bin_edges[b + 1])\n    )\n    blade_dfs.append(\n        df_prox_1.loc[ix_bin] #(4)!\n    )\n</code></pre> <ol> <li>We initialize an empty list to store the DataFrames for each blade.</li> <li>The for loop allows us to consider each blade in turn.</li> <li><code>ix_bin</code> is our boolean mask which indicates if the AoAs fall inside bin number <code>b</code>.</li> <li>We use the <code>.loc</code> method to only select the values inside bin <code>b</code>.</li> </ol> <pre><code>for b in range(B):\n    print(f\"Blade {b} mean: {blade_dfs[b]['AoA'].mean()}, std: {blade_dfs[b]['AoA'].std()}\")\n</code></pre> <pre><code>Blade 0 mean: 0.280844143512115, std: 0.0014568064245125216\nBlade 1 mean: 1.5390655934492143, std: 0.001784799129959647\nBlade 2 mean: 2.788312464321002, std: 0.0015687549238434136\nBlade 3 mean: 4.045575640802255, std: 0.0017088093157144036\nBlade 4 mean: 5.305095908129366, std: 0.0014525709531342695\n</code></pre> <p>Finally, we have 5 DataFrames, one for each blade. </p> Why report the mean and standard deviation? <p>I use the mean and standard deviation as a check for the quality of the allocation. The mean of each blade's dataframe should correspond to the bin center. The standard deviation should be small, because all AoAs should be close to the center.</p> <p>If, for some reason, your alignment is off, the standard deviations will shoot through the roof.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#blade-wrap-around","title":"Blade wrap-around","text":"<p>Let's shift the AoAs from their original position to illustrate an extreme case. This shift is artificial. It is, however, equivalent to what would happen if we positioned the proximity probe or the OPR sensor at a different circumferential location. In short, a constant shift of the AoAs don't objectively change anything about them. We should be able to find the same \\(Q\\) value as we did in the previous section.</p> <pre><code>df_prox_1_shifted = df_prox_1.copy(deep=True) #(1)!\ndf_prox_1_shifted['AoA'] = df_prox_1_shifted['AoA'] - 0.280844143512115\ndf_prox_1_shifted['AoA'] = df_prox_1_shifted['AoA'] % (2*np.pi) #(2)!\n\nB = 5\nd_thetas = np.linspace(-np.pi/B, np.pi/B, 200)\narr_aoas = df_prox_1_shifted[\"AoA\"].to_numpy()\nQs = []\noptimal_Q, optimal_bin_edges, optimal_d_theta = np.inf, None, None\nfor d_theta in d_thetas: #(3)!\n    Q, bin_edges = calculate_Q(arr_aoas, d_theta, B)\n    if Q &lt; optimal_Q:\n        optimal_Q = Q*1\n        optimal_bin_edges = bin_edges\n        optimal_d_theta = d_theta*1\n    Qs.append(Q)\n</code></pre> <ol> <li>We create a copy of our original DataFrame. In Line 2, we shift the AoAs by blade 1's mean AoA value as calculated in the previous section. </li> <li> <p>We've highlighted Line 3 because it is important. Our artificially constructed <code>df_prox_1_shifted</code> DataFrame from Line 2 will contain some <code>AoA</code> values that are negative. </p> <p>In practice our BTT system will always produce positive AoAs. These artificially shifted values should therefore appear at the end of the next revolution. To simulate this effect, we wrap the AoAs to the range \\([0, 2 \\pi]\\) in Line 3.</p> </li> <li> <p>From Line 5 onward, we repeat the same process as before to find the optimal bin edges. The only difference is we use the <code>df_prox_1_shifted</code> DataFrame instead of the <code>df_prox_1</code> DataFrame.</p> </li> </ol> <p>We print the optimal \\(Q\\) value below.</p> <pre><code>&gt;&gt;&gt; print(optimal_Q)\n&gt;&gt;&gt; print(optimal_bin_edges)\ninf\nNone\n</code></pre> <p>The optimal \\(Q\\) is infinity and the optimal edges equals <code>None</code>  !</p> <p>We plot a histogram of the AoAs in Figure 7 below to investigate what went wrong.</p> Reset Zoom Figure 7:      A histogram of our artificially shifted AoAs. We see that the first blade appears both at the start and end of the revolution.    <p>This is what happens when a blade arrives at the proximity probe at approximately the same time that the OPR triggers a zero-crossing time. Some of the AoAs will appear at the end of the previous revolution, and some will appear at the beginning of the current revolution.</p> <p>The algorithm we've developed will fail for such cases, because some values fall before or after the far left and right edges.</p> <p>We should change <code>calculate_Q</code> to handle blade wrap-around.</p> <p>I'll leave it to you to make this change as an exercise \ud83d\udc47.</p> <p> Currently, <code>calculate_Q</code> returns <code>nan</code> when some blades are outside the furthest bin edges. Blade wrap-around will always trigger this response.  Write an updated <code>calculate_Q</code> function that handles AoAs outside of the bin edges.</p> Reveal answer (Please try it yourself before revealing the solution) <pre><code>def calculate_Q(\n    arr_aoas : np.ndarray,\n    d_theta : float,\n    N : int\n) -&gt; Tuple[float, np.ndarray]:\n    bin_edges = np.linspace(0 + d_theta, 2*np.pi + d_theta, N + 1)\n    Q = 0\n    for b in range(N):\n        left_edge = bin_edges[b]\n        right_edge = bin_edges[b + 1]\n        bin_centre = (left_edge + right_edge)/2\n        bin_mask = (arr_aoas &gt; left_edge) &amp; (arr_aoas &lt;= right_edge)\n        Q += np.sum(\n            (\n                arr_aoas[bin_mask] \n                - bin_centre\n            )**2 \n        )\n    if np.sum(arr_aoas &lt; bin_edges[0]) &gt; 0:\n        left_edge_last = bin_edges[N-1]\n        right_edge_last = bin_edges[N]\n        bin_centre_last = (left_edge_last + right_edge_last)/2\n        bin_mask = arr_aoas &lt;= bin_edges[0]\n        Q += np.sum(\n            (\n                (2*np.pi - arr_aoas[bin_mask]) \n                - bin_centre_last\n            )**2 \n        )\n    if np.sum(arr_aoas &gt; bin_edges[-1]) &gt; 0:\n        left_edge_first = bin_edges[0]\n        right_edge_first = bin_edges[1]\n        bin_centre_first = (left_edge_first + right_edge_first)/2\n        bin_mask = arr_aoas &gt; bin_edges[-1]\n        Q += np.sum(\n            (\n                (arr_aoas[bin_mask] - 2*np.pi) \n                - bin_centre_first\n            )**2 \n        )\n    return Q, bin_edges\n</code></pre> <p>In <code>calculate_Q</code> above, we've added lines of code in the 'sanity check' sections to handle AoAs outside the bin edges.</p> <p>In lines 20 - 29, we check for AoAs occurring before the left most bin edge. These values are therefore treated as if they occur in the last bin.</p> <p>In lines 31 - 40, we check for AoAs occurring after the right most bin edge. These values are therefore treated as if they occur in the first bin.</p> <p> After you've completed the function above, create a new function performing everything this chapter covered automatically. Call the function <code>transform_prox_AoAs_to_blade_AoAs</code>. </p> <p>This function should receive the proximity probe AoA DataFrame and the number of blades on the rotor, and return a list of DataFrames, one for each blade. </p> Reveal answer (Please try it yourself before revealing the solution) <pre><code>def transform_prox_AoAs_to_blade_AoAs(\n    df_prox: pd.DataFrame,\n    B: int,\n    d_theta_increments: int = 200,\n) -&gt; List[pd.DataFrame]:\n    \"\"\"This function takes a DataFrame containing the AoAs of a proximity probe,\n    and returns a list of DataFrame, each containing the AoAs of a single blade.\n\n    Args:\n        df_prox (pd.DataFrame): The dataframe containing the AoAs\n            of the proximity probe.\n        B (int): The number of blades.\n        d_theta_increments (int, optional): The number of increments\n\n    Returns:\n        List[pd.DataFrame]: A list of dataframes, each containing the AoA\n        values of a single blade.\n    \"\"\"\n    d_thetas = np.linspace(-0.5 * np.pi / B, 1.5 * np.pi / B, d_theta_increments)\n    arr_aoas = df_prox[\"AoA\"].to_numpy()\n    Qs = []\n    optimal_Q, optimal_bin_edges, optimal_d_theta = np.inf, None, None\n    for d_theta in d_thetas:\n        Q, bin_edges = calculate_Q(arr_aoas, d_theta, B)\n        if Q &lt; optimal_Q:\n            optimal_Q = Q * 1\n            optimal_bin_edges = bin_edges\n            optimal_d_theta = d_theta * 1\n        Qs.append(Q)\n\n    blade_dfs = []\n    blade_median_AoAs = []\n    for b in range(B):\n        ix_bin = (df_prox[\"AoA\"] &gt; optimal_bin_edges[b]) &amp; (\n            df_prox[\"AoA\"] &lt;= optimal_bin_edges[b + 1]\n        )\n        if b == 0:\n            ix_bin = ix_bin | (df_prox[\"AoA\"] &gt; optimal_bin_edges[-1])\n            df_bin = (\n                df_prox.loc[ix_bin].copy().reset_index(drop=True).sort_values(\"ToA\")\n            )\n\n            ix_wrap = df_bin[\"AoA\"] &gt; optimal_bin_edges[-1]\n            df_bin.loc[ix_wrap, \"AoA\"] = df_bin.loc[ix_wrap, \"AoA\"] - 2 * np.pi\n        elif b == B - 1:\n            ix_bin = ix_bin | (df_prox[\"AoA\"] &lt;= optimal_bin_edges[0])\n            df_bin = (\n                df_prox.loc[ix_bin].copy().reset_index(drop=True).sort_values(\"ToA\")\n            )\n\n            ix_wrap = df_bin[\"AoA\"] &gt; optimal_bin_edges[-1]\n            df_bin.loc[ix_wrap, \"AoA\"] = 2 * np.pi - df_bin.loc[ix_wrap, \"AoA\"]\n        else:\n            df_bin = (\n                df_prox.loc[ix_bin].copy().reset_index(drop=True).sort_values(\"ToA\")\n            )\n        blade_dfs.append(df_bin)\n        blade_median_AoAs.append( df_bin[\"AoA\"].median()  )\n    blade_order = np.argsort(blade_median_AoAs)\n    return [blade_dfs[i] for i in blade_order]\n</code></pre> <p>We've decided to only search for the optimal <code>d_theta</code> value between \\(-\\frac{2\\pi}{B}\\) and 0. This is simply a matter of preference, because I want the first blade to occur as close as possible to 0 degrees. If you allow <code>d_theta</code> to be positive, it may result in the first blade being classified as the last blade. This is not a problem, but it is a matter of preference.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#conclusion","title":"Conclusion","text":"<p>Blade alignment is like parallel parking - it seems so simple, but you can make a proper mess of it if you're not careful.</p> <p>I've promised that, by the end of this tutorial, you'll be able to infer parameters for vibration frequency, amplitude and phase for every blade. In this chapter we've enabled the \"for every blade\" part. Before this chapter, we just had a massive array of AoAs with no structure to it. We now have one AoA DataFrame for every blade. </p> <p>This chapter involves only a single proximity probe. BTT systems normally use multiple proximity probes. </p> <p>In the next chapter, we'll combine information from multiple probes together. We'll also investigate a nice visual way to check if we've done our alignment properly: the stack plot.</p> <p>Outcomes</p> <p> Calculate the optimal <code>d_theta</code> to group the AoAs into blade bins by minimizing a quality factor \\(Q\\).</p> <p> Understand that the first blade may arrive close to the OPR zero-crossing time. This can make the blade appear either at the start or end of the revolution. We need to cater for this scenario.</p> <p> Write a function that determines the optimal blade bins for a set of AoAs, and split the proximity probe AoA DataFrames into several individual blade DataFrames.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch4/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to Justin Smith and Alex Brocco for reviewing this chapter and providing feedback.</p> <p> Dawie Diamond </p> <p>             2024-02-20         </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/","title":"5. Working with multiple probes","text":"You are here","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#combining-multiple-probes","title":"Combining multiple probes","text":"<p>We are almost halfway through the tutorial! If you can stick with it for this chapter, it should be downhill from here. If you're doing the tutorial for the first time and feel confused by some of the previous chapters, that's OK. I'm often confused myself. Just remember that the chapters will always be free and online. You can, and should, return to them at any time. The more time you spend on the fundamentals, the faster your research will progress later on.</p> <p>I've promised that, by the end of this tutorial, you'll be able to infer vibration frequency, amplitude, and phase for each individual blade. To achieve this, we need to combine all AoAs belonging to the same blade together. This means combining the AoAs of the same blade at different proximity probes. Much of this chapter's content can be referred to as data wrangling. Data wrangling is the term often used in Machine Learning (ML). We are not changing any AoAs. We are simply grabbing, slicing, and consolidating the data in order to simplify subsequent analyses.</p> <p>Why do we need new algorithms to combine data from different probes together? </p> <p>Because we don't know which blade arrived at each probe first. </p> <p>To illustrate this point, Figure 1 shows an animation of a 5 blade rotor. The rotor completes one revolution. Three proximity probes are located at different circumferential positions. Each time a blade passes a probe, we allocate the blade on the right hand side. This allows us to visualize the order in which the blades arrive at each probe. The blades have been marked with numbers 1 to 5.</p> <p> </p> Figure 1:     The first blade to arrive at each probe differ. The first blade to arrive at probe 1 is Blade 1. The first blade to arrive at probe 2 is Blade 5. The first blade to arrive at probe 3 is Blade 4. If we want to combine the AoAs from all the probes together, we must determine this order first.    <p>Figure 1 above demonstrates the first blade to arrive at each probe is different. The first blade to arrive at probe 1 is Blade 1. The first blade to arrive at probe 2 is Blade 5. The first blade to arrive at probe 3 is Blade 4.</p> <p>It may seem simple to determine this order, but if your rotor has many blades, it is nontrivial. </p> <p>A colorful example</p> <p>Let's use a colorful example to illustrate the problem.</p> <p>Suppose you're measuring the lap times of 5 marathon runners. Normally, you simply stand at the finish line and record the time each runner finishes. </p> <p>But our race is different. </p> <p>The runners do not start at the same location around the track. We can therefore not infer that the first runner to arrive at the finish line is the fastest. Each runner's starting position needs to be taken into account as well. </p> <p>Furthermore, we grab two friends and disperse ourselves to arbitrary positions around the track. No one is taking measurements at the finishing line, but rather at random locations. To infer how fast the runners are going, we need to communicate with one another, and take the relative distance between all timers into account. This chapter solves a similar problem for BTT.</p> <p>To collect all AoAs for the first blade, we have to \"grab\" the first AoA vector from probe 1, the second AoA vector from probe 2, and the third AoA vector from probe 3. To isolate the AoAs that belong to the second blade, we take the second AoA vector from probe 1, the third AoA vector from probe 2, and the fourth AoA vector from probe 3. This task is simple because the order in which the blades arrive is known for this example.</p> <p>Normally, the blade order is unknown. This chapter discusses how to determine this order. By the end of this chapter, we will have one DataFrame per blade. Each DataFrame consolidates the AoAs for a single blade across all the probes. </p> <p>We break this process into two steps. The two steps are explained with the help of Figure 2 below.</p> <p> </p> Figure 2:     An illustration of the two-step process followed in this chapter. In the first step, we pivot the AoA vectors from each probe into a matrix where each row of the matrix represents a shaft revolution, and each column represents a blade's arrival AoA at the probe.       In the second step, we combine the pivoted DataFrames together, and extract the columns that correspond to each blade. After step two, we have a DataFrame for each blade. Each DataFrame contains the AoAs for the blade in question across all the probes.    <p>In the first step, we pivot the AoA vectors from each probe into a matrix where each row of the matrix represents a shaft revolution, and each column represents a blade's arrival AoA at the probe. The illustrative example includes three sensors and five blades. After step 1, there are three matrices. Each matrix corresponds to a sensor. The matrix contains 5 columns, each one holding the AoAs for a different blade. </p> <p>Note that, at the end of step 1, we have not combined or considered the relationship between sensors yet. Step 2 deals with how to combine information from different sensors together. In step 2, we flex our data wrangling muscles to identify which columns in the pivoted matrices represent the same blade for each sensor. Those columns are combined together into a single DataFrame. We therefore have one DataFrame per blade, with as many columns as there are sensors.</p> <p>Outcomes</p> <p> Understand that we can pivot the AoAs arriving at one proximity probe in a column-wise manner. Each row of the resulting DataFrame contains the AoAs for each blade in a different column.</p> <p> Understand what the stack plot is, and how it can be used to confirm our blades are properly aligned.</p> <p> Write functions to convert the AoAs associated with individual proximity probes into consolidated rotor blade DataFrames containing all the ToAs and AoAs belonging to a blade.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#follow-along","title":"Follow along","text":"<p>The worksheet for this chapter can be downloaded here .</p> <p>You can open a Google Colab session of the worksheet here: .</p> <p>You need to use one of these Python versions to run the worksheet:  </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#step-1-pivot-the-aoa-vectors-for-each-probe","title":"Step 1: Pivot the AoA vectors for each probe","text":"Figure 3:     We now discuss step 1 of the two-step process. We pivot the AoA vectors from each probe into a matrix where each row of the matrix represents a shaft revolution, and each column represents a blade's AoAs at the probe.    <p>Figure 3 above shows the first step of the two-step process. We pivot the AoA vectors from each probe into a matrix where each row of the matrix represents a shaft revolution, and each column represents a blade's AoAs at the probe.</p> <p>We still only consider data from a single probe at a time</p> <p>We cannot stress enough that, in step 1, we still only consider data from one probe at a time. Information from different probes will be combined in step 2.</p> <p>We repeat what was achieved in the previous chapter in Figure 4 below. This clarifies the transformation required in Step 1.</p> <p> </p> Figure 4: Illustration of the algorithm developed in Chapter 3. We took the AoAs from one proximity probe, and cut it into 5 DataFrames. Each DataFrame corresponds to the AoAs for one blade. <p>In Figure 4 above, the AoAs from one proximity probe have been sliced into 5 DataFrames. Each DataFrame represents the vector of AoAs for one blade.</p> <p>Now, in step 1 of our process, we pivot those vector DataFrames into a matrix. The AoAs from different blades are located in different columns of the matrix. In other words, each row of our resulting DataFrame concatenates all the AoAs for each sensor. We want to perform the transformation illustrated in Figure 5 below.</p> <p> </p> Figure 5: An illustration of the column-wise pivot we perform. Each row of the ultimate DataFrame contains the AoAs for each blade in a different column.  <p>In Figure 5 above \ud83d\udc46, a function called <code>pivot_blade_AoAs_along_revolutions</code> transforms the list of DataFrames into one DataFrame. Each row contains the AoAs for each blade. We have not changed the information inside the DataFrame, merely rearranged it. </p> <p>Why do we do this? Simply because its easier to work with one DataFrame than with a list of DataFrames. There are other ways to perform the work discussed in this chapter. I believe this is the most intuitive way.</p> <p>The function to perform this transformation is given below. I have added code annotations to explain the steps in the function. You open them with the  symbols. If the comments  don't appear, refresh the page and try again.</p> <pre><code>def pivot_blade_AoAs_along_revolutions(\n    prox_AoA_dfs : List[pd.DataFrame] #(1)!\n) -&gt; pd.DataFrame:\n    df_blades_aligned = prox_AoA_dfs[0]#(2)!\n    df_blades_aligned = df_blades_aligned.rename(#(3)!\n        columns={\n            \"ToA\":\"ToA_1\", \n            \"AoA\":\"AoA_1\"\n        }\n    )\n    for i, df_blade in enumerate(prox_AoA_dfs[1:]):#(4)!\n        df_blades_aligned = df_blades_aligned.merge(#(5)!\n            df_blade[[\"n\", \"ToA\", \"AoA\"]].rename(\n                columns={\n                    \"ToA\":\"ToA_\"+str(i+2), \n                    \"AoA\":\"AoA_\"+str(i+2)}\n            ),\n            how=\"outer\",#(6)!\n            on=\"n\"#(7)!\n        )\n    return df_blades_aligned\n</code></pre> <ol> <li> <p>The <code>prox_AoA_dfs</code> is a list of DataFrames from one proximity probe where each element in the list represents the AoA values from one blade. This list is the output of the <code>transform_prox_AoAs_to_blade_AoAs</code> from the previous chapter.</p> <p>The <code>List</code> type hint is used to indicate <code>prox_AoA_dfs</code> is a list of DataFrames. You can import the <code>List</code> type hint from the <code>typing</code> module as such: </p> <p><code>from typing import List</code></p> </li> <li> <p>We take the first blade as our reference. We will align the other blades to the first blade's DataFrame.</p> </li> <li> <p>We rename the <code>ToA</code> and <code>AoA</code> columns to <code>ToA_1</code> and <code>AoA_1</code> respectively. The <code>1</code> indicates these values belong to the first blade.</p> </li> <li> <p>We loop over the rest of the blades. We merge each successive blade's DataFrame into the reference DataFrame.</p> </li> <li> <p>The Pandas <code>.merge</code> method joins two DataFrames on a common key. Here, we merge the reference DataFrame with the current blade's DataFrame.      We rename the <code>ToA</code> and <code>AoA</code> columns to <code>ToA_{i+2}</code> and <code>AoA_{i+2}</code> respectively. The <code>i+2</code> is used because the <code>i</code> counter starts at zero. The first DataFrame we merge into the reference must, however, be 2. Therefore, we add 2 to the <code>i</code> counter.</p> </li> <li> <p>We perform an <code>outer</code> join. This means we retain all rows from both DataFrames, even if no matching value for the <code>n</code> key is present in one of them. If, for instance, the <code>n</code> for revolution 50 is missing from the current blade's DataFrame, the <code>ToA_2</code> and <code>AoA_2</code> columns will be filled with <code>NaN</code> values.</p> </li> <li> <p>We join the DataFrames on the <code>n</code> key, <code>n</code> is the revolution number.</p> </li> </ol> <p>In the above code block, the first blade's DataFrame is used as the reference DataFrame. Why do we handle the first blade's vector outside of the loop, and the other blades' vectors inside the loop? Because we need a first DataFrame to merge the other DataFrames into. If we tried to process the first blade's AoAs inside the loop, our merge operation would fail, because there is no initial DataFrame to merge it into! The first blade's AoAs are therefore treated as a special case. The first blade's AoAs become the reference into which the other blades' AoAs are merged. </p> Is it not arbitrary to use blade 1 as the reference? <p>Yes it is. We could have selected any blade as our reference. They are all equally arbitrary. Given this fact, we may as well standardize on the first blade as the reference.</p> <p>Each subsequent blade's DataFrame is merged into this reference. This is a common operation in most tabular-data based applications. We expand the reference DataFrame by two columns with each merge.</p> <p>The top of the merged DataFrame is presented in Table 1 below.</p> Table 1: Each proximity probe's AoAs after pivoting in a column-wise manner.  n n_start_time n_end_time Omega ToA_1 AoA_1 ToA_2 AoA_2 ToA_3 AoA_3 ToA_4 AoA_4 ToA_5 AoA_5 0 0.0934028 0.363933 23.2255 0.136547 1.00205 0.190927 2.26504 0.245069 3.5225 0.298838 4.77132 0.352618 6.0204 1 0.363933 0.630815 23.5429 0.40623 0.995802 0.459719 2.25507 0.513109 3.51203 0.566314 4.76465 0.619614 6.01947 2 0.630815 0.894334 23.8435 0.672717 0.999073 0.725672 2.26171 0.778447 3.52004 0.830988 4.7728 0.883363 6.0216 3 0.894334 1.15268 24.3212 0.935346 0.99748 0.987122 2.25673 1.03872 3.51172 1.09019 4.76346 1.1418 6.01879 4 1.15268 1.40862 24.5488 1.19335 0.998545 1.24479 2.26135 1.29604 3.51946 1.34702 4.77088 1.39792 6.02033 Column explanation \ud83d\udc47 Column name Explanation n The revolution number in which the blade arrived at the probe. Revolution number 0 is the first revolution. n_start_time The zero-crossing time at which the revolution started. n_end_time The zero-crossing time at which the revolution ended. Omega The shaft speed within the revolution. In units of radians/second. ToA_1 The ToA of the first blade to arrive at the probe in revolution \\(n\\). AoA_1 The AoA corresponding to the first ToA in revolution \\(n\\) as determined in Ch3. ToA_2 The ToA of the second blade to arrive at the probe in revolution \\(n\\). AoA_2 The AoA corresponding to the second ToA in revolution \\(n\\) as determined in Ch3. ToA_3 The ToA of the third blade to arrive at the probe in revolution \\(n\\). AoA_3 The AoA corresponding to the third ToA in revolution \\(n\\) as determined in Ch3. ToA_4 The ToA of the fourth blade to arrive at the probe in revolution \\(n\\). AoA_4 The AoA corresponding to the fourth ToA in revolution \\(n\\) as determined in Ch3. ToA_5 The ToA of the fifth blade to arrive at the probe in revolution \\(n\\). AoA_5 The AoA corresponding to the fifth ToA in revolution \\(n\\) as determined in Ch3. <p>The table presents the ToA and AoA columns for each blade. Each row of the table contains the data for a revolution. This DataFrame is now ready for further analysis.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#the-stack-plot","title":"The stack plot","text":"<p>We now introduce the stack plot, a widely recognized tool in BTT. The stack plot visually represents the relative distance between adjacent  blades as they pass a proximity probe. A visual representation of what the stack plot represents is provided in Figure 6 below.</p> <p> </p> Figure 6: The stack plot for the illustrative rotor. The stack plot shows the circumferential distance between adjacent blades.  <p>Ideally, the circumferential distance between each set of adjacent blades would be the same. In reality, each rotor exhibits a unique pattern of blade spacing. We can use this unique pattern to assess whether our alignment has been done properly.</p> <p>In the example above, the consecutive distances between adjacent blades for the first shaft revolution is:</p> <pre><code>&gt;&gt;&gt; blade_dfs_recombined = []\n&gt;&gt;&gt; for prox_list_AoAs in blade_probes_dfs:\n    ... blade_dfs_recombined.append(\n    ...     pivot_blade_AoAs_along_revolutions(prox_list_AoAs)\n    ...)\n&gt;&gt;&gt; df = blade_dfs_recombined[0]\n&gt;&gt;&gt; blade_2_minus_1 = df.iloc[0][\"AoA_2\"] - df.iloc[0][\"AoA_1\"] #(1)!\n&gt;&gt;&gt; blade_3_minus_2 = df.iloc[0][\"AoA_3\"] - df.iloc[0][\"AoA_2\"]\n&gt;&gt;&gt; blade_4_minus_3 = df.iloc[0][\"AoA_4\"] - df.iloc[0][\"AoA_3\"]\n&gt;&gt;&gt; blade_5_minus_4 = df.iloc[0][\"AoA_5\"] - df.iloc[0][\"AoA_4\"]\n&gt;&gt;&gt; blade_1_minus_5 = 2*np.pi + df.iloc[1][\"AoA_1\"] - df.iloc[0][\"AoA_5\"]\n&gt;&gt;&gt; print(\"blade_2_minus_1:\", blade_2_minus_1, \"rad\")\n&gt;&gt;&gt; print(\"blade_3_minus_2:\", blade_3_minus_2, \"rad\")\n&gt;&gt;&gt; print(\"blade_4_minus_3:\", blade_4_minus_3, \"rad\")\n&gt;&gt;&gt; print(\"blade_5_minus_4:\", blade_5_minus_4, \"rad\")\n&gt;&gt;&gt; print(\"blade_1_minus_5:\", blade_1_minus_5, \"rad\")\n</code></pre> <ol> <li>The <code>iloc[0]</code> method is used to access the first row of the DataFrame. It returns a Pandas Series, and we can access the <code>AoA</code> columns with the <code>[]</code> operator.</li> </ol> <pre><code>blade_2_minus_1: 1.2629980304819501 rad\nblade_3_minus_2: 1.2574606040202596 rad\nblade_4_minus_3: 1.2488114790250116 rad\nblade_5_minus_4: 1.2490816162460137 rad\nblade_1_minus_5: 1.2585900251951907 rad\n</code></pre> <p>Stack plot calculations are intuitive: Blade 1's AoA in revolution <code>n</code> is subtracted from Blade 2's AoA in revolution <code>n</code>, Blade 2's AoA in revolution <code>n</code> is subtracted from Blade 3's AoA in revolution <code>n</code>, and so on. The only tricky calculation is the <code>blade_1_minus_5</code> calculation. Here, we subtract the AoA of the first blade from the <code>second</code> revolution (<code>n=1</code>) from the AoA of the last blade from the <code>first</code> revolution (<code>n=0</code>). Put another way: the blade to arrive after the last blade of the first revolution is the first blade in the second revolution.</p> <p>Here's a function called <code>create_stack_plot_df</code> to calculate the stack plot:</p> <pre><code>def create_stack_plot_df(df_blades_aligned : pd.DataFrame) -&gt; pd.DataFrame:\n    all_aoa_columns = sorted([#(1)!\n        i for i in df_blades_aligned.columns \n        if i.startswith(\"AoA_\")\n    ])\n    B = len(all_aoa_columns)#(2)!\n    stack_plot_diffs = {}#(3)!\n    stack_plot_diffs[\"n\"] = df_blades_aligned[\"n\"].to_numpy()#(4)!\n    for blade_no in range(B - 1):#(5)!\n        farther_blade_name = all_aoa_columns[blade_no + 1]#(6)!\n        closer_blade_name = all_aoa_columns[blade_no]#(7)!\n        arr_blade_diffs = (#(8)!\n            df_blades_aligned[farther_blade_name] \n            - df_blades_aligned[closer_blade_name]\n        ).to_numpy()\n\n        stack_plot_diffs[closer_blade_name] = arr_blade_diffs#(9)!\n    farther_blade_name = all_aoa_columns[0]#(10)!\n    closer_blade_name = all_aoa_columns[B - 1]\n    arr_blade_diffs = (\n        df_blades_aligned[farther_blade_name].to_numpy()[1:] + 2*np.pi#(11)! \n        - df_blades_aligned[closer_blade_name].to_numpy()[:-1]\n    )\n    arr_blade_diffs = np.append(arr_blade_diffs, [None])#(12)!\n    stack_plot_diffs[closer_blade_name] = arr_blade_diffs\n    return pd.DataFrame(stack_plot_diffs)#(13)!\n</code></pre> <ol> <li>To start, we collect all the columns with the prefix <code>AoA_</code>. This will return as many columns as there are blades.</li> <li>The number of blades, <code>B</code>, is calculated from the AoA column headings.</li> <li>We initialize a dictionary that will contain the stack plot values. We use a dictionary because it is easy to convert it to a Pandas DataFrame later on with the <code>pd.DataFrame</code> constructor.</li> <li>We add the revolution number to the DataFrame. This is the only column that is not a stack plot value. We don't use <code>n</code> in the stack plot, but it feels wrong to throw away the revolution number column .</li> <li>We iterate over all the blades except the last blade. We therefore use <code>range(B - 1)</code> instead of <code>range(B)</code>. Within this loop, we calculate the difference between adjacent blade pairs. We'll calculate the difference between the last and the first blade after the loop has executed.</li> <li>We get the column name of the blade to arrive second - i.e. after the first one.</li> <li>The name of the column that corresponds to the first blade.</li> <li>We calculate the difference between the two blades. We use the <code>.to_numpy()</code> method to convert the Pandas Series to a NumPy array. We do this to get rid of our <code>Pandas</code> index.</li> <li>We add the blade difference array to the dictionary.</li> <li>We now calculate the stack plot values between the last blade and the first blade. The farthest blade is the first blade and the closer blade is the last blade.</li> <li>Here we subtract the two from one another. Note there's a difference between the revolution numbers of the two arguments. The farthest blade starts at the second revolution, and the closer blade starts at the first revolution. Also note the <code>+ 2 * np.pi</code> addition. It wraps the AoAs from the first blade back to the previous revolution.</li> <li>We need to add one <code>None</code> value to the last blade's stack plot values because its dimension must match the other stack plot columns.</li> <li>We convert the dictionary that holds our values in a Pandas DataFrame and return it.</li> </ol> <p>We now can calculate the median of each column. We use the <code>.median</code> method:</p> <p><pre><code>stack_plot_dfs = []\nfor df in blade_dfs_recombined:\n    stack_plot_dfs.append(create_stack_plot_df(df))\nprint(stack_plot_dfs[0].median())\n</code></pre> <pre><code>n          1435.0\nAoA_1    1.257285\nAoA_2    1.257135\nAoA_3    1.254071\nAoA_4    1.257441\nAoA_5    1.257264\ndtype: object\n</code></pre> In the code above, we show the median stack plot values for each column in the stack plot DataFrame. The median value for <code>n</code> is meaningless here, and will not be plotted.</p> <p>Figure 7 below shows the median stack plot values for each blade. To help interpret the y-axis, recall the ideal distance between each blade is \\(\\frac{2 \\pi}{5} \\approx 1.256637\\).</p> Reset Zoom Figure 7:      The stack plot of the rotor for the first proximity probe. The stack plot shows the circumferential distance between adjacent blades. The stack plot value for each blade is close to, but not exactly, the ideal distance between the blades: 2 np.pi/5 = 1.256637.     <p>In Figure 7 above, the median difference between consecutive blades are all approximately equal to the ideal distance of \\(\\frac{2 \\pi}{5}=1.256637\\). The differences that do exist, however, are valuable, and can be considered a \"fingerprint\" for this rotor.</p> <p>We've now figured out how to determine the stack plot for one probe. The stack plot values for all the probes are displayed on top of one another in Figure 8 below. This is simply a formality. We expect the stack plot for each probe to be identical because the same blades arrive at each probe. We expect all the lines to lie neatly on top of one another.</p> Reset Zoom Figure 8:    The stack plot for the rotor at all the proximity probes. The stack plots for probes 2, 3 and 4 are different from the stack plot for probe number 1. This is because the first blade to arrive at probes 2, 3 and 4 is not the same blade as the first blade to arrive at probe 1.     <p>Oh no! </p> <p>The stack plots are clearly different. How can this be? How can the rotor suddenly change shape based on the probe? </p> <p>The rotor has not changed shape. </p> <p>The stack plot, as we've shown at the start of the chapter in Figure 1, is a function of which blade arrives first at each probe. The stack plot for probe 1 is different from the stack plot for probes 2, 3 and 4 because the first blade to arrive at probe 1 is not the same blade as the first blade to arrive at probes 2, 3 and 4.</p> Difference between arrival order of Figure 1 vs arrival order of Figure 8 <p>Please note the arrival order of the blades in Figure 1 is not the same as the arrival order in Figure 8. Figure 1's arrival order was chosen to vividly illustrate the fact that different blades arrive at different probes first. The arrival order in Figure 8 is the actual arrival order of the blades for our dataset.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#step-2-combine-the-pivoted-dataframes-from-different-probes","title":"Step 2: Combine the pivoted DataFrames from different probes","text":"Figure 9:     We now discuss step 2 of the two-step process. We combine the pivoted DataFrames from each probe. We then extract the columns corresponding to each blade. After step 2, we have one DataFrame for each blade. Each DataFrame contains the AoAs for said blade across all the probes.    <p>The first blade to arrive at probe number 1 and the first blade to arrive at probes 2, 3 and 4 is not the same blade. This causes the stack plot for probes 2, 3 and 4 to seem shifted. We can visually inspect the stack plot to determine how much the stack plot for probes 2, 3 and 4 is shifted.</p> <p>A nice way to visualize this is to plot the stack plot on a polar plot.</p> <p> </p> Figure 10:     In this animation, we shift the stack plot values for probes 2, 3 and 4 by 1 blade in the counterclockwise direction. After this shift, our stack plot lines match almost perfectly. We therefore conclude that the first blade to arrive at probe 1 arrives second at probes 2, 3 and 4.    <p>The first probe's stack plot is kept constant. Probe 2, 3, and 4's stack plots are shifted by \\(\\frac{360}{5} = 72\\) degrees counterclockwise. This is the same as shifting the stack plot by 1 blade. The stack plot for probes 2, 3 and 4 now matches the stack plot for probe 1. </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#rename-the-columns-for-global-alignment","title":"Rename the columns for global alignment","text":"<p>The simplest way to solve our apparent conundrum is to rename the columns from the probe 2, 3 and 4 stack plot DataFrames such that it results in a stack plot similar to the first probe.</p> <p>In our case, the below transformation must be performed.</p> <p><pre><code>                 Default order\n_____________________________________________    \n[\"AoA_1\", \"AoA_2\", \"AoA_3\", \"AoA_4\", \"AoA_5\"   ] # Start with each default order\n[\"AoA_1\"] + [\"AoA_2\", \"AoA_3\", \"AoA_4\", \"AoA_5\"] # Break the list into 2 lists\n[\"AoA_2\", \"AoA_3\", \"AoA_4\", \"AoA_5\"] + [\"AoA_1\"] # Switch the the lists around\n[\"AoA_2\", \"AoA_3\", \"AoA_4\", \"AoA_5\", \"AoA_1\"   ] # Add them again  \n_____________________________________________\n            Probe 2, 3 and 4 order               # \ud83d\udc48 This is the global blade order\n                                                 # for probes 2, 3, and 4\n</code></pre> A function that performs this is presented below.</p> <pre><code>def shift_AoA_column_headings(\n    aoa_column_headings : List[str], \n    shift_by : int\n) -&gt; List[str]:\n    if shift_by &gt;= len(aoa_column_headings):#(1)!\n        raise ValueError(\"shift_by must be less than the number blades in aoa_column_headings\")\n    return (#(2)!\n        list(aoa_column_headings)[shift_by:] \n        + list(aoa_column_headings)[:shift_by]\n    )\n</code></pre> <ol> <li>Before we perform the shift, we confirm the user is not trying to shift the column headings by more than the number of blades. This would not make sense!</li> <li>We separate our columns at the <code>shift_by</code> index and concatenate the two parts in reverse order. We wrap the <code>aoa_column_headings</code> with the <code>list</code> function. This is not strictly necessary if the user uses a Python list as the type for <code>aoa_column_headings</code>, but some people may want to pass <code>aoa_column_headings</code> as a Pandas series or a NumPy array. These constructs only implement the '+' to mean mathematical addition, not list concatenation.</li> </ol> <p>We demonstrate the shift function below:</p> <pre><code>&gt;&gt;&gt; probe_1_col_headings = [\"AoA_1\", \"AoA_2\", \"AoA_3\", \"AoA_4\", \"AoA_5\"]\n&gt;&gt;&gt; print(\"Shift by 0:\", shift_AoA_column_headings(probe_1_col_headings, 0))\n&gt;&gt;&gt; print(\"Shift by 1:\", shift_AoA_column_headings(probe_1_col_headings, 1))\n&gt;&gt;&gt; print(\"Shift by 2:\", shift_AoA_column_headings(probe_1_col_headings, 2))\n&gt;&gt;&gt; print(\"Shift by 3:\", shift_AoA_column_headings(probe_1_col_headings, 3))\n&gt;&gt;&gt; print(\"Shift by 4:\", shift_AoA_column_headings(probe_1_col_headings, 4))\n</code></pre> <p><pre><code>Shift by 0: ['AoA_1', 'AoA_2', 'AoA_3', 'AoA_4', 'AoA_5']\nShift by 1: ['AoA_2', 'AoA_3', 'AoA_4', 'AoA_5', 'AoA_1']\nShift by 2: ['AoA_3', 'AoA_4', 'AoA_5', 'AoA_1', 'AoA_2']\nShift by 3: ['AoA_4', 'AoA_5', 'AoA_1', 'AoA_2', 'AoA_3']\nShift by 4: ['AoA_5', 'AoA_1', 'AoA_2', 'AoA_3', 'AoA_4']\n</code></pre> Wonderful. We can now determine the column name mapping that would align the blades from probes 2, 3, and 4 to the first probe.</p> How much should we shift the column headings? <p>Excellent, you've spotted a gap in my approach. Until now, we've been able to estimate the shift directly from the stack plot. This is not ideal. We're almost at the point where we write a function to estimate the shift. We'll do this in the next section.</p> <p>This function can be used to rename the columns:</p> <pre><code>def rename_df_columns_for_alignment(\n    df_to_align : pd.DataFrame,#(1)!\n    global_column_headings : List[str],#(2)!\n    shift_by : int#(3)!\n) -&gt; pd.DataFrame#(4)!\n    shifted_dataframe_columns = shift_AoA_column_headings(#(5)!\n        global_column_headings, \n        shift_by\n    )\n    column_headings_to_rename = {#(6)!\n        local_col : global_col\n        for local_col, global_col \n        in zip(\n            shifted_dataframe_columns,\n            global_column_headings\n        )\n    }\n    original_column_order = list(df_to_align.columns)#(7)!\n    df_to_align = df_to_align.rename(#(8)!\n        columns=column_headings_to_rename\n    )\n    return df_to_align[original_column_order]#(9)!\n</code></pre> <ol> <li>The DataFrame that we want to change.</li> <li>The column headings to which the columns in <code>df_to_align</code> should be mapped. This will normally be AoA or ToA column headings.</li> <li>The number of positions to shift the column headings by.</li> <li>We return a DataFrame with the exact same shape and column headings as <code>df_to_align</code>, but with the column headings renamed and re-ordered. Some columns in <code>df_to_align</code> should not be sorted or renamed, such as the revolution number <code>n</code>. We need to return these columns as is.</li> <li>We shift the column headings of the <code>global_column_headings</code> by <code>shift_by</code> positions.</li> <li>We create a dictionary that maps the column headings in <code>df_to_align</code> to the <code>global_column_headings</code>. The <code>zip</code> function allows us to iterate over the <code>shifted_dataframe_columns</code> and the <code>global_column_headings</code> together.</li> <li>We store the original column order of <code>df_to_align</code> in a variable. We will use this to re-order the columns in <code>df_to_align</code> in the return statement.</li> <li>We rename the columns in <code>df_to_align</code> with the <code>column_headings_to_rename</code> dictionary.</li> <li>We return the columns in <code>df_to_align</code> in the original order.</li> </ol> <p>The stack plots are now redrawn in Figure 11 below.</p> Reset Zoom Figure 11:    The stack plot for the rotor at all the proximity probes after the columns have been renamed. The stack plots align with one another.    <p>Perfect  !</p> <p>Our stack plots for all probes lie on top of one another. We can therefore conclude our alignment is correct. Small differences between the median stack plot values for the different probes are observed. We attribute the differences to random noise and manufacturing tolerances in the axial and radial positions of the probes. Each probe therefore reacts slightly differently to the presence of the blades.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#calculate-the-shift-based-on-probe-spacing","title":"Calculate the shift based on probe spacing","text":"<p>We've successfully shifted the stack plot DataFrames to align them all with the first probe. We estimated the amount to shift through visual inspection of the stack plot. This estimation is simple if the rotor only has 5 blades. </p> <p>Normally, however, you cannot eyeball this shift for a rotor with more blades. We therefore need to estimate the shift based on the installed spacing between the probes. </p> <p>The engineering drawing for the probe holder used in the current dataset reveals the spacing between the probes in Figure 12 below.</p> <p> </p> Figure 12:    The figure shows the engineering drawing for the component holding the probes for this chapter's dataset. The circumferential distance between adjacent probes is 9.67 * 2 = 19.34 degrees.  Equidistant vs non-equidistant spacing <p>How would our method differ between equidistant and non-equidistant probe sets? Nothing. The present method works for any probe-spacing.</p> <p>From Figure 12 above, the holes for the probes were manufactured to be 19.34 degrees from one another. </p> <p>In reality, because of manufacturing tolerances, the manufactured spacing will be slightly different. Even if you could manufacture it perfectly, the probes themselves may still not \"respond\" perfectly similar. This would lead to AoAs that do not correspond to the centerline of the intended probe locations.</p> <p>We therefore need to assume the probes are not perfectly spaced. We therefore need an algorithm to determine when each blade arrives at each probe.</p> <p>We follow a two step process to achieve this:</p> <ol> <li> <p>Predict the likely AoA of a blade at a subsequent probe based on: </p> <ol> <li> <p>the AoA of the blade at the current probe and;</p> </li> <li> <p>the spacing between the two probes.</p> </li> </ol> </li> <li> <p>Determine which AoA value in the subsequent probe's DataFrame is closest to the predicted AoA value.</p> </li> </ol> <p>Here's a function that performs the first step:</p> <pre><code>def predict_probe_offset(\n        df_probe_AoAs : pd.DataFrame,#(1)!\n        starting_aoa : float,#(2)!\n        prox_probe_relative_distance : float,#(3)!\n    ) -&gt; int:#(4)!\n    predicted_blade_position = (\n        starting_aoa \n        + prox_probe_relative_distance#(5)!\n    ) % (2*np.pi)#(6)!\n    all_aoa_columns = sorted([\n        i for i in df_probe_AoAs.columns \n        if i.startswith(\"AoA_\")\n    ])#(7)!\n    current_probe_median_AoAs = df_probe_AoAs[all_aoa_columns].median()#(8)!\n    err_aoa = np.abs(current_probe_median_AoAs - predicted_blade_position)#(9)!\n    offset = np.argmin(err_aoa)#(10)!\n    return offset\n</code></pre> <ol> <li>The DataFrame that contains the AoAs for the probe for which you want to determine the offset. This DataFrame is the result of the <code>pivot_blade_AoAs_along_revolutions</code> function.</li> <li>Our initial AoA. This will always be the median AoA of the first blade to arrive at probe 1.</li> <li>The relative distance between the probe responsible for measuring the values in <code>df_probe_AoAs</code> and the probe from which <code>starting_aoa</code> was obtained. The distance must be provided in radians.</li> <li>The function returns the offset required for the AoA columns in <code>df_probe_AoAs</code> to align it to the blade from <code>starting_aoa</code>.</li> <li>We add the relative distance between the probes to the initial AoA. This gives us the predicted AoA of the blade at the later probe.</li> <li>We wrap the predicted AoA value to the range \\([0, 2 \\pi)\\). This is to cater for cases where a blade arrives at <code>starting_aoa</code> in the next revolution.</li> <li>We get all the AoA column headings from <code>df_probe_AoAs</code>.</li> <li>We calculate the median AoA for each blade at the current probe.</li> <li>We calculate the absolute error between the predicted AoA and the median AoA for each blade.</li> <li>The <code>np.argmin</code> returns the index of the smallest entry in an array. In this case, the smallest value in <code>err_aoa</code> will correspond to the blade that arrives closest to <code>predicted_blade_position</code>.</li> </ol> <p>We can use the function above to check our previous assumption: the offset for probes 2, 3, and 4 must be 1.</p> <pre><code>&gt;&gt;&gt; probe_1_blade_1_AoA = blade_dfs_recombined[0][\"AoA_1\"].median()#(1)!\n&gt;&gt;&gt; probe_spacings = np.deg2rad(np.array([0, 19.34, 19.34*2, 19.34*3]))#(2)!\n&gt;&gt;&gt; for i, (df_probe_AoAs, probe_spacing) in enumerate(#(3)!\n            zip(blade_dfs_recombined, probe_spacings)#(4)!\n        ):\n        probe_offset = predict_probe_offset(#(5)!\n            df_probe_AoAs,\n            probe_1_blade_1_AoA,\n            probe_spacing\n        )\n        print(f\"Probe {i + 1 }:\", probe_offset)#(6)!\n</code></pre> <ol> <li>We calculate the median AoA of the first blade to arrive at probe 1. We consider it our first probe's AoA.</li> <li>We calculate the relative distance between the probes. We use the <code>np.deg2rad</code> function to convert the degrees to radians.</li> <li>We iterate over the DataFrames for each probe. The <code>enumerate</code> function returns the index of the current iteration, <code>i</code>, and the current probe AoA DataFrame and probe spacing.</li> <li>We use the <code>zip</code> function to iterate over the DataFrames and the probe spacings together. This is a common pattern in Python.</li> <li>We use the <code>predict_probe_offset</code> function to determine the offset for the current probe. We use the median AoA of the first blade arriving at probe 1 as the initial AoA.</li> <li>We print the offset for the current probe.</li> </ol> <pre><code>Probe 1: 0\nProbe 2: 1\nProbe 3: 1\nProbe 4: 1\n</code></pre> <p>The optimal offset for probes 2, 3 and 4 is indeed 1. We have also calculated the optimal offset for probe 1. This is simply a sanity check, and should always return 0.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#assemble-global-blade-dataframes","title":"Assemble global blade DataFrames","text":"<p>We now finally assemble one dataframe for each blade. The dataframes will contain the AoAs for each blade across all the probes.</p> <p>A function that constructs <code>B</code> DataFrames from each of the pivoted proximity probe DataFrames is presented below. </p> <pre><code>def assemble_rotor_AoA_dfs(\n    prox_aligned_dfs : List[pd.DataFrame], \n    probe_spacing : List[float]\n) -&gt; List[pd.DataFrame]:\n    all_aoa_columns = sorted([#(1)!\n        i for i in prox_aligned_dfs[0].columns \n        if i.startswith(\"AoA_\")\n    ])\n    all_toa_columns = sorted([#(2)!\n        i for i in prox_aligned_dfs[0].columns \n        if i.startswith(\"ToA_\")\n    ])\n    remaining_columns = [#(3)!\n        i for i in prox_aligned_dfs[0].columns \n        if not i.startswith(\"ToA_\") and not i.startswith(\"AoA_\")\n    ]\n    B = len(all_aoa_columns)#(4)!\n    P = len(prox_aligned_dfs)#(5)!\n    if P  - 1 != len(probe_spacing):#(6)!\n        raise ValueError(\n            \"The number of proximity probes must be \"\n            \"one less than the number of probe spacings\"\n        )\n    rotor_blade_dfs = []#(7)!\n    for b in range(1, B+1):#(8)!\n        columns_to_copy = (\n            remaining_columns \n            + [f\"ToA_{b}\", f\"AoA_{b}\"]\n        )#(9)!\n        rename_dict = {\n            f\"ToA_{b}\" : \"ToA_p1\",\n            f\"AoA_{b}\" : \"AoA_p1\"\n        }#(10)!\n        rotor_blade_dfs.append(#(11)!\n            prox_aligned_dfs[0][columns_to_copy]\n            .copy(deep=True)\n            .rename(\n                columns=rename_dict\n            )\n        )\n    blade_1_probe_1_median = rotor_blade_dfs[0][\"AoA_p1\"].median()#(12)!\n    for iter_count, (df_probe_AoA, probe_offset) in enumerate(\n            zip(prox_aligned_dfs[1:], probe_spacing)#(13)!\n        ):\n        probe_no = iter_count + 2#(14)!\n        probe_offset = predict_probe_offset(#(15)!\n            df_probe_AoA,\n            blade_1_probe_1_median,\n            probe_offset\n        )\n        df_probe_AoAs_aligned = rename_df_columns_for_alignment(#(16)!\n            df_probe_AoA,\n            all_aoa_columns,\n            probe_offset\n        )\n        df_probe_AoAs_aligned = rename_df_columns_for_alignment(#(17)!\n            df_probe_AoAs_aligned,\n            all_toa_columns,\n            probe_offset\n        )\n        for b in range(1, B+1):\n            columns_to_merge = [\"n\", f\"ToA_{b}\", f\"AoA_{b}\"]\n            rename_dict = {\n                f\"ToA_{b}\" : f\"ToA_p{probe_no}\",\n                f\"AoA_{b}\" : f\"AoA_p{probe_no}\"\n            }\n            rotor_blade_dfs[b - 1] = rotor_blade_dfs[b - 1].merge(#(18)!\n                df_probe_AoAs_aligned[columns_to_merge].rename(\n                    columns=rename_dict\n                ),\n                how=\"outer\",\n                on=\"n\"\n            )\n    return rotor_blade_dfs\n</code></pre> <ol> <li>We get all the AoA column headings from the first DataFrame in <code>prox_aligned_dfs</code>. We use the first DataFrame because all the DataFrames in <code>prox_aligned_dfs</code> have the same column headings.</li> <li>Similar to the above line, we get the ToA column names.</li> <li>We get all the column headings that are not AoA or ToA headings, such as <code>n</code>, <code>n_start_time</code>, <code>n_end_time</code>, and <code>Omega</code>.</li> <li>We determine the number of blades in the rotor.</li> <li>We determine the number of proximity probes.</li> <li>This is a sanity check to ensure we've provided the correct number of probe spacings.</li> <li>We initialize an empty list that will contain the rotor blade DataFrames.</li> <li>The purpose of this loop is to get the AoA and ToA values from the first probe. This is the start of each rotor blade's AoA DataFrame and will be grown to include the other proximity probe values in the next loop.</li> <li>We determine the column headings needed to copy from the first probe's DataFrame. We need to copy a) all the columns that are not AoA or ToA columns, and b) the AoA and ToA columns for only the current blade.</li> <li>We construct the dictionary to be used with Pandas' <code>.rename</code> function to rename the AoA and ToA column headings.</li> <li>We copy the columns from the first probe's DataFrame and rename the AoA and ToA columns for the current blade to <code>AoA_p1</code> and <code>ToA_p1</code> respectively. We append the DataFrame to the <code>rotor_blade_dfs</code> list.</li> <li>We determine the median AoA of the first blade at the first probe. We will use this value to predict the AoA of the first blade at the other probes.</li> <li>We loop over the rest of the probes and their probe spacings. Note the probe spacings are all relative to the first probe.</li> <li>We determine the probe number. This is simply the iterator value plus 2, since the first probe is probe 1. We create this variable for renaming purposes.</li> <li>We calculate the offset for the current probe. We use the <code>predict_probe_offset</code> function we wrote earlier.</li> <li>We rename the AoA columns in <code>df_probe_AoAs</code> to align them with the first probe. We use the <code>rename_df_columns_for_alignment</code> function we wrote earlier.</li> <li>Now we rename ToA columns in <code>df_probe_AoAs</code>.</li> <li>We merge our aligned probe's AoA DataFrame, <code>df_probe_AoAs_aligned</code>, with the current blade's DataFrame. We use the <code>merge</code> function to do this. We use the <code>outer</code> merge type to ensure we do not lose any data. We merge on the revolution number <code>n</code>.</li> </ol> <p>We can use this function to get a list of rotor blade DataFrames:</p> <pre><code>&gt;&gt;&gt; prox_relative_distances = np.cumsum(#(1)!\n    np.deg2rad(#(2)!\n            np.array([9.67*2, 9.67*2, 9.67*2])#(3)!\n        )\n    )\n&gt;&gt;&gt; rotor_AoA_dfs = assemble_rotor_AoA_dfs(\n    prox_aligned_dfs=blade_dfs_recombined,\n    probe_spacing=prox_relative_distances\n)\n</code></pre> <ol> <li>We use the <code>np.cumsum</code> function to calculate the cumulative spacing between each probe and the first probe. This is because we specify our probe spacings in its increments between subsequent probes, not in absolute terms. </li> <li>We convert the probe spacings to radians. We use this function instead of multiplication with <code>np.pi</code>/180 . This makes it exceedingly unlikely we'll make a mistake with this conversion.</li> <li>We specify the probe spacings between adjacent probes from Figure 6.</li> </ol> <p>The first three rows in the rotor blade AoA DataFrame is shown in Table 2 below.</p> Table 2: The rotor blade AoA DataFrame's head.   n n_start_time n_end_time Omega ToA_p1 AoA_p1 ToA_p2 AoA_p2 ToA_p3 AoA_p3 ToA_p4 AoA_p4 0 0.0934028 0.363933 23.2255 0.136547 1.00205 0.180378 2.02003 0.180378 2.02003 0.180378 2.02003 1 0.363933 0.630815 23.5429 0.40623 0.995802 0.449329 2.01047 0.449329 2.01047 0.449329 2.01047 2 0.630815 0.894334 23.8435 0.672717 0.999073 0.715402 2.01683 0.715402 2.01683 0.715402 2.01683 <p>From Table 2 above, four AoA columns and four ToA columns are displayed, one for each probe. We can also identify the probe by its subscript <code>p</code>. This DataFrame shares similarities with the DataFrame shown in Table 1. </p> <p>To get a better perspective on what we've done, we present, in Table 3 below, the last rotor blade's AoA DataFrame.</p> Table 3: The last rotor blade's AoA DataFrame  n n_start_time n_end_time Omega ToA_p1 AoA_p1 ToA_p2 AoA_p2 ToA_p3 AoA_p3 ToA_p4 AoA_p4 0 0.0934028 0.363933 23.2255 0.352618 6.0204 0.125942 0.75574 0.125942 0.75574 0.125942 0.75574 1 0.363933 0.630815 23.5429 0.619614 6.01947 0.395832 0.750988 0.395832 0.750988 0.395832 0.750988 2 0.630815 0.894334 23.8435 0.883363 6.0216 0.662427 0.753728 0.662427 0.753728 0.662427 0.753728 <p>Note that <code>ToA_p1</code> in the first row occurs after the other ToAs in the same row. The first probe, therefore, that observes blade 5 in every revolution is probe number 2, and the last probe to observe it is probe number 1.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#conclusion","title":"Conclusion","text":"<p>We've done a lot of work in this chapter that yielded one DataFrame per blade. The steps involved are numerous and may be confusing. Rest assured, it gets easier with practice. The first coding exercise \ud83d\udc47 below will challenge you to combine everything we've done until now in a single function to get the rotor blade DataFrames.</p> <p>We've now reached the peak of the difficulty mountain of BTT. From here, we can start doing the \"cool\" stuff. The stuff most published work is about. </p> <p>We can start doing vibration analysis.</p> <p>Outcomes</p> <p> Understand that we can pivot the AoAs arriving at one proximity probe in a column-wise manner. Each row of the resulting DataFrame contains the AoAs for each blade in a different column.</p> <p> Understand what the stack plot is, and how it can be used to confirm our blades are properly aligned.</p> <p> Write functions to convert the AoAs associated with individual proximity probes into consolidated rotor blade DataFrames containing all the ToAs and AoAs belonging to a blade.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to Justin Smith and Alex Brocco for reviewing this chapter and providing feedback.</p> <p> Dawie Diamond </p> <p>             2024-02-28         </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#coding-exercises","title":"Coding exercises","text":"","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#1-one-function-to-rule-them-all","title":"1. One function to rule them all","text":"<p>We've done a lot of work in chapters 3, 4 and 5. Its now time to combine them into one function that receives raw time stamps, and returns rotor blade AoA DataFrames.</p> <p> Write a function called <code>get_rotor_blade_AoAs</code> that receives the these three inputs:</p> <ol> <li>A DataFrame that contains the opr zero-crossing times.</li> <li>A list of ToAs from each proximity probe.</li> <li>A list of probe spacings between each proximity probe and the first proximity probe.</li> </ol> <p>and returns a list of rotor blade DataFrames. I recommend you leverage the functions we've written in this chapter.</p> Reveal answer (Please try it yourself before revealing the solution) <pre><code>def get_rotor_blade_AoAs(\n    df_opr_zero_crossings : pd.DataFrame,\n    prox_probe_toas : List[pd.DataFrame],\n    probe_spacings : List[float],\n    B : int\n) -&gt; List[pd.DataFrame]:\n    \"\"\"This function converts the raw time stamps, both the OPR zero-crossing\n    times and he proximity probe ToAs, and returns a DataFrame for each \n    blade containing the ToA and AoA values for each blade over all the\n    proximity probes.\n\n    Args:\n        df_opr_zero_crossings (pd.DataFrame): A DataFrame containing the\n            OPR zero-crossing times in its first column.\n        prox_probe_toas (List[pd.DataFrame]): A list of DataFrames\n            where each DataFrame contains the ToAs of a single\n            blade from a proximity probe.\n        probe_spacings (List[float]): The relative spacing between\n            the first probe and every other probe. There  one\n            less value in this list than in prox_probe_toas.\n        B (int): The number of blades.\n\n    Returns:\n        List[pd.DataFrame]: A list of DataFrames where each DataFrame\n            contains the ToAs and AoAs of a single blade over all\n            the proximity probes.\n    \"\"\"\n    blade_dfs_recombined = []\n\n    for df_prox_toas in prox_probe_toas:\n        df_prox = transform_ToAs_to_AoAs(\n            df_opr_zero_crossings, \n            df_prox_toas, \n        )\n\n        blade_dfs_recombined.append(\n            pivot_blade_AoAs_along_revolutions(\n                transform_prox_AoAs_to_blade_AoAs(\n                    df_prox, \n                    B\n                )\n            )\n        )\n\n    rotor_AoA_dfs = assemble_rotor_AoA_dfs(\n        prox_aligned_dfs=blade_dfs_recombined,\n        probe_spacing=probe_spacings\n    )\n    return rotor_AoA_dfs\n</code></pre> <p>Usage example:</p> <pre><code>&gt;&gt;&gt; ds = Datasets[\"data/intro_to_btt/intro_to_btt_ch05\"]\n&gt;&gt;&gt; df_opr_zero_crossings = ds['table/opr_zero_crossings']\n&gt;&gt;&gt; df_prox_1 = ds['table/prox_1_toas']\n&gt;&gt;&gt; df_prox_2 = ds['table/prox_2_toas']\n&gt;&gt;&gt; df_prox_3 = ds['table/prox_3_toas']\n&gt;&gt;&gt; df_prox_4 = ds['table/prox_4_toas']\n\n&gt;&gt;&gt; rotor_blade_AoA_dfs = get_rotor_blade_AoAs(\n        df_opr_zero_crossings,\n        [df_prox_1, df_prox_2, df_prox_3, df_prox_4],\n        np.cumsum(np.deg2rad(np.array([19.34, 19.34, 19.34]))),\n        5\n    )\n</code></pre>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch5/#2-predict-the-probe-spacings","title":"2. Predict the probe spacings","text":"<p>It can happen that you receive a set of BTT timestamps, but the exact probe spacing is unknown. This can happen when you are handed an old dataset. It can also happen because you're not 100% sure that the manufactured probe spacing is correct.</p> <p> Write a function that calculates the probe spacing by comparing the stack plot between two probes. </p> Reveal answer (Please try it yourself before revealing the solution) <p> BOO. </p> <p>I'll leave you to it. I actually think this could make a journal publication. If you're stuck, you can reach me at dawie.diamond@bladesight.com.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/","title":"6. Data Zeroing and Filtering","text":"You are here","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#tip-deflections-zeroing-and-filtering","title":"Tip Deflections Zeroing and Filtering","text":"<p>At the end of the last chapter, we managed to combine data from multiple proximity sensors. We arrived at a place where we had one DataFrame containing the AoAs for a single blade. We are now more than halfway through our journey. In order to reach our promised goal of inferring blade vibration characteristics, we now convert these AoAs into tip deflections. The process entails: </p> <ol> <li>Zeroing the AoAs to remove the static part of the signal.</li> <li>Scaling the AoAs by the rotor's radius, thereby yielding the tip deflection in units of microns.</li> <li>Filtering the tip deflections to remove high frequency noise.</li> </ol> <p>In this chapter, we explore multiple techniques to perform this transformation. You may ultimately use only one approach. Rest assured you'll find some application for the other ones in future, even if its unrelated to BTT.</p> <p> </p> Figure 1:     An animation showing the effect of applying a Butterworth filter to normalized tip deflections.     <p>Outcomes</p> <p> Understand that AoAs are offset by a constant value. This offset is unrelated to the blade's vibration. </p> <p> Understand that the normalized AoAs can be multiplied by the rotor radius to obtain tip deflections.</p> <p> Understand that the tip deflection signal may contain non-vibration related components that are proportional to the shaft speed.</p> <p> Understand that a low pass filter can be used to smooth the tip deflections. </p> <p> Understand that the peak-to-peak vibration can be used to identify resonance events.</p> <p> Write a single function that zeroes, scales and filters the rotor blade AoAs.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#following-along","title":"Following along","text":"<p>The worksheet for this chapter can be downloaded here .</p> <p>You can open a Google Colab session of the worksheet here: .</p> <p>You need to use one of these Python versions:  </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#zeroing-the-aoas","title":"Zeroing the AoAs","text":"<p>Let's load a new dataset into memory. The dataset was acquired from the same rotor as used in the previous chapters. The dataset has measurements from three eddy current probes for a run-up and run-down of the rotor:</p> <pre><code>from bladesight import Datasets\n\nds = Datasets[\"data/intro_to_btt/intro_to_btt_ch06\"]\ndf_opr_zero_crossings = ds['table/opr_zero_crossings']\ndf_prox_1 = ds['table/prox_1_toas']\ndf_prox_2 = ds['table/prox_2_toas']\ndf_prox_3 = ds['table/prox_3_toas']\n</code></pre> <p>I've included the functions we've created in the previous chapter into the <code>bladesight</code> module. Specifically, the <code>get_rotor_blade_AoAs</code> function from the previous chapter's coding exercises have been added to the <code>btt</code> module. It can now be used as a single entrypoint to convert the OPR zero-crossing times and the proximity probe ToAs into rotor blade AoA DataFrames.</p> <pre><code>from bladesight.btt import get_rotor_blade_AoAs\nfrom typing import List#(1)!\nblade_AoAs : List[pd.DataFrame] = get_rotor_blade_AoAs(\n    df_opr_zero_crossings, \n    [\n        df_prox_1, \n        df_prox_2, \n        df_prox_3\n    ],\n    probe_spacings=np.deg2rad([10,20]),\n    B=5\n)\n</code></pre> <ol> <li> <p>We import the list annotation. The <code>get_rotor_blade_AoAs</code> function returns a list of DataFrames. Each DataFrame contains the AoAs for a single blade. </p> <p>Why did I not return one big DataFrame instead? Because we want to analyze each blade individually. We may want to compare the vibration of different blades. It's easier to achieve if the DataFrames are separate.</p> </li> </ol> <p>In the code above we've stipulated that probe 2 is 10 degrees from probe 1. Probe 3 is 20 degrees from probe 1. We also stipulate there are 5 blades. The function returns a list of DataFrames, one for each blade. The top of the first DataFrame is shown in Table 1 below:</p> Table 1: The first 5 rows of rotor blade 1's AoA DataFrame.  n n_start_time n_end_time Omega ToA_p1 AoA_p1 ToA_p2 AoA_p2 ToA_p3 AoA_p3 0 0.202061 0.460325 24.3286 0.205687 0.0882288 0.212988 0.265845 0.220066 0.438032 1 0.460325 0.716163 24.5592 0.463899 0.087785 0.471097 0.264557 0.478046 0.435233 2 0.716163 0.967917 24.9576 0.719673 0.0876073 0.726748 0.264189 0.733604 0.435293 3 0.967917 1.21753 25.1716 0.971393 0.0874948 0.978406 0.26402 0.98519 0.434798 4 1.21753 1.46356 25.5385 1.22097 0.0877474 1.2279 0.264713 1.23458 0.435487 <p>The AoAs for each probe are plotted against the revolution number in Figure 2 below.</p> Reset Zoom Figure 2: The AoAs for the first blade. Each probe's AoAs are offset by a constant value. We say the AoAs are not zeroed. The shaft speed is also indicated on a second y-axis. <p>In Figure 2 above, there are three seemingly horizontal lines that represent the AoAs for the blade at probes one, two and three respectively. Each line has a constant AoA offset. This constant is the average distance traveled by the shaft from the start of each revolution until the blade reaches the probe. </p> <p>This constant offset is unrelated to the deflection of the blade. We therefore say the values in Figure 2 are not zeroed. We need to remove the static part of the signal before we can proceed with the analysis.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#normalization-and-scaling","title":"Normalization and scaling","text":"<p>One of the simplest ways to remove the static part of the signal is to subtract the mean of the AoA column from each AoA value. We can use the code below to achieve this.</p> <pre><code>df[\"AoA_norm_p1\"] = df[f\"AoA_p1\"].mean() - df[f\"AoA_p1\"] \ndf[\"AoA_norm_p2\"] = df[f\"AoA_p2\"].mean() - df[f\"AoA_p2\"]\ndf[\"AoA_norm_p3\"] = df[f\"AoA_p3\"].mean() - df[f\"AoA_p3\"]\n</code></pre> <p>The normalized AoA column can now be scaled with the rotor radius to calculate the tip deflection. </p> <p>Recall that the distance traveled along an arc is given by the formula:</p> \\[\\begin{equation} x = R \\cdot \\theta \\end{equation}\\] <p>The code below shows how to do this:</p> <pre><code>R = 162000\ndf[\"x_p1\"] = R * df[\"AoA_norm_p1\"]\ndf[\"x_p2\"] = R * df[\"AoA_norm_p2\"]\ndf[\"x_p3\"] = R * df[\"AoA_norm_p3\"]\n</code></pre> <p>The engineering drawing for the blisk used in these measurements is presented in Figure 3 below.</p> <p> </p> Figure 3:     An engineering drawing of the blisk used in these measurements. The blisk's diameter is 324 mm. The radius is therefore 162 mm.    <p>The rotor's radius is 162mm, or 162000 \\(\\mu\\)m. I like to express tip deflection in microns. This is a personal preference. </p> <p>The resulting tip deflections are presented in Figure 4 below.</p> Reset Zoom Figure 4: The normalized tip deflections for the first blade. There are distinct areas where the blade vibration suddenly change, as indicated by callout A. This is a typical example of a resonance event. We've also added, as indicated by callout B, dotted lines that serve as \"breakpoints\" for our detrending algorithm (we're going to discuss detrending next). The shaft speed is indicated on a second y-axis.     <p>In Figure 4 above, the tip deflections no longer have a constant offset. All the tip deflection values are between +-1000 \u00b5m. The tip deflections change suddenly at multiple locations. Whether the change in tip deflection is positive or negative depends on the probe's location and the vibration frequency and phase.</p> <p>One such location is indicated by callout A. We refer to these events as resonance events. Drag across the plot to zoom into the resonance event. Each probe's tip deflections have different shapes at the resonance. This is counter-intuitive, because the blade's vibrational state can surely not change much within a single shaft revolution. This behavior is because of aliasing. But we're getting ahead of ourselves. We'll discuss aliasing in the next chapter. For now, you just need to understand that the tip deflections measured at different probes have different shapes, and that there exists a perfectly sensible explanation for this.</p> <p>Are the tip deflections safe?</p> <p>The tip deflections in Figure 4 above are within the safe limits for this particular blade. You need to perform a FEA to determine the safe limits for your blade.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#piecewise-linear-detrending","title":"Piecewise linear detrending","text":"<p>We have done well to remove the static offset from each probe's signal. Unfortunately, some static effects that have nothing to do with tip deflection are still present in the signal. </p> <p>From Figure 4 it seems as though the tip deflections change proportionally to the shaft speed. It is unlikely this change is related to tip deflection. Shaft speed related shifts can occur for many reasons. In this case, the proportional change in tip deflection is due to the fact that the eddy current probes used here have a limited bandwidth. The amplitude of the pulses (as discussed in Chapter 2) therefore become smaller as the shaft speed increases. This causes the ToAs to be triggered later. This later triggering manifests itself as apparent tip deflection changes.</p> <p>Let's remove this proportional change with a detrending algorithm.</p> <p>A detrending algorithm is a simple algorithm that removes a static trend from a signal. The Python library <code>scipy</code> has a built-in detrending algorithm.</p> <pre><code>from scipy.signal import detrend\n</code></pre> <p>This function fits and subtracts a linear curve from the signal. A linear curve, though, is not what we need. In Figure 4 above, there are multiple regions with different linear trends. This is especially true the moment the shaft speed reverses around revolution 1436. Linear trend changes are observed in other regions as well.</p> <p>Fortunately, the detrending algorithm allows us to specify breakpoints where the linear trend changes. From Figure 4 above, I've eyeballed the breakpoints between linear sections at shaft revolutions 217, 1128, 1436, 1784, and 2670. The breakpoints are indicated by the dotted lines in Figure 4 above (one breakpoint is indicated by callout B). </p> <p>The detrending algorithm can be applied for all three probes with the code below:</p> <pre><code>bps = np.array([217, 1128, 1436, 1784, 2670])\ndf[f\"x_p1\"] = detrend(\n    df[\"x_p1\"],\n    bp=bps\n)\ndf[f\"x_p2\"] = detrend(\n    df[\"x_p2\"],\n    bp=bps\n)\ndf[f\"x_p3\"] = detrend(\n    df[\"x_p3\"],\n    bp=bps\n)\n</code></pre> <p>The detrended tip deflections are shown in Figure 5 below.</p> Reset Zoom Figure 5: The detrended tip deflections for the first blade. The tip deflections are now centered around zero for the duration of the measurement.    <p>Thats much better ! The tip deflections from each probe are now centered around zero. We can now trust that the tip deflection variations are caused by blade vibration.</p> <p>This approach gives us great control over the zeroing process. It would, however, be better to automatically remove these trends.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#order-domain-polynomial-detrending","title":"Order domain polynomial detrending","text":"<p>We can gain some intuition about removing shaft speed related effects with a scatterplot of tip deflection vs shaft speed. The scatterplot is presented in Figure 6 below.</p> Reset Zoom Figure 6: The tip deflections have been plotted vs shaft speed for each probe. The tip deflections seem to decrease proportionally as shaft speed increases. We can fit a high order polynomial to each signal. This polynomial can be subtracted from the tip deflections to remove shaft speed related effects.    <p>From Figure 6 above, the tip deflections for probes 2 and 3 seem to decrease, on average, as the shaft speed increases. Probe 1's tip deflections exhibit a smaller correlation. The resonance events within these signals seem to be short lived as a function of shaft speed. </p> <p>This allows us to fit a high-order polynomial to the tip deflections vs shaft speed. The polynomial represents the shaft speed related effects in the tip deflections. By subtracting the evaluated polynomial from each signal, we end up with a signal that only contains the tip's dynamic vibration.</p> <p>The polynomial can be fit with the code below:</p> <pre><code>df[\"x_p1\"] = R * df[\"AoA_norm_p1\"]\ndf[\"x_p2\"] = R * df[\"AoA_norm_p2\"]\ndf[\"x_p3\"] = R * df[\"AoA_norm_p3\"]\n\npoly_order = 11 #(1)!\np1 = np.polyfit(df['Omega'], df['x_p1'], poly_order)\np2 = np.polyfit(df['Omega'], df['x_p2'], poly_order)\np3 = np.polyfit(df['Omega'], df['x_p3'], poly_order)\n\ndf[\"x_p1\"] = df[\"x_p1\"] - np.polyval(p1, df['Omega'])\ndf[\"x_p2\"] = df[\"x_p2\"] - np.polyval(p2, df['Omega'])\ndf[\"x_p3\"] = df[\"x_p3\"] - np.polyval(p3, df['Omega'])\n</code></pre> <ol> <li>Here, I've selected a polynomial order of 11. This was the first value I tried. You may need to experiment with different polynomial orders to find the best one for your case. Maybe you could write an algorithm that automatically determines this polynomial order. If you do, please let me know .</li> </ol> <p>The detrended tip deflections are presented in Figure 7 below.</p> Reset Zoom Figure 7: The detrended tip deflections for the first blade after zeroing with an order domain polynomial. The tip deflections are now centered around zero for the duration of the measurement.    <p>Great ! We've managed to remove the static, non-vibration related part of the signal. We can now move on to the next step of the analysis, filtering.</p> <p>Poorly conditioned polynomial fit</p> <p>When you use polynomial detrending, you may receive a <code>Polyfit may be poorly conditioned</code> warning. This happens for one of three reasons:</p> <ol> <li>The polynomial order is too high. You can reduce the polynomial order to remove the warning.</li> <li>The shaft speed is constant. This means there is no shaft speed variety to fit against. You should choose an order of 0 or 1 for constant speed cases.</li> <li>Your data is wrong. If the data passed to the algorithm is spurious or incorrect, the algorithm will still attempt to fit a polynomial to it. This will result in a poorly conditioned fit. You should check your data for errors.</li> </ol> <p>Tip</p> <p>Zeroing can be achieved in many different ways. I've presented you with one simple method to get you going. It is, however, a discipline on its own. Maybe you can come up with different ways of zeroing the signal. If you do, please let me know .</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#filtering","title":"Filtering","text":"<p>We've now removed the static part of the signal. We have, essentially, implemented a high-pass filter on our signals. We still have high frequency noise in our signals. We can remove this noise with a low-pass filter. </p> <p>Once again, the <code>scipy</code> package in Python comes to the rescue. There are multiple filters in the <code>scipy.signal</code> module. We demonstrate two methods here:</p> <ol> <li>A Butterworth filter.</li> <li>A Gaussian filter.</li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#butterworth-filter","title":"Butterworth filter","text":"<p>A Butterworth filter is a low-pass filter. It is often implemented in analogue systems, but we can implement it digitally with the <code>scipy.signal.butter</code> function. The code below shows how to implement a Butterworth filter.</p> <pre><code>from scipy.signal import butter, filtfilt\n\nbutterworth_filter = butter(N=2, Wn=0.3) #(1)!\n\ndf[\"x_p1_filt_butter\"] = filtfilt(*butterworth_filter, df[\"x_p1\"]) #(2)!\ndf[\"x_p2_filt_butter\"] = filtfilt(*butterworth_filter, df[\"x_p2\"])\ndf[\"x_p3_filt_butter\"] = filtfilt(*butterworth_filter, df[\"x_p3\"])\n</code></pre> <ol> <li>The <code>butter</code> function is responsible for designing the filter. The order parameter, <code>N</code>, and the cutoff frequency <code>Wn</code>, can be adjusted. Each different combination of the two results in a different frequency response. I will not discuss filter design in this tutorial. Primarily because I am not an expert in filter design. The important parameter here is the cutoff frequency <code>Wn</code>. The larger this value, the more high frequency components will be permitted to stay. In our case, the faster our resonances occur, the higher we want this cutoff. I think 0.3 is a good initial value to use.</li> <li>The <code>filtfilt</code> function applies the filter. The first argument is the filter coefficients, and the second argument is the signal to filter. The <code>filtfilt</code> function is a forward-backward filter. This means it applies the filter twice, once forward, and once backward. This is done to remove phase shifts caused by the filter. The result is a filtered signal, but it has the same phase as the original signal.</li> </ol> <p>The butterworth filter is simple to implement. It works well for most cases.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#gaussian-filter","title":"Gaussian filter","text":"<p>A Gaussian filter is a low-pass filter often used in image processing. It is implemented below:</p> <pre><code>from scipy.ndimage import gaussian_filter1d\n\ndf[\"x_p1_filt_gaussian\"] = gaussian_filter1d(df[\"x_p1\"], 1) #(1)!\ndf[\"x_p2_filt_gaussian\"] = gaussian_filter1d(df[\"x_p2\"], 1)\ndf[\"x_p3_filt_gaussian\"] = gaussian_filter1d(df[\"x_p3\"], 1)\n</code></pre> <ol> <li>The <code>gaussian_filter1d</code> takes as its first argument the signal to filter, and as its second argument the standard deviation of the Gaussian filter. The larger the standard deviation, the smoother the signal will be. A standard deviation of 1 means the Gaussian kernel has a standard deviation of 1 shaft revolution. You need to experiment with different values to determine what works best for your case.</li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#filter-comparison","title":"Filter comparison","text":"<p>We show the effects of both filters in Figure 8 below.</p> Reset Zoom Figure 8: The filtered tip deflections for the first blade arriving at the first probe. By zooming into the signal, it becomes clear that both the Butterworth and Gaussian filters have a similar effect. The Gaussian filter leaves slightly more noise in the signal, but it is not significant. Both leave the signal significantly smoother than the raw signal.    <p>From Figure 8 above, the Gaussian filter and the Butterworth filter performs well. The Gaussian filter leaves a bit more high frequency noise. That should not bother us.</p> When would which method perform better? <p>To be honest, I have no idea. I've used both filters in the past, and I've never noticed a significant difference between the two. I've used the Butterworth filter more often, because in my experience, the people who use Butterworth filters have moustaches. Engineers with moustaches built the modern world.</p> <p>Tip</p> <p>It is not mandatory to remove the noise in the signal for frequency analysis. Some algorithms, such as the ones we'll cover in subsequent chapters, work better with the noise removed. There are, however, algorithms that are robust against noise. It is therefore a good idea to keep the raw signal around for later analysis if need be.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#peak-to-peak-vibration","title":"Peak-to-Peak vibration","text":"<p>A well established concept in vibration analysis is the peak-to-peak vibration. It is simply the difference between the maximum and minimum values of a signal within a certain timeframe. The peak-to-peak vibration gives us a nice tool to combine the tip deflections from each probe into a single value. </p> <p>The peak-to-peak vibration for each blade is the difference between the minimum value and the maximum value inside each revolution. </p> <p>We can achieve this with the code below:</p> <pre><code>x_matrix = (\n    df[[\"x_p1_filt_butter\", \"x_p2_filt_butter\", \"x_p3_filt_butter\"]]\n    .to_numpy()\n)\ndf[\"pk-pk\"] = x_matrix.max(axis=1) - x_matrix.min(axis=1)\n</code></pre> <p>The peak-to-peak vibration for the first blade is presented in Figure 9 below.</p> Reset Zoom Figure 9: The peak-to-peak vibration for the first blade. We now have a single indicator that represents the vibration from all the proximity probes for a blade. It is much easier to identify resonance zones with this indicator than with multiple probe signals.    <p>In Figure 9 above, the peak-to-peak vibration is an indicator that represents the maximum range between the tip deflections within every revolution. It is simpler to identify resonance events with this signal than with multiple probe signals.</p> <p>In most of our plots, we've also included the shaft speed on a secondary y-axis. You may have noticed there is a symmetry to the resonances in Figure 9 above. This symmetry occurs because we measured on a run-up and run-down, and the vibration is synchronous. We'll delve into synchronous vibration in the next chapter. For now, you only have to understand a blade will experience resonance at a particular shaft speed. Whether we traverse this shaft speed on the run-up or run-down is irrelevant. </p> <p>We can use this concept with a scatterplot of the peak-to-peak values vs the shaft speed in Figure 10 below.</p> Reset Zoom Figure 10: The peak-to-peak vibration for the first blade vs shaft speed. This makes it easier to identify resonances. We've marked resonances with arrows (as indicated in callout A) at 572, 622, 672, 934, 1078, and 1248 RPM.    <p>The order domain scatterplot, shown in Figure 10 above, beautifully reveal resonance events. These events occur on both the run-up and the run-down. We've indicated the resonance events with arrows in Figure 10 above. </p> <p>Tip</p> <p>Please note the peak-to-peak vibration is not the same as the vibration amplitude. It is a quick and dirty way to visually spot resonances with the aliased tip deflections. It is not a replacement for a proper frequency inference.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#conclusion","title":"Conclusion","text":"<p>In this chapter, we converted raw AoAs to tip deflections. The tip deflection values represent the dynamic vibration of the blade. All the static components have been removed. We've also used the peak-to-peak vibration to identify resonance events.</p> <p>In the next chapter, we will delve into the concept of synchronous vibration and sampling.</p> <p>Outcomes</p> <p> Understand that AoAs are offset by a constant value. This offset is unrelated to the blade's vibration. </p> <p> Understand that the normalized AoAs can be multiplied by the rotor radius to obtain tip deflections.</p> <p> Understand that the tip deflection signal may contain non-vibration related components that are proportional to the shaft speed.</p> <p> Understand that a low pass filter can be used to smooth the tip deflections. </p> <p> Understand that the peak-to-peak vibration can be used to identify resonance events.</p> <p> Write a single function that zeroes, scales and filters the rotor blade AoAs.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to Justin Smith and Alex Brocco for reviewing this chapter and providing feedback.</p> <p> Dawie Diamond </p> <p>             2024-03-05         </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#coding-exercises","title":"Coding exercises","text":"","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch6/#1-aoa-to-tip-deflection-algorithm","title":"1. AoA to Tip Deflection algorithm","text":"<p>We've performed several steps in this chapter to zero and filter a signal. We want to combine these steps into a single function that scales, zeroes and filters a signal.</p> <p> Write a function called <code>get_blade_tip_deflections_from_AoAs</code>, accepting these arguments:</p> <ol> <li>A DataFrame that contains the raw AoA values of a rotor blade. This is a DataFrame from the output of the <code>get_rotor_blade_AoAs</code> function.</li> <li>A polynomial order to use for detrending.</li> <li>A cutoff frequency to use for the butterworth filter.</li> </ol> <p>and returns a new DataFrame with the zeroed and filtered tip deflections. Also include the peak-to-peak vibration levels.</p> Reveal answer (Please try it yourself before revealing the solution) <pre><code>def get_blade_tip_deflections_from_AoAs(\n    df_rotor_blade_AoAs : pd.DataFrame,\n    blade_radius : float,\n    poly_order : int = 11,\n    filter_order : int = 2,\n    filter_cutoff : float = 0.3\n) -&gt; pd.DataFrame:\n    \"\"\"This function performs the following operations:\n        1. Normalizes the AoAs of each probe.\n        2. Scales the AoAs to tip deflections.\n        3. Detrends the tip deflections with a polynomial fit.\n        4. Filters the tip deflections with a Butterworth filter.\n        5. Calculates the peak-to-peak tip deflection.\n\n    Args:\n        df_rotor_blade_AoAs (pd.DataFrame): The DataFrame containing the \n            AoAs of each probe. This is an item from the list \n            returned by the function `get_rotor_blade_AoAs`.\n        blade_radius (float): The radius of the blade in microns.\n        poly_order (int, optional): The polynomial order to use for the detrending\n            algorithm . Defaults to 11.\n        filter_order (int, optional): The order of the butterworth filter. Defaults to 2.\n        filter_cutoff (float, optional): The butterworth filter cutoff \n            frequency. Defaults to 0.3.\n\n    Returns:\n        pd.DataFrame: The DataFrame containing the detrended and filtered tip deflections.\n            This dataframe also contains the peak-to-peak tip deflection.\n    \"\"\"\n    df = df_rotor_blade_AoAs.copy(deep=True)\n    all_aoa_columns = [\n        col_name \n        for col_name \n        in df.columns \n        if col_name.startswith(\"AoA_p\")\n    ]\n    butterworth_filter = butter(N=filter_order, Wn=filter_cutoff)\n    for col in all_aoa_columns:\n        df[col + \"_norm\"] = df[col].mean() - df[col]\n        deflection_col_name = col.replace(\"AoA\", \"x\")\n        df[deflection_col_name] = blade_radius * df[col + \"_norm\"]\n        poly = np.polyfit(df['Omega'], df[deflection_col_name], poly_order)\n        df[deflection_col_name] = (\n            df[deflection_col_name] \n            - np.polyval(poly, df['Omega'])\n        )\n        df[deflection_col_name + '_filt'] = filtfilt(\n            *butterworth_filter,\n            df[deflection_col_name]\n        )\n    x_matrix = df[[col for col in df.columns if col.endswith(\"_filt\")]].to_numpy()\n    df[\"pk-pk\"] = x_matrix.max(axis=1) - x_matrix.min(axis=1)\n    return df\n</code></pre> <p>Usage example:</p> <pre><code>&gt;&gt;&gt; df_filtered = get_blade_tip_deflections_from_AoAs(\n    df,\n    R=162000,\n    poly_order=10\n)\n</code></pre>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/","title":"7. Synchronous Vibration and Sampling","text":"You are here","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#synchronous-vibration-and-sampling","title":"Synchronous Vibration and Sampling","text":"<p>The previous chapters presented new signal processing steps along our journey to infer blade vibration, frequency, and phase from raw timestamps. In this chapter, we slow down a bit. </p> <p>Blades do not simply vibrate for no reason. Something causes it. </p> <p>In this chapter, we discuss why blades are vibrating instead of how to process the signals. This chapter will help us understand what the results mean.</p> <p>We delve into the fundamentals of Single Degree of Freedom (SDoF) vibration. Most graduate students would have already encountered SDoF vibration in their studies. We, however, explain it through the lens of BTT. Hopefully, spending time on the fundamentals through a different lens will help you understand the subject better.</p> <p>Outcomes</p> <p> Understand how obstructions in the flow path causes synchronous vibration.</p> <p> Understand that synchronous vibration occurs at an integer multiple of the shaft speed. This integer multiple is called the Engine Order (EO). </p> <p> Understand what a Campbell diagram is and how we can use it to guess the mode associated with a resonance event we measured.</p> <p> Understand that we can use a Single Degree of Freedom (SDoF) oscillator to model a blade's vibration.</p> <p> Understand how BTT systems sample the blade's vibration waveform.</p> <p> Understand why synchronous vibration data is more difficult to process than asynchronous vibration data.</p> <p> Understand that BTT signals are generally aliased.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#two-kinds-of-vibration","title":"Two kinds of vibration","text":"<p>This chapter focuses on a kind of vibration called synchronous vibration. We will, however, briefly categorize the two kinds of vibration here.</p> <p>Here's a high-level overview of the two kinds of vibration:</p> <ol> <li> <p>Obstruction-driven vibration, or synchronous vibration.</p> </li> <li> <p>Fluid-structure interaction-driven, or asynchronous vibration.</p> </li> </ol> <p>Figure 1 below illustrates the respective driving mechanisms of two kinds of vibration.</p> <p> </p> Figure 1: The two kinds of driving mechanisms causing blade vibration. In A) the flow path is obstructed by struts, causing synchronous vibration. In B) the blade is vibrating in response to the fluid, and the fluid's pressure is oscillating because of the blade's vibration.    <p>In Figure 1 A) there are 5 struts in the flow path upstream from the rotor. The struts obstruct the fluid, causing pressure fluctuations downstream. These pressure fluctuations occur once per revolution for each obstruction. This statement is so important, I've put it in a box \ud83d\udc47.</p> <p>Obstruction-driven fluctuations cause synchronous vibration</p> <p>The pressure fluctuations caused by obstructions occur once per revolution for each obstruction. If there are 5 obstructions, the pressure fluctuations occur 5 times per revolution. It is not possible to have 4.5 pressure fluctuations per revolution, just like you cannot have 2.4 children. </p> <p>This kind of vibration is therefore called \"synchronous vibration\", because it occurs at an integer multiple of the shaft speed. This integer multiple is called the Engine Order (EO).</p> <p>In Figure 1 B) a blade's airfoil is shown as the fluid passes. On one of the fluid lines, I've added a conceptual spring and damper. It is supposed to convey the idea that the blade is vibrating because of the fluid, and the fluid is vibrating because of the structure. These two systems feed off one another, and can result in significant vibration. This kind of vibration is called \"asynchronous vibration\", because it does not occur at an integer multiple of the shaft speed, it is dependant on the fluid and the blade's structural properties.</p> <p>Asynchronous vibration is not well understood... by me</p> <p>Please do not take my explanation above as authoritative. I am not an expert in fluid-structure interaction, Computational Fluid Dynamics (CFD), or flutter. BTT is concerned with measuring the vibrations, regardless of what caused them. </p> <p>I did request a review by a subject matter expert. The expert contributed that flutter could be caused by blade stall and shock interactions. It seems, however, as if the jury is still out on whether blade stall can cause flutter.  </p> <p>If you are an expert in this field and you would like to contribute to this tutorial, please get in touch.\ud83d\ude00</p> <p>PS. Obviously, I do not believe there is anything close to a linear relationship between the blade's vibration and the fluid's pressure.</p> <p>This chapter focuses on synchronous vibration because it is more difficult to measure than asynchronous vibration. We'll explain why this is the case later in the chapter.</p> <p>For now, let's focus on synchronous vibration.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#synchronous-vibration","title":"Synchronous vibration","text":"<p>Synchronous vibration is defined as vibration occurring at an integer multiple of the shaft speed. This integer multiple is called the Engine Order (EO). </p> <p>The relationship between the excitation frequency and the shaft speed is given below:</p> \\[ f = \\Omega \\cdot EO \\] Equation 1 Symbols Symbol Description \\(f\\) Excitation frequency experienced by a blade [rad/s] \\(\\Omega\\) Shaft speed [rad/s] \\(EO\\) Engine Order <p>The domains of the variables are:</p> \\[ \\begin{align} f &amp;\\gt 0 \\\\ \\Omega &amp; \\gt 0 \\\\ EO &amp; \\in [1,2,3...] \\\\ \\end{align} \\] <p>Synchronous vibration can therefore only take on a discrete set of values. If, for instance, the rotor speed is 3000 RPM (50 Hz), the possible excitation frequencies are:</p> Table 1 EO \\(f\\) [Hz] 1 50 2 100 3 150 4 200 5 250 ... ... <p>Asynchronous vibration occurs when there is a non-integer relationship between the shaft speed and the excitation frequency. We typically do not express asynchronous vibration as a non-integer EO, but would simply report the natural frequency without relation to the shaft speed. </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#at-which-frequency-are-blades-excited","title":"At which frequency are blades excited?","text":"<p>A popular textbook (Rao, 1991)<sup>1</sup> on rotor blade vibration offers one explanation. It is said that the main source of dangerous excitations are the stator vanes. Though the premise is sound, lets conduct a thought experiment to weigh the theory.</p> <p>The number of stator vanes multiplied by the shaft speed gives us the excitation frequency, also called the Nozzle Passing Frequency (NPF). The presence of stator vanes definitely cause obstruction-driven vibration, but does it actually cause damage? Damage can only accrue if a blade is responding at one of its natural frequencies.</p> Why can damage only occur when blades are in resonance? <p>In short, if a blade's design allows for fatigue damage to accumulate in normal operating conditions, I do not want to be in the room when that blade goes into resonance. It is a bad design. The engineers that design blades know what they are doing, and they design blades to be safe.</p> <p>Structures theoretically have an infinite number of natural frequencies. However, the first natural frequencies typically have the least damping associated with them, and the highest frequency response function (FRF) amplitudes. It is a generally accepted practice to disregard all modes except the first few when modal analysis is performed. The first few modes are therefore the most likely to cause damage.</p> <p>Let's consider a rotor with 80 blades, and half the amount of stator blades, 45. The rotor runs at 3000 RPM. The NPF is therefore:</p> \\[ NPF = \\frac{3000}{60} \\times 45 \\approx 2250 \\text{ Hz} \\] <p>Even though this is a thought experiment and we don't have real natural frequencies to compare the NPF to, 2250 Hz is a suspiciously high frequency to be among the first few modes. This is well above the typical range within which the lower natural frequencies of large blades occur. In my work, I'm interested in natural frequencies well below 2000 Hz. </p> <p>Note</p> <p>Blade natural frequencies are not usually made public by blade manufacturers. No doubt there are exceptions to the 2000 Hz cutoff used above. In my experience, however, this is a good rule of thumb. The first natural frequency of rotor blades generally occur far below 2250 Hz.</p> <p>What is the highest frequency you can measure with BTT?</p> <p>BTT signals are inherently aliased. You'll read about this later in the chapter. If you are designing an experimental setup and would like to calculate the positions for your probes, you can check out my paper about it (Diamond and Stephan Heyns, 2018)<sup>2</sup>. This space seems to have received attention recently. Here's a link to the Google Scholar page of citing articles to my paper: Google Scholar.</p> <p>The vibrations caused by the stator vanes are therefore not the culprit.</p> <p>How, then, does damaging vibration arise?</p> Do your own research <p>I have said here that Nozzle Passing Frequencies (NPF) are not the main culprits for blade vibration. This is my take on it, based on my experience and understanding of vibration.</p> <p>There are, however, papers and sources claiming the opposite. A recent example that claims NPF is - in fact - a key concern, is Chapter 7 of the book \"Forsthoffer's Proven Guidelines for Rotating Machinery Excellence\" (Forsthoffer, 2021)<sup>3</sup>. Another recent source does, however, share my sentiment that non NPF-related phenomena are the main culprits (Tanuma, 2022)<sup>4</sup>. </p> <p>The statements attributed to these books can be found here: Science Direct: Campbell Diagram.</p> <p>Please do your own research and come to your own conclusions. If you have a different take on this, please get in touch. I would love to include your take on this tutorial.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#a-simple-forcing-function","title":"A simple forcing function","text":"<p>The aerodynamic behavior inside a turbomachine is a complex discipline. We will not attempt to explain how specific aerodynamic flow patterns arise. Instead, we rather discuss why it does not take much to cause excitations at the lowest EOs.</p> <p>Let's suppose we have a turbomachine afflicted with a single discontinuity in the working fluid's flow path upstream of the blades. The discontinuity could be a supporting structural element, such as a strut. The discontinuity will cause a pressure fluctuation downstream of it. As the blades rotate, they pass through this pressure fluctuation once every revolution. This, in turn, causes a force to be exerted on the blade once every revolution.</p> <p>Let's model this forcing function as a unit impulse when the blade is in the path of the discontinuity, and zero otherwise. We'll assume the downstream effects of the discontinuity occur between \\(\\frac{2 \\pi}{10}\\) and \\(\\frac{3 \\pi}{10}\\) radians. The forcing function can be expressed as:</p> \\[ f(\\theta) = \\begin{cases} 1 &amp; \\text{if }  \\frac{2 \\pi}{10} \\lt \\theta \\leq \\frac{3 \\pi}{10} \\\\ 0 &amp; \\textrm{else} \\\\ \\end{cases} \\] <p>We plot the forcing function experienced by each blade over multiple shaft revolutions in Figure 2 below.</p> Reset Zoom Figure 2: The forcing function caused by an idealized discontinuity in the flow path. <p>The forcing function is clearly periodic. A brief force is experienced by each blade once per revolution.</p> <p>To understand which frequencies are excited by this forcing function, we plot the magnitudes of the first few positive Fourier coefficients in Figure 3 below:</p> Reset Zoom Figure 3:  The magnitudes of the first few positive Fourier coefficients of the forcing function.    <p>The frequency domain representation of the forcing function \ud83d\udc46 shows that, although the force occurs once per revolution, all EOs are excited by it.</p> <p>Why does the frequency domain look like this?</p> <p>When I first saw this result, it was completely counter intuitive. Why should a once per revolution disturbance excite all EOs? </p> <p>The answer is the forcing function is not a simple sinusoid. The fourier transform stipulates you can represent any time-domain signal as the sum of infinite sinusoidal terms. Our forcing function is therefore made up of an infinite number of sinusoids. It happens to be the case for periodic signals that each sinusoid at an integer multiple of the shaft speed is significant, and the other ones are not.</p> <p>I intended to derive this result analytically, but time caught me. If you can derive this result analytically, please get in touch. I would love to include your derivation here.</p> <p>Energy of the excitation and damping ratios</p> <p>The energy of the excitation diminishes as the EO increases. This is one reason why the first few EOs are the most likely to cause damage. Another reason is because higher modes usually have larger damping ratios. This means they are less likely to cause damage than the lower modes.</p> <p>This explains why a simple discontinuity in the flow path can excite the first few EOs of vibration. Obviously, the forcing function inside a turbomachine is not as simple as the one we've modeled above. But the principle remains the same. A non-sinusoidal periodic forcing function will excite some or all of the low EOs.</p> <p>Discontinuities can be anything</p> <p>We intuitively understand struts or stator vanes count as discontinuities. In fact, there are many possible discontinuities in a turbomachine. A nonconcentric casing might be a discontinuity. A noncircular inlet might introduce a discontinuity.</p> <p>I believe, given the breadth of possible obstructions, there will always be at least a single once per revolution excitation source in a turbomachine. </p> <p>This is an inkling I have, not a conclusion based on evidence. \ud83d\ude01</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#campbell-diagram","title":"Campbell diagram","text":"<p>Synchronous vibration can only occur when the excitation frequency coincides with a blade natural frequency. It is straightforward to calculate the shaft speed that will cause excitation at a natural frequency. We simply substitute the EOs we expect may occur into Equation 1 and solve for \\(\\Omega\\). </p> <p>If, for instance, a blade has a natural frequency of 120 Hz, we can calculate the shaft speeds at which the blade will be excited in Equation 2 below:</p> \\[ \\begin{align} \\Omega_{EO=2} &amp;= \\frac{120}{2} = 60 \\text{Hz or 3600 RPM }\\\\ \\Omega_{EO=3} &amp;= \\frac{120}{3} = 40 \\text{Hz or 2400 RPM }\\\\ \\Omega_{EO=4} &amp;= \\frac{120}{4} = 30 \\text{Hz or 1800 RPM }\\\\ \\dots &amp; \\end{align} \\] Equation 2 <p>Is it really so simple? Alas, the physics throws another curveball at us here. </p> <p>Rotating objects experience centrifugal force. The centrifugal force experienced by a rotor blade acts radially from the center of the shaft toward the tip of the blade.</p> <p>This force causes the stiffness of the blade to increase, a phenomenon known as centrifugal stiffening. Elevated stiffness leads to increased natural frequencies. The natural frequencies of the blades are therefore not constant, but generally increase as the rotor speeds up.</p> <p>We need to take this effect into account when we calculate the possible resonance shaft speeds. The Campbell diagram is a handy tool to visually solve the problem. A Campbell diagram contains the natural frequencies of the blades as a function of rotor speed. The excitation frequencies for each EO are also plotted. </p> <p>An illustrative Campbell diagram for a rotor blade's first three natural frequencies are displayed in Figure 4 below.</p> Reset Zoom Figure 4:  An illustrative Campbell diagram for a fictional rotor blade's first three natural frequencies.    <p>Figure 4 above illustrates the Campbell diagram's central concepts. The three mode lines indicate three natural frequencies as they change with rotor speed. The dotted lines indicate the excitation frequency associated with each EO of interest. You'll notice the EO lines are perfectly straight. This is because the EO is directly proportional to the rotor speed.</p> <p>Dark star-shaped markers on Figure 4 represent shaft speeds where one of the blade's natural frequencies coincide with an EO excitation frequency. Synchronous vibration can only occur at these discrete shaft speeds. We'll call these shaft speeds resonance speeds. </p> <p>FEM and Campbell diagrams</p> <p>The variation of natural frequencies with rotor speed is usually known from Finite Element Analysis (FEA) of the blades. It is almost inconceivable for a commercial rotor blade manufacturer to design a blade without also producing a Campbell diagram. </p> <p>In the rare case where you don't have access to one, you'll have to infer the natural frequencies algorithmically. Many methods have been proposed to do this. They are all outside the scope of this tutorial.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#a-simple-vibration-model","title":"A simple vibration model","text":"<p>The simplest, and often completely sufficient, way of expressing a rotor blade's vibration is to assume the blade is a damped single degree of freedom oscillator under harmonic excitation. The equation of motion for such a system is:</p> \\[ m \\ddot{x} + c \\dot{x} + k x = F_0 \\cdot \\cos(\\omega t)\\\\ \\] Equation 3 <p>Now we divide by \\(m\\). This yields a new equation of motion:</p> \\[ \\ddot{x} + 2 \\zeta \\omega_n \\dot{x} + \\omega_n^2 x = f_0 \\cdot \\cos(\\omega t) \\\\ \\] Equation 4 <p>where</p> \\[ \\omega_n = \\sqrt{\\frac{k}{m}} \\] Equation 5 <p>and </p> \\[ \\zeta = \\frac{c}{2 \\sqrt{k \\cdot m}} \\\\ \\] Equation 6 <p>and</p> \\[ f_0 = \\frac{F_0}{m} \\] Equation 7 Symbols Symbol Meaning SI Unit Domain \\(m\\) Mass of the single degree of freedom system kg \\(m \\gt 0\\) \\(c\\) Damping coefficient \\(\\frac{Ns}{m}\\) \\(c \\geq 0\\) \\(k\\) Stiffness \\(\\frac{N}{m}\\) \\(k \\gt 0\\) \\(F_0\\) Amplitude of the excitation force \\(N\\) \\(F_0 \\in \\mathbb{R}\\) \\(\\omega\\) Excitation frequency rad/s \\(\\omega \\gt 0\\) \\(x\\) Tip Displacement \\(m\\) \\(x \\in \\mathbb{R}\\) \\(\\zeta\\) Damping ratio \\(\\sqrt{\\frac{ N }{ m \\cdot kg } } s\\) \\(\\zeta \\geq 0\\) \\(\\omega_n\\) Natural frequency rad/s \\(\\omega_n \\gt 0\\) <p>This equation is a second order ordinary differential equation. A derivation of the solution can be found in Rao's (Rao, 2003)<sup>5</sup> excellent text book on mechanical vibrations (Chapter 3). </p> <p>The solution is: </p> \\[ x(t) = X(\\omega) \\cos (\\omega t - \\phi(\\omega)) \\] Equation 8 <p>where</p> \\[ \\frac{X(\\omega)}{\\delta_{\\text{st}}} = \\frac{1}{ \\sqrt{ (1 - r^2)^2 + (2 \\zeta r)^2 } }  \\] Equation 9 <p>and</p> \\[ \\phi(\\omega) = \\arctan \\left( \\frac{2 \\zeta r}{1 - r^2} \\right) \\] Equation 10 <p>and</p> \\[ r = \\frac{\\omega}{\\omega_n} \\] Equation 11 Symbols Symbol Meaning SI Unit Domain \\(\\delta_{\\text{st}}\\) Deflection under the static force \\(F_0\\) \\(m\\) \\(\\delta_{\\text{st}} \\in \\mathbb{R}\\) \\(r\\) Excitation frequency ratio - \\(r \\gt 0\\) <p>Each blade will have different values for \\(\\omega_n\\), \\(\\delta_{\\text{st}}\\), and \\(\\zeta\\). These values determine the vibration response of the blade. Intuition about the solution can be gained by fixing \\(\\omega_n=125\\) Hz and \\(\\delta_{\\text{st}} = 1\\). We can plot the solution for different values of \\(\\zeta\\) and \\(\\omega\\).</p> <p>Natural frequency unit</p> <p>Normally, the unit you use for natural frequency (Hz or rad/s) depends on where you want to use it. Here, however, the natural frequency gets absorbed into the excitation frequency ratio, \\(r\\). It therefore does not matter which unit you use here. We'll use Hz for convenience.</p> <p>The slider below \ud83d\udc47 allows you to change the value of \\(\\zeta\\). The resulting vibration amplitude and phase as a function of excitation frequency are plotted in Figure 4 below.</p> <p>Current \u03b6:  </p> A) B) Figure 5: The amplitude and phase of a single degree of freedom oscillator as a function of excitation frequency. We've fixed the natural frequency to 125 Hz and the static deflection to 1.    <p>Two observations from Figure 5 are highlighted below:</p> <ul> <li>Larger damping ratios lead to smaller amplitudes.</li> <li>The phase of the vibration always shifts by \\(\\pi\\) radians as the resonance is traversed. This is a fundamental law of vibration. The rate at which this shift occurs  is controlled by the damping ratio. The larger the damping ratio, the slower the phase shift.</li> </ul>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#sampling","title":"Sampling","text":"<p>We now have a mathematical expression that describes the shape of a blade tip's vibration response. Theoretically, we can use the expression to calculate the tip deflection at any point in time. However, we cannot measure the tip deflection at any point in time. We can only measure the tip deflection each time a blade passes a probe. </p> <p>In other words, despite the fact that the blade's vibration response is continuous, we only get one sample of the continuous waveform each time a blade passes a probe.</p> <p>To illustrate this concept, we've simulated the vibration response of a blade and artificially placed three proximity probes into a \"casing\". The slider below \ud83d\udc47 allows you to change the shaft speed, and observe both the continuous vibration response in Figure 6 A) and the samples taken by our BTT system in Figure 6 B).</p> <p>Current shaft speed:  RPM</p> A) B) Figure 6: A) A blade's continuous vibration response as a function of the blade's angular position. B) The samples taken by our BTT system as a function of shaft speed. The shaft speed can be controlled by the slider. If you're uncomfortable because we've expressed the continuous vibration vs angle instead of time, just keep reading.    Simulation parameters <ul> <li>\\(\\omega_n = 125\\)</li> <li>\\(\\delta_{\\text{st}}\\) = 1</li> <li>\\(\\Omega \\in [1150, 1350]\\) RPM</li> <li>\\(EO = 6\\) </li> <li>\\(\\zeta = 0.01\\)</li> <li>\\(\\text{Sensor locations} = [45, 145, 275]\\) deg</li> </ul> <p>In Figure 6 above, the continuous tip deflection is presented in A). We've also placed three proximity probes, prefixed by P, in the casing above the signal. Each proximity probe will sample the continuous waveform at the value corresponding to the vertical dotted line that stretches from the probe to the waveform. As you move the slider, you'll notice the continuous waveform changes in both amplitude and phase. You'll also notice the values sampled by each probe change.</p> <p>In Figure 6 B), the sampled values of the BTT system as a function of the entire shaft speed range are plotted. The instantaneous samples for the shaft speed as it is currently set is indicated by large markers on B. The corresponding samples are indicated on A) at the ends of the vertical dotted lines.</p> <p>We cannot stress the implication of this figure enough, we're therefore going to use a fancy box \ud83d\udc47 to highlight it.</p> <p>Continuous vs Sample signals</p> <p>We are not measuring the continuous signal shown in Figure 6 A) above. We only measure the sampled values for each probe as indicated in B).</p> <p>The task of BTT frequency inference is to infer the continuous waveform from the samples.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#substitute-angle-for-time","title":"Substitute angle for time","text":"<p>Back in Equation 4, we expressed the tip deflection as a function of time: \\(x(t)\\). In Figure 6, however, we plotted the tip deflection as a function of angle. Why the apparent conflict?</p> <p>This is because we can substitute time for angle in our equations.</p> <p>In reality the tip deflection does vary with time, but it is a faux dependance. To show why, the definition of synchronous vibration is repeated below:</p> \\[ \\omega = \\Omega \\cdot EO \\] Equation 12 <p>recall the shaft speed, \\(\\Omega\\), can be expressed as the distance traveled by the rotor from the start of a revolution until it reaches a sensor's position, \\(\\theta_s\\):</p> \\[ \\Omega = \\frac{\\theta_s}{t} \\] Equation 13 <p>We can substitute this into  Equation 12 above to get:</p> \\[ \\omega = \\frac{\\theta_s}{t} \\cdot EO \\] Equation 14 <p>Finally, we substitute the above equation into Equation 8 to get:</p> <p></p> \\[\\begin{align} x(t) &amp;= X(\\omega) \\cos \\left( \\omega \\cdot t - \\phi(\\omega) \\right) \\\\ x(t) &amp;= X(\\omega) \\cos \\left( \\frac{\\theta_s}{t} \\cdot EO \\cdot t - \\phi(\\omega) \\right) \\\\ &amp;= X(\\omega) \\cos \\left( \\theta_s \\cdot EO - \\phi(\\omega) \\right) \\end{align}\\] Equation 15 <p>The tip deflection is only dependant on the EO, the location of the sensor, and the shaft speed (since \\(\\omega=\\Omega \\cdot EO\\)). The tip deflection is therefore not dependant on time.</p> <p>The implications of this are profound. Normally in vibration measurement, the longer you measure something, the more information you get. Our equations reveal, however, if you keep the shaft speed constant and you measure the tip deflections for all eternity, you will measure the exact same deflections over and over again. You effectively only have as many unique samples as there are sensors. </p> <p>This is why synchronous vibration is more difficult to measure than asynchronous vibration.</p> <p>Recall we said at the beginning of the chapter that synchronous vibration is more difficult to measure than asynchronous vibration? This is the reason why. </p> <p>The continuous waveform will be sampled at approximately the same points over and over again. This makes it difficult to infer the continuous waveform from the samples. Asynchronous vibration, on the other hand, is not dependant on the shaft speed. The continuous waveform will be sampled at different points each revolution. This makes it easier to infer the continuous waveform from the samples.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#aliasing","title":"Aliasing","text":"<p>It is often pointed out that BTT signals are aliased. This means BTT systems sample at a rate below the Nyquist frequency of the blade response. </p> <p>The Nyquist frequency is double the natural frequency we want to measure:</p> \\[ \\begin{align} f_{s,N} &amp;= \\omega_n \\cdot 2\\\\ &amp;= 125 \\cdot 2\\\\ &amp;= 250 Hz \\end{align} \\] Equation 16 <p>We can calculate our BTT system's sampling rate at the EO 6 resonance speed of 1250 RPM:</p> \\[ \\begin{align} f_s &amp;= \\Omega \\cdot S\\\\ &amp;= \\frac{\\omega}{EO} \\cdot S\\\\ &amp;= \\frac{1250}{60} \\cdot 3\\\\ &amp;= 62.5\\\\ \\end{align} \\] Symbols Symbol Meaning SI Unit Domain \\(f_{s,N}\\) Nyquist frequency \\(Hz\\) \\(f_{sN} \\gt 0\\) \\(f_s\\) Sampling frequency \\(Hz\\) \\(f_s \\gt 0\\) \\(\\Omega\\) Shaft speed \\(Hz\\) \\(\\Omega \\gt 0\\) <p>We only measure 62.5 samples per second, whereas the required rate is 250 samples per second. This is why BTT signals are said to be aliased.</p> <p>Note</p> <p>Although the above method provides intuition, I do not believe it is a mathematically sound deduction. We normally associate aliasing and the Nyquist frequency with signals that can be transformed using the Discrete Fourier Transform (DFT) . One requirement of the DFT is the samples must be equidistant along the discretization axis, like time or angle. BTT sensors are generally not equally far apart from one another. Even if you attempted to install them equidistantly, manufacturing errors would render the samples non-equidistant.</p> <p>You can read about this in more detail in (VanderPlas, 2018)<sup>6</sup>.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#conclusion","title":"Conclusion","text":"<p>In this chapter, we've spent some time to understand the fundamentals behind synchronous vibration. We've shown that BTT systems sample a continuous vibration waveform, and we need to infer the true vibration behavior from these samples.   </p> <p>The final two chapter describe two ways of completing our promised journey. The two remaining chapters describe different ways to infer vibration frequency, amplitude, and phase from the samples:</p> <ul> <li>Ch8: The Single Degree of Freedom (SDoF) fit method, and</li> <li>Ch9: The Circumferential Fourier Fit (CFF) method;</li> </ul> <p>Outcomes</p> <p> Understand how obstructions in the flow path causes synchronous vibration.</p> <p> Understand that synchronous vibration occurs at an integer multiple of the shaft speed. This integer multiple is called the Engine Order (EO). </p> <p> Understand what a Campbell diagram is and how we can use it to guess the mode associated with a resonance event we measured.</p> <p> Understand that we can use a Single Degree of Freedom (SDoF) oscillator to model a blade's vibration.</p> <p> Understand how BTT systems sample the blade's vibration waveform.</p> <p> Understand why synchronous vibration data is more difficult to process than asynchronous vibration data.</p> <p> Understand that BTT signals are generally aliased.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch7/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to Justin Smith and Alex Brocco for reviewing this chapter and providing feedback. </p> <p> Dawie Diamond </p> <p> 2024-03-12 2024-08-25              </p> <ol> <li> <p>Rao, J., 1991. Turbomachine blade vibration. New Age International.\u00a0\u21a9</p> </li> <li> <p>Diamond, D.H., Stephan Heyns, P., 2018. A novel method for the design of proximity sensor configuration for rotor blade tip timing. Journal of Vibration and Acoustics 140, 061003.\u00a0\u21a9</p> </li> <li> <p>Forsthoffer, W.E., 2021. Forsthoffer's proven guidelines for rotating machinery excellence. Butterworth-Heinemann.\u00a0\u21a9</p> </li> <li> <p>Tanuma, T., 2022. Advances in steam turbines for modern power plants. Woodhead Publishing.\u00a0\u21a9</p> </li> <li> <p>Rao, S., 2003. Machanical vibrations. Pearson Education India.\u00a0\u21a9</p> </li> <li> <p>VanderPlas, J.T., 2018. Understanding the lomb--scargle periodogram. The Astrophysical Journal Supplement Series 236, 16.\u00a0\u21a9</p> </li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/","title":"8. Single Degree of Freedom (SDoF) Method","text":"You are here","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#single-degree-of-freedom-sdof-fit-method","title":"Single Degree of Freedom (SDoF) Fit Method","text":"<p>In the previous chapter, we used a fully defined SDoF vibration model to generate the samples we typically observe in BTT data. </p> <p>In this chapter, we do the opposite. </p> <p>The SDoF fit method comprises solving the inverse problem. In other words, we already have  the sampled tip deflections for each probe. Now we need to find the SDoF model's parameters. I've put together a GIF that captures the essence of the task. Our model (represented by the red line) changes until it lies on top of the observed datapoints (blue).</p> <p> </p> Figure 1:     An animation of how the SDoF fit method's predicted tip deflections change as the natural frequency, damping ratio, and static deflection converge to the correct solution. I added some animations to the dots and a glitch effect. These effects do not have any meaning... I just couldn't help myself \ud83d\ude01.    <p>We restate the SDoF equations below for convenience. </p> \\[\\begin{equation} x(t) = X(\\omega) \\cos \\left( \\theta_s \\cdot EO - \\phi(\\omega) \\right) \\end{equation}\\] <p></p> \\[\\begin{equation} X(\\omega) = \\frac{\\delta_{\\text{st}}}{ \\sqrt{ (1 - r^2)^2 + (2 \\zeta r)^2 } }\\\\ \\end{equation}\\] <p></p> \\[\\begin{equation} \\phi(\\omega) = \\arctan \\left( \\frac{2 \\zeta r}{1 - r^2} \\right)\\\\ \\end{equation}\\] <p></p> \\[\\begin{equation} r = \\frac{\\omega}{\\omega_n} \\end{equation}\\] Symbols Symbol Meaning SI Unit Domain \\(x(t)\\) Tip deflection \\(\\mu m\\) \\(\\mathbb{R}\\) \\(X(\\omega)\\) Vibration amplitude \\(\\mu m\\) \\(\\mathbb{R}+\\) \\(\\delta_{\\text{st}}\\) Static deflection \\(\\mu m\\) \\(\\mathbb{R}+\\) \\(\\zeta\\) Damping ratio - \\([0,1)\\) for underdamped systems \\(\\omega_n\\) Natural frequency \\(rad/s\\) or Hz \\(\\mathbb{R}+\\) \\(\\theta_s\\) Sensor position \\(rad\\) \\([0, 2\\pi]\\) \\(\\phi(\\omega)\\) Phase angle \\(rad\\) \\(\\mathbb{R}\\) \\(\\omega\\) Excitation frequency \\(rad/s\\) or Hz \\(\\mathbb{R}+\\) \\(EO\\) Engine Order - \\(\\mathbb{Z}+\\) <p>Our task is to find values for \\(\\delta_{\\text{st}}\\), \\(\\zeta\\), and \\(\\omega_n\\) that best fit the data. This approach was set forth as early as 1978. It is, to my best knowledge, the first BTT vibration inference method ever proposed (Zablotskiy and Korostelev, 1978)<sup>1</sup>. </p> <p>In this chapter, we first produce a simple solution to the above equations. Layers of complexity are added incrementally. I use the incremental approach to emphasize the nonlinear nature of this problem. If you invest time in understanding these concepts, you can apply the lessons wherever you need to determine parameters inside sinusoidal terms in the future. </p> <p>This chapter culminates in the fulfillment of the promise I made at the start of the tutorial. You'll be able to infer blade frequency, amplitude, and phase from raw time stamps.</p> <p>Outcomes</p> <p> Understand why we require an optimization function to determine the model parameters of the SDoF fit method.</p> <p> Understand why we need to specify upper and lower bounds for the model parameters.</p> <p> Understand why the SDoF model, in its raw form, is not adequate. We need to add phase and amplitude offsets to the objective function.</p> <p> Understand how we can loop over each probe's data to fit the SDoF model to multiple probes.</p> <p> Understand why the EO is treated differently than the other model parameters. Because the EO can only be a positive integer, we iterate over the EOs to identify the optimal EO.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#follow-along","title":"Follow along","text":"<p>The worksheet for this chapter can be downloaded here .</p> <p>You can open a Google Colab session of the worksheet here: .</p> <p>You need to use one of these Python versions to run the worksheet:  </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#getting-the-dataset","title":"Getting the dataset","text":"<p>Let's use the dataset from Chapter 5 again. The functions developed in chapters 1 - 6 have been included in the <code>bladesight</code> package. </p> <p>We use these functions to generate the tip deflections for the dataset:</p> <pre><code>ds = Datasets[\"data/intro_to_btt/intro_to_btt_ch05\"]\ndf_opr_zero_crossings = ds['table/opr_zero_crossings']\ndf_prox_1 = ds['table/prox_1_toas']\ndf_prox_2 = ds['table/prox_2_toas']\ndf_prox_3 = ds['table/prox_3_toas']\ndf_prox_4 = ds['table/prox_4_toas']\n\nBLADE_COUNT = 5\nRADIUS = 164000\n\nrotor_blade_AoA_dfs = get_rotor_blade_AoAs(\n    df_opr_zero_crossings,\n    [df_prox_1, df_prox_2, df_prox_3, df_prox_4],\n    np.cumsum(np.deg2rad(np.array([19.34, 19.34, 19.34]))), # (1)!\n    BLADE_COUNT\n)\ntip_deflection_dfs = []\nfor df_AoAs in rotor_blade_AoA_dfs:\n    df_tip_deflections = get_blade_tip_deflections_from_AoAs(\n        df_AoAs,\n        RADIUS,\n        11,#(2)!\n        2,#(3)!\n        0.5#(4)!\n    )\n    tip_deflection_dfs.append(df_tip_deflections)\n</code></pre> <ol> <li>These are the angles between probes 2 to 4 relative to probe 1.</li> <li>The order of the zeroing polynomial.</li> <li>The order of the Butterworth filter.</li> <li>The cutoff frequency of the Butterworth filter.</li> </ol> <p>We plot the peak-to-peak vibration for blade 1 in Figure 2 below.</p> Reset Zoom Figure 2: The peak-to-peak vibration levels for a five blade blisk with four probes. The left and right edges of the peak-to-peak chart curls up but never returns back to a low value, as is usually the case with transient resonances. This is a consequence of the zeroing we performed. Since those regions don't contain resonances, we can live with these end effects.    <p>The peak-to-peak vibration for blade 1 is presented in Figure 2 above. There seems to be symmetric resonance events on the up and downward ramps. </p> <p>For illustrative purposes, we focus on the resonance event between shaft revolutions 500 and 600.</p> <p>End effects</p> <p>You may have noticed the ends of the peak-to-peak vibration increase without a subsequent decrease. Resonance events are usually identified by the peak-to-peak vibration increasing as the event starts, and decreasing as the event finishes.</p> <p>The end effects observed in Figure 2 is not a resonance event. It is an artifact of the order domain polynomial detrending we performed in Chapter 6. The order domain zeroing often skews the peak-to-peak vibration values near the edges.</p> <p>If there were resonances in those regions, we would have taken the time to perform better zeroing. From prior experience, I can confirm there are no resonances in those regions, so we can simply proceed.</p> <p>The original method (Zablotskiy and Korostelev, 1978)<sup>1</sup> used only one probe's data to fit the model. We'll also start with just one probe. </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#the-nontrivial-nature-of-the-problem","title":"The nontrivial nature of the problem","text":"<p>It is conventional for engineers to invert the equation that contains the variable we want to solve. Let's start with solving for the EO. We invert Equation 1 below:</p> <p></p> \\[\\begin{align} x(t) &amp;= X(\\omega) \\cos \\left( \\theta_s \\cdot EO - \\phi(\\omega) \\right ) \\\\ \\frac{x(t)}{X(\\omega)} &amp;= \\cos \\left( \\theta_s \\cdot EO - \\phi(\\omega) \\right ) \\\\ \\arccos \\left( \\frac{x(t)}{X(\\omega)} \\right) &amp;= \\theta_s \\cdot EO - \\phi(\\omega) \\\\ \\theta_s \\cdot EO &amp;= \\arccos \\left( \\frac{x(t)}{X(\\omega)} \\right) + \\phi(\\omega) \\\\ EO &amp;= \\frac{\\arccos \\left( \\frac{x(t)}{X(\\omega)} \\right) + \\phi(\\omega)}{\\theta_s} \\end{align}\\] <p>the below domain constraint is required:</p> \\[\\begin{equation} -1 \\leq \\frac{x(t)}{X(\\omega)} \\leq 1 \\end{equation}\\] <p>How easy is it to solve for \\(EO\\) using this inversion? I have no idea  . It seems absurdly difficult to me. </p> <p>Firstly, the model parameters, \\(\\delta_{\\text{st}}\\), \\(\\zeta\\), and \\(\\omega_n\\), are all inside the \\(X(\\omega)\\) and \\(\\phi(\\omega)\\) terms. They are also unknown! We could rearrange the equations to solve for these parameters, but we would have the same problem. Our model parameters cannot be solved for directly.</p> <p>Secondly, we have a domain constraint on the argument of the arccos function. This means we have to solve for \\(EO\\) using a nonlinear constraint. I don't like the sound of that. If you do manage to find a closed form analytic solution for the model parameters, don't send it to me, send it to the Nobel committee.</p> <p>We therefore resort to computational techniques. We'll use an optimization algorithm to find the solution.</p> <p>The first step we take toward a solution is to guess the EO of vibration. The decision to arbitrarily guess the EO may make you uneasy. In most undergraduate courses, we are used to well-posed problems. Give me the mass of a body and the force acting on it, and I can tell you the acceleration with 100% certainty. Solving the SDoF fit method is not like that.</p> <p>Solving the SDoF fit problem is a bit like dating. The only way to find the right person is to first commit to the relationship, and assess how it goes.</p> <p>How can we make an intelligent guess for the EO? We can use the formula below:</p> \\[\\begin{equation} EO = \\frac{\\text{Natural frequency}}{\\text{Shaft speed}} \\end{equation}\\] <p>We've seen this equation before. It is the definition of the Engine Order. The EO is the integer multiple of the shaft speed that determines the excitation frequency.</p> <p>For the blades used in this tutorial, I happen to know (because I designed these blades) that the blades' first natural frequency is approximately 125 Hz. To get a shaft speed, we take the median shaft speed inside the resonance region that we've identified between revolutions 500 and 600, which is 950 RPM:</p> \\[ \\text{EO} = \\frac{125}{950 / 60} \\approx 7.9 \\] <p>We'll therefore start with a guess of 8 for our EO. Is it a good guess? That will be revealed at the end of this chapter.</p> <p>What if the natural frequencies are not known?</p> <p>Don't worry. We just need to pick an EO to start with for our optimization algorithm. Later in the chapter, we loop over a range of EOs and compare the objective function values to identify the optimal EO. </p> <p>Why are we assuming there is only one frequency that dominates the response?</p> <p>This entire chapter is based on the assumption that there is one frequency that dominates the response. That is the definition of the SDoF model. It is a simplification that is often good enough. Here's an appropriate quote often attributed to George Box: \"All models are wrong, but some are useful\" (Box, 1979)<sup>2</sup>. </p> <p>In reality, the blade will respond at many different frequencies simultaneously. However, if the blades are in resonance, the response will likely be dominated by the natural frequency.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#resonance-window-selection","title":"Resonance window selection","text":"<p>To fit our SDoF model, we need to identify data in a resonance region. In other words , we must create a new <code>DataFrame</code> that contains only the tip deflections within a resonance region. </p> <p>We can use the shaft revolution number to construct this new <code>DataFrame</code> . The <code>eval</code> method of a Pandas DataFrame can be used to this end:</p> <p><pre><code>df_resonance_window = tip_deflection_dfs[0].query(\"n &gt; 500 and n &lt; 600\")\n</code></pre> In the code snippet above, we first select the tip deflections that belong to the first blade (<code>tip_deflection_dfs[0]</code>), and then we select only the tip deflections occurring between shaft revolutions 500 and 600 (<code>query(\"n &gt; 500 and n &lt; 600\")</code>).</p> <p>Can't window selection be automated?</p> <p>Yes. Techniques exist to automatically identify resonance regions. Some of them have been patented. They are not included here because they are not required for solving the SDoF fit equations.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#a-simple-objective-function","title":"A simple objective function","text":"<p>Many optimization algorithms are available in Python. These algorithms require an objective function. The objective function evaluates how good a proposed set of model parameters are by returning an error between the predicted tip deflections and the observed tip deflections. It should return a small error for a good fit and a large error for a bad fit. The optimization algorithm searches for parameters that minimize the objective function.</p> <p>Let's start with a simple objective function. We'll use the sum of squared error between the measured tip deflections, and the predicted tip deflections defined in Equation 1 to Equation 4. </p> <p>The code for this objective function is shown below:</p> <pre><code>def get_X(\n        omega : np.ndarray,\n        omega_n : float, \n        zeta: float,\n        delta_st: float\n    ) -&gt; np.ndarray:#(1)!\n    r = omega / omega_n\n    return (\n        delta_st \n        / np.sqrt(\n            (1 - r**2)**2 \n            + (2*zeta*r)**2\n        )\n    )\n\ndef get_phi(\n    omega : np.ndarray, \n    omega_n : float, \n    zeta: float\n) -&gt; np.ndarray:#(2)!\n    r = omega / omega_n\n    return np.arctan2(2 * zeta * r,1 - r**2)\n\ndef predict_sdof_samples_simple(\n    omega_n : float,\n    zeta : float,\n    delta_st : float,\n    EO : int,\n    theta_sensor : float,\n    arr_omega : np.ndarray\n) -&gt; np.ndarray:#(3)!\n    X = get_X(arr_omega*EO, omega_n, zeta, delta_st)#(4)!\n    phi = get_phi(arr_omega*EO, omega_n, zeta)\n    predicted_tip_deflections = X * np.cos(theta_sensor * EO - phi)\n    return predicted_tip_deflections\n\ndef SDoF_simple_loss(\n        model_params : np.ndarray,\n        arr_tip_deflections : np.ndarray,\n        arr_omega : np.ndarray, \n        EO : int, \n        theta_sensor : float\n    ) -&gt; np.ndarray:#(5)!\n    omega_n, ln_zeta, delta_st = model_params\n    zeta = np.exp(ln_zeta)#(6)!\n    predicted_tip_deflections = predict_sdof_samples_simple(\n        omega_n, zeta, delta_st, EO, theta_sensor, arr_omega\n    )\n    return np.sum(\n        (\n            arr_tip_deflections\n            - predicted_tip_deflections\n        )**2\n    )\n</code></pre> <ol> <li> <p>This function returns the vibration amplitude of      the blade vibration.</p> <p><code>x(\u03c9) =     \u03b4_st / sqrt( (1 - r**2)**2 + (2*\u03b6*r)**2)</code></p> <p>where:</p> <p>r = \u03c9/\u03c9_0</p> <p>Args:</p> <pre><code>omega (np.ndarray): The excitation frequencies in rad/s.\n\nomega_n (float): The natural frequency of the blade in rad/s.\n\nzeta (float): The damping ratio of the blade vibration.\n\ndelta_st (float, optional): The static deflection of the blade. \n    This value is usually given in units of \u00b5m.\n</code></pre> <p>Returns:</p> <pre><code>np.ndarray: The amplitude of the blade vibration in the\n    same units as delta_st.\n</code></pre> </li> <li> <p>Get the phase between the tip deflection and          the forcing function. </p> <p>\u03c6(\u03c9) = arctan(2\u03b6r /  (1 - r**2))</p> <p>where: r = \u03c9/\u03c9_n</p> <p>Args:     omega (np.ndarray): The excitation frequencies in rad/s.</p> <pre><code>omega_0 (float): The natural frequency of the blade in rad/s.\n\ndelta (float): The damping ratio of the blade vibration.\n</code></pre> <p>Returns:</p> <pre><code>np.ndarray: The phase of the blade vibration in rad.\n</code></pre> </li> <li> <p>This function determined the predicted SDoF fit     samples at a proximity probe given the SDoF parameters.</p> <p>Args:</p> <pre><code>omega_n (float): The natural frequency of the SDoF system.\n\nzeta (float): The damping ratio of the SDoF system.\n\ndelta_st (float): The static deflection of the SDoF system.\n\nEO (int): The EO of vibration you want to fit.\n\ntheta_sensor (float): The sensor's angular position on the rotor.\n\narr_omega (np.ndarray): The angular velocity of the rotor corresponding\n    to each revolution for which we want to predict the SDoF samples.\n</code></pre> <p>Returns:</p> <pre><code>np.ndarray: The predicted SDoF samples.\n</code></pre> </li> <li> <p>Note how we multiply the shaft speed with EO to get the excitation frequency.</p> </li> <li> <p>This function returns the error between the SDoF model given the      parameters and the measured tip deflection data.</p> <p>Args:</p> <pre><code>model_params (np.ndarray): The SDoF fit method's model parameters. It\n    includes a list of the following parameters:\n    omega_n (float): The natural frequency of the SDoF system.\n    ln_zeta (float): The damping ratio of the SDoF system.\n    delta_st (float): The static deflection of the SDoF system.\n\narr_tip_deflections (np.ndarray): The tip deflection data of the probe.\n\narr_omega (np.ndarray): The angular velocity of the rotor corresponding\n    to the tip deflection data.\n\nEO (int): The EO of vibration you want to fit.\n\ntheta_sensor (float): The sensor's angular position on the rotor.\n</code></pre> <p>Returns:</p> <pre><code>np.ndarray: The sum of squared error between the tip deflection data\n    and the predicted tip deflections.\n</code></pre> </li> <li> <p>We use the logarithm of the damping ratio to make the optimization     surface more linear. This helps the optimization algorithm converge faster.</p> </li> </ol> <p>We've broken up our loss function to make it easier to understand. It is dependant on three other functions:</p> <ol> <li><code>get_X</code></li> <li><code>get_phi</code></li> <li><code>predict_sdof_samples_simple</code></li> </ol> <p>The <code>get_X</code> and <code>get_phi</code> functions are used to calculate the vibration amplitude and phase. The <code>predict_sdof_samples_simple</code> function uses these values to predict the tip deflections for a given set of SDoF parameters. The suffix <code>_simple</code> has been added to the function names. It will later become clear why I did this.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#optimization-bounds","title":"Optimization bounds","text":"<p>Which optimization function should we use?</p> <p>One of the challenges of solving optimization problems where the optimization parameters occur inside sinusoidal terms is they often struggle to converge. This is because the solution space may have many local minima and maxima, and the gradient may not point in the direction of the global optimum. </p> <p>Our problem contains both cosine and arctan functions, which means the solution space is likely complex and nonlinear. We therefore choose to use a global optimization method because it does not rely on gradients, but rather explores the solution space with a population of candidate solutions. </p> <p>I experimented with several methods, and found the <code>scipy.optimize.differential_evolution</code> method works well for this problem. I did not have a more profound reason than this. </p> <p>This method requires us to specify bounds for the optimization parameters. We can specify bounds based on our physical constraints and prior knowledge.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#bounds-for-the-natural-frequency","title":"Bounds for the natural frequency","text":"<p>To set the bounds for the natural frequency, we can use a simple formula based on the engine order and the shaft speed. We have already identified the resonance window. We therefore have all shaft speed values occurring inside the resonance window.</p> <p>We can therefore calculate the minimum and maximum possible natural frequency as follows:</p> \\[\\begin{equation} \\omega_{n, \\textrm{min}} = EO \\cdot \\Omega_{\\textrm{min}} \\end{equation}\\] \\[\\begin{equation} \\omega_{n, \\textrm{max}} = EO \\cdot \\Omega_{\\textrm{max}} \\end{equation}\\] <p>The snippet below shows how to implement this in code: <pre><code>omega_n_min = df_resonance_window[\"Omega\"].min() * EO\nomega_n_max = df_resonance_window[\"Omega\"].max() * EO\n</code></pre></p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#bounds-for-damping","title":"Bounds for damping","text":"<p>Our system is underdamped, which means the damping ratio, \\(\\zeta\\), is positive and less than 1 (Rao, 2003)<sup>3</sup>. From experience, a range between 0.0001 and 0.3 should cover all cases encountered in practice.</p> <p>In the previous chapter, you had an opportunity to change the \\(\\zeta\\) parameter with a slider and observe the effect this has on the vibration response. You may recall that, when \\(\\zeta\\) is small, a tiny change in \\(\\zeta\\) causes a huge change in the vibration amplitude. The optimization algorithm is not privy to this information. The more linear the optimization surface, the easier it is for the optimization algorithm to find the global minimum.</p> <p>We therefore transform the damping ratio by calculating its natural logarithm. This way, the optimization algorithm can work with a more straightforward relationship between the parameter it is optimizing, \\(\\ln(\\zeta)\\), and the objective function. </p> <p>We convert the logarithm of \\(\\zeta\\) back to the original value inside the objective function, as indicated in Line 45 of the code snippet above.</p> <p>The bounds for the damping ratio is therefore:</p> <pre><code>ln_zeta_min = np.log(0.0001)#(1)!\nln_zeta_max = np.log(0.3)\n</code></pre> <ol> <li>I expected the natural logarithm function to be <code>np.ln</code>. For some reason, it is actually <code>np.log</code>.</li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#bounds-for-the-static-deflection","title":"Bounds for the static deflection","text":"<p>The static deflection bounds are the most application specific. It depends on how large your resonance amplitudes generally are. The higher the vibration amplitude, the wider these bounds should be.</p> <p>A good initial guess for the current rotor is a value between 0 and 10 \\(\\mu m\\) for \\(\\delta_{\\textrm{st}}\\). You can adjust this value later based on your results.</p> <pre><code>delta_st_min = 0\ndelta_st_max = 10\n</code></pre>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#solving-the-simple-problem","title":"Solving the simple problem","text":"<p>Now we simply provide these values, along with the optimization function, to the <code>scipy.optimize.differential_evolution</code> function. The code snippet below shows how to do this:</p> <pre><code>from scipy.optimize import differential_evolution #(1)!\nsimple_solution = differential_evolution(\n    func = SDoF_simple_loss,\n    bounds=[#(2)!\n        (omega_n_min, omega_n_max),\n        (ln_zeta_min, ln_zeta_max),\n        (delta_st_min, delta_st_max)\n    ],\n    args=(#(3)!\n        df_resonance_window[f'x_p1_filt'].values,\n        df_resonance_window['Omega'].values,\n        EO,\n        df_resonance_window[\"AoA_p1\"].median()#(4)!\n    ),\n    seed=42#(5)!\n)\n</code></pre> <ol> <li>We import the <code>differential_evolution</code> function from the <code>scipy.optimize</code> package. In the worksheet, we do this at the top of the worksheet, not where we solve the problem.</li> <li>We provide the bounds for the optimization parameters. The optimization algorithm calculates there are 3 parameters, and therefore creates an array of three values being passed into the <code>model_params</code> argument of the <code>SDoF_simple_loss</code> function.</li> <li>Each one of these arguments correspond to the positional arguments in the <code>SDoF_simple_loss</code> function after the <code>model_params</code> argument. The <code>differential_evolution</code> function will pass these arguments to the <code>SDoF_simple_loss</code> function in the same order.</li> <li>We use the median value of the AoA as the sensor position. Remember, the <code>AoA_p1</code> column has not been zeroed or normalized yet. </li> <li>The seed is not strictly necessary, but it ensures the results are reproducible on the same computer. You may even get the exact same answers as I did if you use the same seed.</li> </ol> <p>The <code>differential_evolution</code> function returns a <code>OptimizeResult</code> object. We can print this object: <pre><code>&gt;&gt;&gt; print(simple_solution)\n</code></pre> <pre><code> message: Optimization terminated successfully.\n success: True\n     fun: 1881551.798646529\n       x: [ 7.887e+02 -6.175e+00  1.469e+00]\n     nit: 15\n    nfev: 760\n     jac: [-9.313e-02  3.423e+00 -4.005e+00]\n</code></pre></p> <p>Here, the optimization algorithm converged successfully. We can print out the results of the optimization algorithm as follows:</p> <pre><code>print(\"\u03c9_n = \", simple_solution.x[0] / (2*np.pi), \" Hz\")\nprint(\"\u03b6   = \", np.exp(simple_solution.x[1]))\nprint(\"\u03b4_st= \", simple_solution.x[2], \" \u00b5m\")\n</code></pre> <pre><code>\u03c9_n =  125.53304440293931  Hz\n\u03b6   =  0.0020816334883631683\n\u03b4_st=  1.4691101377911184  \u00b5m\n</code></pre> <p>We have solved the SDoF fit method with a global optimization algorithm \ud83d\udc4f. </p> <p>Can we confirm this solution is correct?</p> <p>It is always a good idea to plot the results. The predicted vs true tip deflections are presented in Figure 3 below.</p> Reset Zoom Figure 3: The SDoF fit method's predicted tip deflections vs the measured tip deflections.    <p>Figure 3 reveals our model is not a good fit for the measured tip deflections. The two lines share some resemblance, but our fit is far from satisfactory.</p> <p>One thing our model does capture is the increase in amplitude around \\(n=560\\). This suggests we are on the right track, but we need to refine our model further.</p> <p>There are two shortcomings we need to fix. First, our model predicts zero tip deflection near the start and end of the resonance. Contrast this to the measured tip deflections, which seems to settle at -80 and -110 \u03bcm respectively. </p> <p>The most likely reason for this is because our data zeroing step pushed the \"measured\" tip deflections past its true zero point. The seemingly negative values may be an artifact of the zeroing process. We need to account for this in our model.</p> <p>Second, our model only produces positive tip deflections. The measured data, however, shows a sudden negative dip around \\(n=568\\). This means our model misses an important phenomenon. </p> <p>Why is our model flat when it should predict tip deflections along this sudden dip? </p> <p>Because we have made a terribly simplistic assumption concerning our phase angle. Equation 3 is the phase angle between the forcing function and the response. This implicitly assumes the forcing function is zero at the start of each revolution. In practice, the phase angle of the forcing function is almost certainly unknown. We therefore need to solve the forcing function offset as well.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#amplitude-and-phase-offsets","title":"Amplitude and phase offsets","text":"<p>We have diagnosed what's wrong with our model: it does not account for amplitude and phase offsets. How do we fix it? Let's start with the phase offset. This is a simple adjustment: we just add a constant term to the argument of the cosine function from Equation 1. </p> <p>The new equation is given below:</p> <p></p> \\[\\begin{equation} x(t) = X(\\omega) \\cos \\left( \\theta_s \\cdot EO - \\phi(\\omega) + \\phi_0 \\right) \\end{equation}\\] <p>where \\(\\phi_0\\) is our new phase offset. What are the possible values for \\(\\phi_0\\)? Since the start of the forcing function is unknown, we can assume any value between 0 and \\(2 \\pi\\). That's our first improvement.</p> <p>Next, we need to add an amplitude offset. This is more complicated. A reasonable attempt would be to just add a constant term to each probe's measurements. That would, however, imply our zeroing artifact at the start and the end of the resonance has the same value. No justification for this assumption exists.</p> <p>Instead, we introduce a linearly-varying amplitude correction. The correction function is defined by two terms, \\(z_{\\Omega_{\\textrm{median}}}\\) and \\(z_{\\Omega_{\\textrm{max}}}\\). These terms are defined as follows:</p> <ol> <li>\\(z_{\\Omega_{\\textrm{median}}}\\) is the amplitude correction at the median shaft speed in the resonance window.</li> <li>\\(z_{\\Omega_{\\textrm{max}}}\\) is the amplitude correction at the maximum shaft speed in the resonance window.</li> </ol> <p>From these two terms, we can calculate a correction function that varies linearly with shaft speed. </p> <p>The correction function is defined as follows:</p> \\[\\begin{equation} z(\\Omega) = m_z \\cdot \\Omega + b_z  \\end{equation}\\] \\[\\begin{equation} m_z = \\frac{z_{\\Omega_{\\textrm{max}}} - z_{\\Omega_{\\textrm{median}}}}{\\Omega_{\\textrm{max}} - \\Omega_{\\textrm{median}}} \\end{equation}\\] \\[\\begin{equation} b_z = z_{\\Omega_{\\textrm{median}}} - m_z \\cdot \\Omega_{\\textrm{median}} \\end{equation}\\] <p>The terms \\(m_z\\) and \\(b_z\\) are the slope and intercept of the correction function. They depend on the correction factors, \\(z_{\\Omega_{\\textrm{median}}}\\) and \\(z_{\\Omega_{\\textrm{max}}}\\), and the median and maximum shaft speeds in the resonance window, \\(\\Omega_{\\textrm{median}}\\) and \\(\\Omega_{\\textrm{max}}\\).</p> <p>Correction function vs phase offset</p> <p>We've added two new concepts: the phase offset term, \\(\\phi_0\\), and the correction factors, \\(z_{\\Omega_{\\textrm{median}}}\\) and \\(z_{\\Omega_{\\textrm{max}}}\\). There is a subtle difference between where these two terms are applied. </p> <p>The phase offset term, \\(\\phi_0\\), is part of our SDoF vibration model. It shifts the entire vibration waveform such that \\(\\phi\\) represents the phase difference between the force and the tip deflection. The correction function, \\(z(\\Omega)\\), is not part of the SDoF vibration model. This correction factor is applied to the measured tip deflections. </p> <p>How do we choose the bounds for the correction factors? Hopefully, our optimization algorithm is smart enough to find the optimal solution without us constraining the correction factors too much. We therefore set the positive and negative bounds' size equal to the maximum absolute tip deflection in the resonance window.</p> <p>The bounds for our new parameters are therefore:</p> <pre><code>phi_0_min = 0\nphi_0_max = 2*np.pi\nz_max = df_resonance_window[\"x_p1_filt\"].abs().max()\nz_min = -z_max\n</code></pre> <p>We rewrite our SDoF model as follows:</p> <pre><code>def predict_sdof_samples(\n    omega_n : float,\n    zeta : float,\n    delta_st : float,\n    EO : int,\n    theta_sensor : float,\n    phi_0 : float,\n    arr_omega : np.ndarray\n) -&gt; np.ndarray:#(1)!\n    X = get_X(arr_omega*EO, omega_n, zeta, delta_st)  \n    phi = get_phi(arr_omega*EO, omega_n, zeta)\n    predicted_tip_deflections = X * np.cos(theta_sensor * EO - phi + phi_0)\n    return predicted_tip_deflections\n</code></pre> <ol> <li> <p>This function determined the predicted SDoF fit     samples at a proximity probe given the SDoF parameters.</p> <p>Args:</p> <pre><code>omega_n (float): The natural frequency of the SDoF system.\n\nzeta (float): The damping ratio of the SDoF system.\n\ndelta_st (float): The static deflection of the SDoF system.\n\nphi_0 (float): The phase offset of the SDoF system.\n\nEO (int): The EO of vibration you want to fit.\n\ntheta_sensor (float): The sensor's angular position on the rotor.\n\nphi_0 (float): The phase offset of the SDoF system.\n\narr_omega (np.ndarray): The angular velocity of the rotor corresponding\n    to each revolution for which we want to predict the SDoF samples.\n</code></pre> <p>Returns:</p> <pre><code>np.ndarray: The predicted SDoF samples.\n</code></pre> </li> </ol> <p>Our new loss function is given below:</p> <pre><code>def get_correction_values(\n    arr_omegas : float,\n    z_median : float,\n    z_max : float, \n) -&gt; np.ndarray:#(1)!\n    omega_median = np.median(arr_omegas)\n    omega_max = np.min(arr_omegas)\n    m = (\n        z_max\n        - z_median\n    ) / (\n        omega_max \n        - omega_median\n    )\n    b = z_median - m * omega_median\n    correction_values = m * arr_omegas  + b\n    return correction_values\n\ndef SDoF_loss(\n        model_params : np.ndarray,\n        arr_tip_deflections : np.ndarray,\n        arr_omega : np.ndarray, \n        EO : int, \n        theta_sensor : float\n) -&gt; np.ndarray:#(2)!\n    omega_n, ln_zeta, delta_st, phi_0, z_median, z_max = model_params\n    zeta = np.exp(ln_zeta)\n    predicted_tip_deflections = predict_sdof_samples(\n        omega_n, zeta, delta_st, EO, theta_sensor, phi_0, arr_omega\n    )\n    arr_tip_deflection_corrections = get_correction_values(\n        arr_omega, z_median, z_max\n    )\n    arr_tip_deflections_corrected = (\n        arr_tip_deflections\n        + arr_tip_deflection_corrections\n    )\n    return np.sum(\n        (\n            arr_tip_deflections_corrected\n            - predicted_tip_deflections\n        )**2\n    )\n</code></pre> <ol> <li> <p>This function calculates the correction values for each sample     based on the correction factors.</p> <p>Args:     arr_omegas (float): The omega values for each sample.</p> <pre><code>z_median (float): The correction value at the median shaft speed.\n\nz_max (float): The correction value at the max shaft speed.\n</code></pre> <p>Returns:     np.ndarray: The sample offsets for each sample.</p> </li> <li> <p>This function fits the SDoF parameters to a single      probe's tip deflection data.</p> <p>Args:     model_params (np.ndarray): The SDoF fit method's model parameters. It         includes a list of the following parameters:         omega_n (float): The natural frequency of the SDoF system.         ln_zeta (float): The damping ratio of the SDoF system.         delta_st (float): The static deflection of the SDoF system.         phi_0 (float): The phase offset of the SDoF system.         z_median (float): The amplitude offset at the median shaft speed.         z_max (float): The maximum amplitude offset.</p> <pre><code>arr_tip_deflections (np.ndarray): The tip deflection data of the probe.\n\narr_omega (np.ndarray): The angular velocity of the rotor corresponding\n    to the tip deflection data.\n\nEO (int): The EO of vibration you want to fit.\n\ntheta_sensor (float): The sensor's angular position on the rotor.\n</code></pre> <p>Returns:     np.ndarray: The sum of squared error between the tip deflection data</p> </li> </ol> <p>We've created a new function, <code>get_correction_values</code>. This function calculates the correction values for each sample based on the correction factors. The correction factors are the values that need to be determined during optimization.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#solving-the-improved-problem","title":"Solving the improved problem","text":"<p>We solve the improved problem with the code below:</p> <pre><code>improved_solution = differential_evolution(\n    func = SDoF_loss,\n    bounds=[\n        (omega_n_min, omega_n_max),\n        (ln_zeta_min, ln_zeta_max),\n        (delta_st_min, delta_st_max),\n        (phi_0_min, phi_0_max),\n        (z_min, z_max),\n        (z_min, z_max),\n    ],\n    args=(\n        df_resonance_window[f'x_p1_filt'].values,\n        df_resonance_window['Omega'].values,\n        EO,\n        df_resonance_window[\"AoA_p1\"].median()\n    ),\n    seed=42\n)\n</code></pre> <p>Once again, we can print the results:</p> <pre><code>print(\"\u03c9_n      = \", improved_solution.x[0] / (2*np.pi), \" Hz\")\nprint(\"\u03b6        = \", np.exp(improved_solution.x[1]))\nprint(\"\u03b4_st     = \", improved_solution.x[2], \" \u00b5m\")\nprint(\"\u03c6_0      = \", improved_solution.x[3], \" rad\")\nprint(\"z_median = \", improved_solution.x[4], \" \u00b5m\")\nprint(\"z_max    = \", improved_solution.x[5], \" \u00b5m\")\n</code></pre> <pre><code>\u03c9_n      =  126.27747716213543  Hz\n\u03b6        =  0.0026626951829294677\n\u03b4_st     =  3.6772997184546794  \u00b5m\n\u03c6_0      =  4.683877456932529  rad\nz_median =  55.39278985745745  \u00b5m\nz_max    =  134.43742560770318  \u00b5m\n</code></pre> <p>The values are in the same region as the previous solution, except for the static deflection and newly added terms, which were zero by implication in the previous solution.</p> <p>The predicted vs true tip deflections are presented in Figure 4 below.</p> Reset Zoom Figure 4: The improved SDoF fit method's predicted tip deflections vs the corrected measured tip deflections.    <p>That's much better \ud83d\udc4f. The model now captures the negative dip around \\(n=568\\). The model also captures the tip deflection at the start and end of the resonance. The only critique is that the model seems to have a lower amplitude than the measured tip deflections where the resonance occurs. </p> <p>We could delve into a solution. Unfortunately, it makes for a beautiful coding exercise later on \ud83d\ude01. </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#multiple-probe-solution","title":"Multiple probe solution","text":"<p>We have seen how to apply the SDoF fit method to a single probe's tip deflections. Now we want to extend this method to multiple probes. How do we do that?</p> <p>The idea is similar to the single probe case. In the single probe case, we had one array of observed tip deflections. Now, we have a set of observed tip deflection arrays, where each array in the set corresponds to a different probe. We also have different \\(\\theta_s\\) values for each probe, depending on the circumferential spacing between the probes. </p> <p>We have the same number of model parameters, because the model parameters are independent of the number of probes. We must, however, introduce a set of correction values for each probe. Because of this, our optimization search space scales linearly with the number of probes.</p> <p>Our new loss function is given in the code below.</p> <pre><code>def SDoF_loss_multiple_probes(\n        model_params : np.ndarray,\n        tip_deflections_set : List[np.ndarray],\n        arr_omega : np.ndarray, \n        EO : int, \n        theta_sensor_set : List[float]\n) -&gt; np.ndarray:#(1)!\n    omega_n, ln_zeta, delta_st, phi_0, *correction_factors = model_params#(2)!\n    zeta = np.exp(ln_zeta)\n    error = 0#(3)!\n    for i_probe, arr_tip_deflections in enumerate(tip_deflections_set):#(4)!\n        theta_sensor = theta_sensor_set[i_probe]\n        predicted_tip_deflections = predict_sdof_samples(\n            omega_n, zeta, delta_st, EO, theta_sensor, phi_0, arr_omega\n        )\n        z_median = correction_factors[i_probe*2]\n        z_max = correction_factors[i_probe*2+1]#(5)!\n        arr_tip_deflection_corrections = get_correction_values(\n            arr_omega, z_median, z_max\n        )\n        arr_tip_deflections_corrected = (\n            arr_tip_deflections\n            + arr_tip_deflection_corrections\n        )\n        error += np.sum(\n            (\n                arr_tip_deflections_corrected\n                - predicted_tip_deflections\n            )**2\n        )\n    return error\n</code></pre> <ol> <li> <p>This function fits the SDoF parameters to          multiple probes' data.</p> <p>Args:     model_params (np.ndarray): The SDoF fit method's model parameters. It         includes a list of the following parameters:</p> <pre><code>    omega_n (float): The natural frequency of the SDoF system.\n\n    ln_zeta (float): The damping ratio of the SDoF system.\n\n    delta_st (float): The static deflection of the SDoF system.\n\n    phi_0 (float): The phase offset of the SDoF system.\n\n    And the z_median and z_max for each probe.\n\n        z_median (float): The amplitude offset at the \n            median shaft speed.\n\n        z_max (float): The maximum amplitude offset.\n\ntip_deflections_set (List[np.ndarray]): The tip deflection data for each probe.\n\narr_omega (np.ndarray): The angular velocity of the rotor corresponding\n    to the tip deflection data.\n\nEO (int): The EO of vibration you want to fit.\n\ntheta_sensor_set (List[float]): Each sensor's angular position \n    relative to the start of the revolution.\n</code></pre> <p>Returns:</p> <pre><code>np.ndarray: The sum of squared error between \n    the tip deflection data of each probe and\n    the predicted tip deflections.\n</code></pre> </li> <li> <p>This code unpacks the optimization algorithm model arguments, <code>model_params</code>, into the SDoF parameters and the correction factors. The last variable, <code>correction_factors</code>, has an asterisk, <code>*</code>, in front of it. This is Python's way of allocating the rest of <code>model_params</code> into <code>correction_factors</code>. With this notation, we can use the same loss function, regardless of how many probes we have.</p> </li> <li><code>error</code> are now initialized and will be incremented for each probe.</li> <li>We loop over every probe. Essentially, we do exactly what we did in the previous loss function for each probe.</li> <li> <p>We grab the correction factors pertaining to this probe. The correction factors are located in <code>correction_factors</code> in the following order:</p> <pre><code>correction_factors = [\n    z_median_probe_1,\n    z_max_probe_1,\n    z_median_probe_2,\n    z_max_probe_2,\n    .\n    .\n    .,\n    z_median_probe_n,\n    z_max_probe_n,\n]\n</code></pre> </li> </ol> <p>The code below shows how to use the new loss function to solve the multiple probe problem:</p> <pre><code>PROBE_COUNT = 4\nbounds = [\n    (omega_n_min, omega_n_max),\n    (ln_zeta_min, ln_zeta_max),\n    (delta_st_min, delta_st_max),\n    (phi_0_min, phi_0_max),\n]\ntip_deflections_set = []\ntheta_sensor_set = []\nfor i_probe in range(PROBE_COUNT):#(1)!\n    z_max = df_resonance_window[f\"x_p{i_probe+1}_filt\"].abs().max()\n    z_min = -z_max\n    bounds.extend(\n        [\n            (z_min, z_max),\n            (z_min, z_max)\n        ]\n    )\n    tip_deflections_set.append(\n        df_resonance_window[f\"x_p{i_probe+1}_filt\"].values\n    )\n    theta_sensor_set.append(\n        df_resonance_window[f\"AoA_p{i_probe+1}\"].median()\n    )\n\nmultiple_probes_solution = differential_evolution(\n    func = SDoF_loss_multiple_probes,\n    bounds=bounds,\n    args=(\n        tip_deflections_set,\n        df_resonance_window['Omega'].values,\n        EO,\n        theta_sensor_set\n    ),\n    seed=42\n)\n</code></pre> <ol> <li>We loop over each probe and add the bounds, tip deflection array and the probe static position to the optimization problem.</li> </ol> <p>There's a bit more effort involved with the setup of our bounds and arguments, but it is conceptually the same as the single probe case.</p> <p>The results are shown below:</p> <pre><code>print(\"\u03c9_n      = \", multiple_probes_solution.x[0] / (2*np.pi), \" Hz\")\nprint(\"\u03b6        = \", np.exp(multiple_probes_solution.x[1]))\nprint(\"\u03b4_st     = \", multiple_probes_solution.x[2], \" \u00b5m\")\nprint(\"\u03c6_0      = \", multiple_probes_solution.x[3], \" rad\")\nfor i_probe in range(PROBE_COUNT):\n    print(f\"z_median_{i_probe+1} = \", multiple_probes_solution.x[4+i_probe*2], \" \u00b5m\")\n    print(f\"z_max_{i_probe+1}    = \", multiple_probes_solution.x[5+i_probe*2], \" \u00b5m\")\n</code></pre> <pre><code>\u03c9_n      =  126.25099097038297  Hz\n\u03b6        =  0.0026064673895625176\n\u03b4_st     =  3.687735366342961  \u00b5m\n\u03c6_0      =  4.833934260209016  rad\nz_median_1 =  64.63941828855289  \u00b5m\nz_max_1    =  132.82804180903605  \u00b5m\nz_median_2 =  96.0353967585784  \u00b5m\nz_max_2    =  37.229680208617246  \u00b5m\nz_median_3 =  33.09137450249458  \u00b5m\nz_max_3    =  93.7017772103181  \u00b5m\nz_median_4 =  163.029855309319  \u00b5m\nz_max_4    =  160.06562042963864  \u00b5m\n</code></pre> <p>Again, our model parameters are in the same region as the previous solution. The predicted vs true tip deflections are shown in Figure 5 below. Each probe's fit is drawn on a different tab.</p> Probe 1 fitProbe 2 fitProbe 3 fitProbe 4 fit <p> Reset Zoom </p> <p> Reset Zoom </p> <p> Reset Zoom </p> <p> Reset Zoom </p> Figure 5: The improved SDoF fit method's predicted tip deflections vs the corrected measured tip deflections for each probe.    <p>We are happy with the fit for each probe. Our model parameters did not change much from the single probe case. This is exactly what we want to see. A model should be able to fit multiple probes with the same parameters.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#estimating-the-eo","title":"Estimating the EO","text":"<p>Until this point, we have assumed the EO=8. The optimization algorithm will, however, converge to a solution regardless of our choice for EO. Which EO is the correct one?</p> <p>We can simply repeat the above exercise for multiple EOs and compare the objective function errors. The EO that results in the lowest error value is most likely the correct one.</p> <p>The code below shows us how to do this:</p> <pre><code>PROBE_COUNT = 4\nEOs = np.arange(1,17)\nEO_solutions = []\n\nfor EO in EOs:\n    print(\"NOW SOLVING FOR EO = \", EO)\n    omega_n_min = df_resonance_window[\"Omega\"].min() * EO\n    omega_n_max = df_resonance_window[\"Omega\"].max() * EO\n    ln_zeta_min = np.log(0.0001)\n    ln_zeta_max = np.log(0.3)\n    delta_st_min = 0\n    delta_st_max = 10\n    phi_0_min = 0\n    phi_0_max = 2*np.pi\n    bounds = [\n        (omega_n_min, omega_n_max),\n        (ln_zeta_min, ln_zeta_max),\n        (delta_st_min, delta_st_max),\n        (phi_0_min, phi_0_max),\n    ]\n    tip_deflections_set = []\n    theta_sensor_set = []\n    for i_probe in range(PROBE_COUNT):\n        z_max = df_resonance_window[f\"x_p{i_probe+1}_filt\"].abs().max()\n        z_min = -z_max\n        bounds.extend(\n            [\n                (z_min, z_max),\n                (z_min, z_max)\n            ]\n        )\n        tip_deflections_set.append(\n            df_resonance_window[f\"x_p{i_probe+1}_filt\"].values\n        )\n        theta_sensor_set.append(\n            df_resonance_window[f\"AoA_p{i_probe+1}\"].median()\n        )\n\n    multiple_probes_solution = differential_evolution(\n        func = SDoF_loss_multiple_probes,\n        bounds=bounds,\n        args=(\n            tip_deflections_set,\n            df_resonance_window['Omega'].values,\n            EO,\n            theta_sensor_set\n        ),\n        seed=42\n    )\n    EO_solutions.append(multiple_probes_solution)\n</code></pre> <p>This loop takes approximately 1 minute and 30 seconds to run on my laptop. The optimal solution error function value for each EO can be accessed in the <code>.fun</code> attribute of each solution. </p> Reset Zoom Figure 6: The objective function value for each EO.    <p>From Figure 6 above, our initial guess was correct \ud83d\udcaa! The optimal solution errors for each EO decreases gradually as we approach EO=8. EO=8 exhibits the smallest value. It is therefore reasonable to assume the true EO of vibration is 8.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#conclusion","title":"Conclusion","text":"<p>We've come a long way in this chapter. We've learned how to fit the SDoF fit parameters to BTT probe data with a global optimization function. We've also learned how to combine the data from multiple probes to get a more robust estimate of the model parameters.</p> <p>But what's even more remarkable is how well our simple model works. With just four parameters, we can capture the vibration of the blade tip over multiple revolutions with high accuracy.</p> <p>In the next and final chapter, we'll explore another way to infer the vibration parameters. This method, however, can be solved using linear algebra. It makes the solution faster and therefore more suitable for real-time analysis.</p> <p>Outcomes</p> <p> Understand why we require an optimization function to determine the model parameters of the SDoF fit method.</p> <p> Understand why we need to specify upper and lower bounds for the model parameters.</p> <p> Understand why the SDoF model, in its raw form, is not adequate. We need to add phase and amplitude offsets to the objective function.</p> <p> Understand how we can loop over each probe's data to fit the SDoF model to multiple probes.</p> <p> Understand why the EO is treated differently than the other model parameters. Because the EO can only be a positive integer, we iterate over the EOs to identify the optimal EO.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to Justin Smith and Alex Brocco for reviewing this chapter and providing feedback.</p> <p> Dawie Diamond </p> <p>             2024-03-19         </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#coding-exercises","title":"Coding exercises","text":"","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#1-getting-the-amplitude-larger","title":"1. Getting the amplitude larger","text":"<p>We've seen throughout this chapter that our model's amplitude is not quite right. It's too low.</p> <p> Why do you think the amplitude is constantly too low?</p> <p>Can you write a new objective function that produces a larger \\(\\delta_{st}\\)?</p> Reveal answer (Please try it yourself before revealing the solution) <pre><code>def SDoF_loss_multiple_probes(\n        model_params : np.ndarray,\n        tip_deflections_set : List[np.ndarray],\n        arr_omega : np.ndarray, \n        EO : int, \n        theta_sensor_set : List[float],\n        amplitude_scaling_factor : float = 1 #(1)!\n    ) -&gt; np.ndarray:\n    \"\"\" This function fits the SDoF parameters to \n        multiple probes' data.\n\n    Args:\n        model_params (np.ndarray): The SDoF fit method's model parameters. It\n            includes a list of the following parameters:\n\n            omega_n (float): The natural frequency of the SDoF system.\n            ln_zeta (float): The damping ratio of the SDoF system.\n            delta_st (float): The static deflection of the SDoF system.\n            phi_0 (float): The phase offset of the SDoF system.\n            And then the z_median and z_max for each probe.\n                z_median (float): The amplitude offset at the \n                    median shaft speed.\n                z_max (float): The maximum amplitude offset.\n\n        tip_deflections_set (List[np.ndarray]): The tip deflection data for each probe.\n        arr_omega (np.ndarray): The angular velocity of the rotor corresponding\n            to the tip deflection data.\n        EO (int): The EO of vibration you want to fit.\n        theta_sensor_set (List[float]): Each sensor's angular position \n            relative to the start of the revolution.\n        amplitude_scaling_factor (float, optional): A scaling factor to\n            weight the measured tip deflections. Defaults to 1. Use this value\n            to reward solutions that better capture the full amplitude of the\n            tip deflections.\n\n    Returns:\n        np.ndarray: The sum of squared error between \n            the tip deflection data of each probe and\n            the predicted tip deflections.\n    \"\"\"\n    omega_n, ln_zeta, delta_st, phi_0, *correction_factors = model_params\n    zeta = np.exp(ln_zeta)\n    probe_count = len(tip_deflections_set)\n    error = 0\n    for i_probe, arr_tip_deflections in enumerate(tip_deflections_set):    \n        theta_sensor = theta_sensor_set[i_probe]\n        predicted_tip_deflections = predict_sdof_samples(\n            omega_n, zeta, delta_st, EO, theta_sensor, phi_0, arr_omega\n        )\n        z_median = correction_factors[i_probe*2]\n        z_max = correction_factors[i_probe*2+1]\n        arr_tip_deflection_corrections = get_correction_values(\n            arr_omega, z_median, z_max\n        )\n        arr_tip_deflections_corrected = (\n            arr_tip_deflections\n            + arr_tip_deflection_corrections\n        )\n        error += np.sum(\n            np.abs(arr_tip_deflections_corrected)**amplitude_scaling_factor #(2)!\n            *(\n                arr_tip_deflections_corrected\n                - predicted_tip_deflections\n            )**2\n        )\n    return error\n</code></pre> <ol> <li>This is a new parameter.</li> <li>We use the new parameter to scale the error values according to the absolute size of the measured tip deflections. This rewards solutions that better capture the full amplitude of the tip deflections.</li> </ol> <p>Usage example:</p> <pre><code>PROBE_COUNT = 4\nEO = 8\n\nomega_n_min = df_resonance_window[\"Omega\"].min() * EO\nomega_n_max = df_resonance_window[\"Omega\"].max() * EO\nln_zeta_min = np.log(0.0001)\nln_zeta_max = np.log(0.3)\ndelta_st_min = 0\ndelta_st_max = 10\nphi_0_min = 0\nphi_0_max = 2*np.pi\n\nbounds = [\n    (omega_n_min, omega_n_max),\n    (ln_zeta_min, ln_zeta_max),\n    (delta_st_min, delta_st_max),\n    (phi_0_min, phi_0_max),\n]\ntip_deflections_set = []\ntheta_sensor_set = []\nfor i_probe in range(PROBE_COUNT):\n    z_max = df_resonance_window[f\"x_p{i_probe+1}_filt\"].abs().max()\n    z_min = -z_max\n    bounds.extend(\n        [\n            (z_min, z_max),\n            (z_min, z_max)\n        ]\n    )\n    tip_deflections_set.append(\n        df_resonance_window[f\"x_p{i_probe+1}_filt\"].values\n    )\n    theta_sensor_set.append(\n        df_resonance_window[f\"AoA_p{i_probe+1}\"].median()\n    )\n\nmultiple_probes_solution = differential_evolution(\n    func = SDoF_loss_multiple_probes,\n    bounds=bounds,\n    args=(\n        tip_deflections_set,\n        df_resonance_window['Omega'].values,\n        EO,\n        theta_sensor_set,\n        2 #(1)!\n    ),\n    seed=42\n)\n</code></pre> <ol> <li>We set the <code>amplitude_scaling_factor</code> to 2. This means the error will be scaled by the square of the absolute value of the measured tip deflections. This rewards solutions that better capture the full amplitude of the tip deflections.</li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#2-writing-a-function-we-can-use","title":"2. Writing a function we can use","text":"<p>We've covered a lot of ground in this chapter. Let's write a main entrypoint that performs the SDoF fit given a minimum number of arguments.</p> <p> Write a function, called, <code>perform_SDoF_fit</code>, receiving the following three required arguments:</p> <ol> <li>The blade tip deflection DataFrame, <code>df_blade</code>.</li> <li>The revolution number indicating the start of the resonance, <code>n_start</code>.</li> <li>The revolution number indicating the end of the resonance, <code>n_end</code>.</li> </ol> <p>The function should return the following values:</p> <ol> <li>The optimal solution, i.e. \\(\\omega_n\\), \\(\\zeta\\), \\(\\delta_{st}\\), and \\(\\phi_0\\)</li> <li>The EO of vibration.</li> </ol> <p>You may optionally accept other parameters to make the function more flexible.</p> Reveal answer (Please try it yourself before revealing the solution) <pre><code>def perform_SDoF_fit(\n    df_blade : pd.DataFrame,\n    n_start : int,\n    n_end : int,\n    EOs : List[int] = np.arange(1, 20),\n    delta_st_max : int = 10,\n    verbose : bool = False\n) -&gt; Dict[str, float]:\n    \"\"\"This function receives a blade tip deflection DataFrame, and returns \n    the SDoF fit model parameters after fitting.\n\n    Args:\n        df_blade (pd.DataFrame): The blade tip deflection DataFrame.\n        n_start (int): The starting revolution number of the resonance \n            you want to fit.\n        n_end (int): The ending revolution number of the resonance \n            you want to fit.\n        EOs (List[int], optional): The list of EOs to search for. Defaults \n            to np.arange(1, 20).\n        delta_st_max (int, optional): The maximum static deflection within our optimization \n            bounds. Defaults to 10.\n        verbose (bool, optional): Whether to print the progress. Defaults to False.\n\n    Returns:\n        Dict[str, float]: The fitted model parameters.\n    \"\"\"\n    df_resonance_window = df_blade.query(f\"n &gt;= {n_start} and n &lt;= {n_end}\")\n    measured_tip_deflection_signals = [\n        col \n        for col in df_resonance_window\n        if col.endswith(\"_filt\")\n    ]\n    PROBE_COUNT = len(measured_tip_deflection_signals)\n    eo_solutions = []\n    for EO in EOs:\n        if verbose:\n            print(\"NOW SOLVING FOR EO = \", EO, \" of \", EOs)\n        omega_n_min = df_resonance_window[\"Omega\"].min() * EO\n        omega_n_max = df_resonance_window[\"Omega\"].max() * EO\n        ln_zeta_min = np.log(0.0001)\n        ln_zeta_max = np.log(0.3)\n        delta_st_min = 0\n        phi_0_min = 0\n        phi_0_max = 2*np.pi\n        bounds = [\n            (omega_n_min, omega_n_max),\n            (ln_zeta_min, ln_zeta_max),\n            (delta_st_min, delta_st_max),\n            (phi_0_min, phi_0_max),\n        ]\n        tip_deflections_set = []\n        theta_sensor_set = []\n        for i_probe in range(PROBE_COUNT):\n            z_max = df_resonance_window[f\"x_p{i_probe+1}_filt\"].abs().max()\n            z_min = -z_max\n            bounds.extend(\n                [\n                    (z_min, z_max),\n                    (z_min, z_max)\n                ]\n            )\n            tip_deflections_set.append(\n                df_resonance_window[f\"x_p{i_probe+1}_filt\"].values\n            )\n            theta_sensor_set.append(\n                df_resonance_window[f\"AoA_p{i_probe+1}\"].median()\n            )\n        multiple_probes_solution = differential_evolution(\n            func = SDoF_loss_multiple_probes,\n            bounds=bounds,\n            args=(\n                tip_deflections_set,\n                df_resonance_window['Omega'].values,\n                EO,\n                theta_sensor_set,\n                2\n            ),\n            seed=42\n        )\n        eo_solutions.append(multiple_probes_solution)\n    best_EO_arg = np.argmin([solution.fun for solution in eo_solutions])\n    best_EO = EOs[best_EO_arg]\n    best_solution = eo_solutions[best_EO_arg]\n    return {\n        \"omega_n\" : best_solution.x[0] / (2*np.pi),\n        \"zeta\" : np.exp(best_solution.x[1]),\n        \"delta_st\" : best_solution.x[2],\n        \"phi_0\" : best_solution.x[3],\n        \"EO\" : best_EO,\n    }\n</code></pre> <p>Usage example:</p> <pre><code>&gt;&gt;&gt; SDoF_fit_parameters = perform_SDoF_fit(\n    tip_deflection_dfs[0],\n    n_start = 500,\n    n_end = 600\n)\n</code></pre>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch8/#3-comparing-resonances-on-the-upward-and-downward-ramps","title":"3. Comparing resonances on the upward and downward ramps","text":"<p>Throughout this chapter, we've focused on the EO=8 resonance on the ramp-up. We also have an EO=8 resonance on the ramp-down. Since nothing changed in the setup between the two resonances, we would expect the model parameters to be the same for both resonances.</p> <p> Analyze the resonance on the downward ramp and compare the model parameters to the upward ramp.</p> <p>Do the results make sense?</p> Reveal answer (Please try it yourself before revealing the solution) <p>This is something you can do yourself. You're welcome to email me your results if you want me to check it.</p> <ol> <li> <p>Zablotskiy, I.Y., Korostelev, Y.A., 1978. Measurement of resonance vibrations of turbine blades with the ELURA device. Foreign Technology Div Wright-Patterson AFB OH.\u00a0\u21a9\u21a9</p> </li> <li> <p>Box, G.E., 1979. Robustness in the strategy of scientific model building, in: Robustness in Statistics. Elsevier, pp. 201--236.\u00a0\u21a9</p> </li> <li> <p>Rao, S., 2003. Machanical vibrations. Pearson Education India.\u00a0\u21a9</p> </li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/","title":"9. Circumferential Fourier Fit (CFF) Method","text":"You are here","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#circumferential-fourier-fit-cff-method","title":"Circumferential Fourier Fit (CFF) Method","text":"<p>At the start of the tutorial, I promised you would learn how to infer blade frequency, amplitude, and phase from raw time stamps. In the previous chapter, we used the SDoF fit method to achieve this goal. The SDoF fit method is physics-based: it is derived from the Equations of Motion (EoM) of a harmonic oscillator. </p> <p>Let's solve the problem again, but from a different angle. It's often a good idea to use two different techniques to reach the same destination. This solidifies our understanding of the problem and the solution.</p> <p>The SDoF fit method, however powerful it may be, has a dark side: it is slow. </p> <p>It takes ~8 seconds to solve the equations for a single resonance. This might not seem like much, but when we have many blades and resonances to analyze, it becomes impractically slow. </p> <p>For real time analysis, we need a faster way to estimate the vibration parameters. That's where the Circumferential Fourier Fit (CFF) method comes in. The CFF method is a phenomenological model. A phenomenological model is only concerned with fitting the measured data well, not with being consistent with the underlying physics. We use phenomenological models all the time. The entire discipline of Machine Learning(ML) is built around them.</p> <p>In its most basic form, it fits a sinusoidal function to the measured data with three coefficients: \\(A\\), \\(B\\), and \\(C\\). The CFF method was first named as such, to my best knowledge, in (Joung et al., 2006)<sup>1</sup>.</p> <p> </p> Figure 1:     An animation of how the CFF method fits one sinusoid to each revolution's data.    <p>Outcomes</p> <p> Understand that the CFF method is a phenomenological model that fits a sinusoidal function to each revolution of the blade vibration.</p> <p> Construct the CFF equations.</p> <p> Compare results from the CFF and SDoF fit methods.</p> <p> Evaluate several candidate EOs to identify the most likely EO.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#derivation","title":"Derivation","text":"<p>The CFF method and the SDoF method share a common trait. Both assume the blade tip exhibits sinusoidal vibration. The CFF method, however, completely ignores the modal properties, \\(\\omega_n\\), \\(\\delta_{\\text{st}}\\), \\(\\zeta\\), and \\(\\phi_0\\). </p> <p>The CFF method calculates the vibration amplitude and phase directly for each shaft revolution. This results in linear equations, instead of the highly non-linear equations we had with the SDoF fit method.</p> <p>The tip vibration within every shaft revolution is expressed as follows:</p> <p></p> \\[\\begin{equation} x(\\theta_s) = A \\sin(\\theta_s \\cdot EO) + B \\cos(\\theta_s \\cdot EO) + C \\end{equation}\\] Symbols Symbol Description Unit Domain \\(x(\\theta_s)\\) The tip deflection at the sensor located at \\(\\theta_s\\) \u00b5m \\(x(\\theta_s) \\in \\mathbb{R}\\) \\(\\theta_s\\) The angular position of sensor \\(s\\) rad \\(0 \\leq \\theta_s \\leq 2\\pi\\) \\(A\\) The amplitude of the sine term \u00b5m \\(A \\in \\mathbb{R}\\) \\(B\\) The amplitude of the cosine term \u00b5m \\(B \\in \\mathbb{R}\\) \\(C\\) The offset of the tip deflection \u00b5m \\(C \\in \\mathbb{R}\\) <p>We can write Equation 1 for each sensor. This leads to a system of equations:</p> <p></p> \\[\\begin{align} x(\\theta_1) &amp;= A \\sin(\\theta_1 \\cdot EO) + B \\cos(\\theta_1 \\cdot EO) + C \\\\ x(\\theta_2) &amp;= A \\sin(\\theta_2 \\cdot EO) + B \\cos(\\theta_2 \\cdot EO) + C \\\\ &amp;\\vdots \\\\ x(\\theta_n) &amp;= A \\sin(\\theta_n \\cdot EO) + B \\cos(\\theta_n \\cdot EO) + C \\end{align}\\] <p>\\(\\theta_1\\) represents the position of probe 1, \\(\\theta_2\\) represents the position of probe 2, and so on. The variable \\(n\\) represents the number of probes.</p> <p>This system can be written in matrix form as follows:</p> <p></p> \\[\\begin{equation} \\begin{bmatrix} x(\\theta_1) \\\\ x(\\theta_2) \\\\ \\vdots \\\\ x(\\theta_n) \\end{bmatrix} = \\begin{bmatrix} \\sin(\\theta_1 \\cdot EO) &amp; \\cos(\\theta_1 \\cdot EO) &amp; 1 \\\\ \\sin(\\theta_2 \\cdot EO) &amp; \\cos(\\theta_2 \\cdot EO) &amp; 1 \\\\ \\vdots &amp; \\vdots &amp; \\vdots \\\\ \\sin(\\theta_n \\cdot EO) &amp; \\cos(\\theta_n \\cdot EO) &amp; 1 \\end{bmatrix} \\begin{bmatrix} A \\\\ B \\\\ C \\end{bmatrix} \\end{equation}\\] <p>We finally represent the system in a more compact form:</p> <p></p> \\[\\begin{equation} \\mathbf{x} = \\mathbf{A} \\mathbf{b} \\end{equation}\\] Symbols Symbol Description Unit Domain \\(\\mathbf{x}\\) The vector of tip deflections at each sensor mm \\(\\mathbf{x} \\in \\mathbb{R}^n\\) \\(\\mathbf{A}\\) The matrix of the sine and cosine terms mm \\(\\mathbf{A} \\in \\mathbb{R}^{n \\times 3}\\) \\(\\mathbf{b}\\) The vector of the vibration parameters mm \\(\\mathbf{b} \\in \\mathbb{R}^3\\) <p>We have now rephrased the problem as a linear algebra problem where we want to solve for \\(\\mathbf{b}\\). </p> <p>Once solved, we can calculate the amplitude and phase of the vibration within each revolution using:</p> <p></p> \\[\\begin{equation} X = \\sqrt{A^2 + B^2} \\end{equation}\\] <p></p> \\[\\begin{equation} \\phi = \\arctan \\left( \\frac{A}{B} \\right) \\end{equation}\\] <p>The phase and amplitude can now be used to calculate the tip deflections:</p> <p></p> \\[\\begin{equation} x(\\theta_s) = X \\cos(\\theta_s \\cdot EO - \\phi) + C \\end{equation}\\] <p>The above equation has exactly the same form as the SDoF fit method, only with a constant amplitude and phase within each revolution. </p> SDoF fit equations <p>For comparison, here are the SDoF fit equations again:</p> \\[\\begin{equation} x(t) = X(\\omega) \\cos \\left( \\theta_s \\cdot EO - \\phi(\\omega) \\right) \\end{equation}\\] \\[\\begin{equation} X(\\omega) = \\frac{\\delta_{\\text{st}}}{ \\sqrt{ (1 - r^2)^2 + (2 \\zeta r)^2 } }\\\\ \\end{equation}\\] \\[\\begin{equation} \\phi(\\omega) = \\arctan \\left( \\frac{2 \\zeta r}{1 - r^2} \\right)\\\\ \\end{equation}\\] \\[\\begin{equation} r = \\frac{\\omega}{\\omega_n} \\end{equation}\\] Symbol Meaning SI Unit Domain \\(x(t)\\) Tip deflection \\(\\mu m\\) \\(\\mathbb{R}\\) \\(X(\\omega)\\) Vibration amplitude \\(\\mu m\\) \\(\\mathbb{R}+\\) \\(\\delta_{\\text{st}}\\) Static deflection \\(\\mu m\\) \\(\\mathbb{R}+\\) \\(\\zeta\\) Damping ratio - \\([0,1)\\) for underdamped systems \\(\\omega_n\\) Natural frequency \\(rad/s\\) or Hz \\(\\mathbb{R}+\\) \\(\\theta_s\\) Sensor position \\(rad\\) \\([0, 2\\pi]\\) \\(\\phi(\\omega)\\) Phase angle \\(rad\\) \\(\\mathbb{R}\\) \\(\\omega\\) Excitation frequency \\(rad/s\\) or Hz \\(\\mathbb{R}+\\) \\(EO\\) Engine Order - \\(\\mathbb{Z}+\\) <p>What's the difference between Equation 10 and Equation 11? </p> <p>The substantial difference between them is the SDoF fit method's \\(X\\) and \\(\\phi\\) is a function of the excitation frequency, \\(\\omega\\). The CFF method's \\(X\\) and \\(\\phi\\) are constant scalar variables within each revolution.</p> <p>Amplitude offset</p> <p>The amplitude offset term, \\(C\\), is generally kept as a part of the CFF model parameters. This stands in contrast to the SDoF fit method, where the correction factors are subtracted from the measured tip deflections before fitting the model.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#following-along","title":"Following along","text":"<p>The worksheet for this chapter can be downloaded here .</p> <p>You can open a Google Colab session of the worksheet here: .</p> <p>You need to use one of the following Python versions to run the worksheet:  </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#getting-the-dataset","title":"Getting the dataset","text":"<p>To see the CFF method in action, we will use the same dataset as used in the previous chapter. This way, we can compare the results from the CFF and SDoF fit methods. The dataset contains blade tip displacements measured by four sensors for a run-up and a run-down.</p> <pre><code>ds = Datasets[\"data/intro_to_btt/intro_to_btt_ch05\"]\ndf_opr_zero_crossings = ds['table/opr_zero_crossings']\ndf_prox_1 = ds['table/prox_1_toas']\ndf_prox_2 = ds['table/prox_2_toas']\ndf_prox_3 = ds['table/prox_3_toas']\ndf_prox_4 = ds['table/prox_4_toas']\n\nBLADE_COUNT = 5\nRADIUS = 164000\n\nrotor_blade_AoA_dfs = get_rotor_blade_AoAs(\n    df_opr_zero_crossings,\n    [df_prox_1, df_prox_2, df_prox_3, df_prox_4],\n    np.cumsum(np.deg2rad(np.array([19.34, 19.34, 19.34]))),\n    BLADE_COUNT\n)\ntip_deflection_dfs = []\nfor df_AoAs in rotor_blade_AoA_dfs:\n    df_tip_deflections = get_blade_tip_deflections_from_AoAs(\n        df_AoAs,\n        RADIUS,\n        11,\n        2,\n        0.5\n    )\n    tip_deflection_dfs.append(df_tip_deflections)\ndf_resonance_window = tip_deflection_dfs[0].query(\"n &gt;= 500 and n &lt;= 600\")\nEO = 8\n</code></pre>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#single-revolution-case","title":"Single Revolution Case","text":"<p>The simplest implementation of the CFF method is given below:</p> <pre><code>def cff_method_single_revolution(\n    df_blade : pd.DataFrame,\n    theta_sensor_set : List[float],\n    EO : int,\n    signal_suffix : str = \"_filt\" #(1)!\n) -&gt; pd.DataFrame: #(2)!\n    PROBE_COUNT = len(theta_sensor_set)\n    tip_deflection_signals = [#(3)!\n        f\"x_p{i_probe + 1}{signal_suffix}\" \n        for i_probe in range(PROBE_COUNT)\n    ]\n    theta_sensors = np.array(theta_sensor_set)\n    A = np.ones((PROBE_COUNT, 3))#(4)!\n    A[:, 0] = np.sin(theta_sensors * EO)\n    A[:, 1] = np.cos(theta_sensors * EO)#(5)!\n\n    A_pinv = np.linalg.pinv(A) #(6)!\n    B = A_pinv.dot(\n        df_blade.loc[:, tip_deflection_signals].values.T\n    ) #(7)!\n    df_cff = pd.DataFrame(B.T, columns=[\"A\", \"B\", \"C\"]) #(8)!\n    df_cff[\"X\"] = np.sqrt(df_cff[\"A\"]**2 + df_cff[\"B\"]**2)\n    df_cff[\"phi\"] = np.arctan2(df_cff[\"A\"], df_cff[\"B\"])\n    df_cff[\"n\"] = df_blade[\"n\"].values\n    df_predicted_targets = pd.DataFrame(\n        A.dot(B).T, \n        columns=[\n            col + \"_pred\" \n            for col \n            in tip_deflection_signals\n        ]\n    ) #(9)!\n    df_cff = pd.concat([df_cff, df_predicted_targets], axis=1)\n    return df_cff\n</code></pre> <ol> <li>Here, we specify the suffix of the tip deflection signals. We'll leave this as the default <code>\"_filt\"</code> most of the time. We may, however, set this to <code>\"\"</code> in order to fit the CFF method on the unfiltered tip deflections.</li> <li> <p>This function fits the CFF method for a resonance. The model parameters, \\(A\\), \\(B\\), and \\(C\\) are solved for each revolution of data.</p> <p>Args:</p> <pre><code>df_blade (pd.DataFrame): The dataframe containing the tip deflections.\n\ntheta_sensor_set (List[float]): The sensor angles.\n\nEO (int): The Engine Order.\n\nsignal_suffix (str, optional): The suffix of the tip deflection \n    signals. Defaults to \"_filt\".\n</code></pre> <p>Returns:</p> <pre><code>pd.DataFrame: A DataFrame containing the CFF parameters for \n    each shaft revolution.\n</code></pre> </li> <li> <p>We identify the names of the columns containing the tip deflections. This list is also used to determine how many probes were used for the present dataset.</p> </li> <li>We initialize the matrix \\(\\mathbf{A}\\), which contain each sensor's sine, cosine and constant term coefficients. We initialize it as a <code>PROBE_COUNT X 3</code> matrix of ones, since the constant term is one everywhere, and the other two columns will be assigned new values.</li> <li>We calculate and assign the sine and cosine coefficients for each sensor.</li> <li>Here, we calculate the pseudo inverse of <code>A</code>. The pseudo inverse is a matrix that, when multiplied with <code>A</code>, results in the identity matrix. We only do this once, since the matrix <code>A</code> is constant for each revolution.</li> <li>This line is the reason why the CFF method is so fast. Because our <code>A</code> matrix is constant for each revolution, we can simply multiply its pseudo-inverse with the transpose of the observed tip deflections. This results in the CFF parameters for each revolution.</li> <li>From here to the end, its all cosmetic. We create a dataframe containing the CFF parameters, the amplitude, phase, and the shaft revolution number.</li> <li>We calculate the predicted tip deflections with the CFF parameters. This is for convenience so we don't need to recalculate it later to check our fits.</li> </ol> <p>Here we implement the method:</p> <pre><code>%%timeit #(1)!\nPROBE_COUNT = 4\ndf_cff_params = cff_method_single_revolution(\n    df_resonance_window,\n    [\n        df_resonance_window[f\"AoA_p{i_probe + 1}\"].median()#(2)!\n        for i_probe in range(PROBE_COUNT)\n    ],\n    EO\n)\n</code></pre> <ol> <li>We use the <code>%%timeit</code> magic command to measure the execution time of the cell. This only works when you're in a Jupyter Notebook</li> <li>We use the median of the raw AoA values for the sensor location.</li> </ol> <p>The <code>%%timeit</code> command is something specific to Jupyter notebooks. It causes Python to run the entire cell multiple times. The mean execution time is reported after the final iteration. This is useful for benchmarking code. This call runs for a total of... 3 ms! Contrast this to the SDoF fit method, which took approximately 8 seconds. The CFF method is therefore  ~2666 times faster than the SDoF fit method. This is a massive speed up \u23e9!</p> <p>Faster speed is awesome, but is it accurate? Here's the predicted tip deflections vs the actual tip deflections:</p> Probe 1 fitProbe 2 fitProbe 3 fitProbe 4 fit <p> Reset Zoom </p> <p> Reset Zoom </p> <p> Reset Zoom </p> <p> Reset Zoom </p> Figure 2: The CFF predicted tip deflections vs the actual tip deflections for each probe. The CFF method is able to fit the tip deflections very well.    <p>Wow \ud83d\udc4f! The CFF predicted values and the measured values are almost on top of one another. </p> <p>Contrast this with the SDoF method where we didn't get such a good fit. What do we conclude from this? Is the CFF method better than the SDoF fit method?</p> <p>I don't think so. We have to remember the CFF method is phenomenological. It needs to fit 3 parameters to 4 measured values in each revolution. The odds are therefore stacked in its favor to fit the data well. In fact, the CFF method even fits the data well near the start of the resonance, where we mostly have noise. This should make us uneasy. If our model accurately reproduces noise, it means we are overfitting.</p> <p>Now for the big question: what is our natural frequency? The simple answer is we don't have one! The CFF method is not concerned with the underlying physics, so it doesn't have a natural frequency. We can, however, assume that the shaft speed where the amplitude reaches its peak is where the natural frequency is exactly excited.</p> <p>Let's compare the CFF amplitude and phase to the SDoF fit amplitude and phase for the same resonance:</p> AmplitudePhase <p> Reset Zoom </p> <p> Reset Zoom </p> Figure 3: The CFF method amplitude and phase vs the SDoF fit amplitude and phase for the same resonance. The maximum amplitude between the two methods differ by approximately 200 \u03bcm. The phase, at least in the resonance region, is basically identical.    <p>From Figure 3 above, the maximum amplitude of the CFF method occurs at revolution number 568. We can use the rotor speed in this resonance, multiplied by the EO, to get the CFF natural frequency:</p> <pre><code>&gt;&gt;&gt; omega_n_568 = df_resonance_window.query(\"n == 568\")[\"Omega\"].iloc[0]*EO\n&gt;&gt;&gt; omega_n_567 = df_resonance_window.query(\"n == 567\")[\"Omega\"].iloc[0]*EO\n&gt;&gt;&gt; print(\"CFF omega_n @ n=568: {:.3f} Hz\".format(omega_n_568 / (2*np.pi)))\n&gt;&gt;&gt; print(\"CFF omega_n @ n=567: {:.3f} Hz\".format(omega_n_567 / (2*np.pi)))\n&gt;&gt;&gt; print(\"SDoF omega_n       : {:.3f} Hz\".format(SDoF_params[\"omega_n\"]))\n</code></pre> <pre><code>CFF omega_n @ n=568: 126.565 Hz\nCFF omega_n @ n=567: 126.273 Hz\nSDoF omega_n       : 126.270 Hz\n</code></pre> <p>The CFF natural frequency at revolution 568 is 0.3 Hz higher than the SDoF natural frequency. This is a difference of 0.2%. I believe it is a small difference. The two methods seem to point to the same underlying physics. We also used the shaft speed at the previous revolution, n=567, to calculate the natural frequency. Now, the natural frequency is almost identical to the SDoF natural frequency.</p> <p>The CFF method's maximum amplitude is approximately 200 \u03bcm lower than the SDoF method's maximum amplitude. This difference is large, approximately 28%. It is possible the SDoF fit method may be overestimating the amplitude. If you did the coding exercise in the previous chapter, you would have implemented an SDoF fit method that rewards the ability to capture larger amplitudes.</p> <p>The phase plot suggests the two methods produce similar phase shifts where the amplitudes are largest. The CFF method produces larger phase shifts outside the resonance region.</p> <p>Which one of the two is more accurate? I don't know. More effort needs to be put in to compensate for the zeroing artifacts in the CFF method. The only real way to judge which one is better is to have calibrated strain gauge data available. This falls outside the scope of the present tutorial.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#estimate-the-eo","title":"Estimate the EO","text":"<p>The CFF method can fit the data well... as long as the correct EO is known beforehand. But what if we are not sure about the EO? How can we find out which one is the best for our data?</p> <p>We can repeat what we did in the previous chapter. We can try different EO values and calculate the sum of squared errors between the predicted and the measured tip deflections. The lower the error, the better the fit. So, we search for the EO that results in the lowest error value. That is likely to be the correct one for our data.</p> <p>The below code performs this calculation:</p> <pre><code>PROBE_COUNT = 4\nEOs = np.arange(1, 17)\nerrors = []\nfor EO in EOs:\n    df_cff_params = cff_method_single_revolution(\n        df_resonance_window,\n        [\n            df_resonance_window[f\"AoA_p{i_probe + 1}\"].median()\n            for i_probe in range(PROBE_COUNT)\n        ],\n        EO\n    )\n    error = 0\n    for i_probe in range(PROBE_COUNT):\n        error += np.sum(\n            (\n                df_cff_params[f\"x_p{i_probe+1}_filt_pred\"].values \n                - df_resonance_window[f\"x_p{i_probe+1}_filt\"].values\n            )**2\n        )\n    errors.append(error)\nprint(\"Most likely EO:\", EOs[np.argmin(errors)])\n</code></pre> <pre><code>Most likely EO: 8\n</code></pre> <p>The error values are plotted in Figure 4 below.</p> Reset Zoom Figure 4: The sum of squared errors between the predicted and measured tip deflections for each EO. EO=8 results in the lowest sum of squared error value.    <p>From Figure 4 above, the EO with the lowest error value is 8. This is the correct value. You may need to zoom in a bit, since the error values for EOs 8 - 11 are close to one another.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#conclusion","title":"Conclusion","text":"<p>In this chapter, we have shown how to apply the CFF method to a resonance event. The CFF method is a powerful tool to fit the blade tip deflection data with high accuracy. The CFF method can also be used to estimate the natural frequency and EO of vibration.</p> <p>The main benefit of the CFF method is its speed. The CFF method is, in its rawest form, approximately 2666 times faster than the SDoF fit method. You should therefore be able to use it in real-time.</p> <p>Outcomes</p> <p> Understand that the CFF method is a phenomenological model that fits a sinusoidal function to each revolution of the blade vibration.</p> <p> Construct the CFF equations.</p> <p> Compare results from the CFF and SDoF fit methods.</p> <p> Evaluate several candidate EOs to identify the most likely EO.</p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to Justin Smith and Alex Brocco for reviewing this chapter and providing feedback.</p> <p> Dawie Diamond </p> <p>             2024-03-26         </p>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#coding-exercises","title":"Coding exercises","text":"","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#1-multiple-revolution-case","title":"1. Multiple Revolution Case","text":"<p>Solving the CFF parameters on a per revolution basis is great, but it may be prone to noise and outliers. In our example above, we have 3 unknown parameters and only 4 measurements. The system may be overdetermined, but we'd ideally like to have even more measurements to increase robustness to noise.</p> <p>We can change the problem to allow the parameters \\(A\\), \\(B\\), and \\(C\\) are fit across multiple revolutions. This should increase the robustness of the fit.</p> <p> Write a new function, <code>cff_method_multiple_revolutions</code> that receives the following arguments:</p> <ol> <li><code>df_blade</code> : The DataFrame containing the tip deflections. </li> <li><code>theta_sensor_set</code> : The sensor angles.</li> <li><code>EO</code> : The Engine Order.</li> <li><code>extra_revolutions</code> : The number of revolutions before and after each \"center\" revolution to fit.</li> <li><code>signal_suffix</code> (str, optional): The suffix of the tip deflection signals. Defaults to \"_filt\". </li> </ol> <p>The function should fit the CFF parameters over <code>1 + 2*extra_revolutions</code> consecutive revolutions. In other words, we should still receive one CFF set of parameters per revolution, but the values of \\(A\\), \\(B\\), and \\(C\\) should be fit over 1 + 2*extra_revolutions revolutions.</p> Reveal answer (Please try it yourself before revealing the solution) <pre><code>def cff_method_multiple_revolutions(\n    df_blade : pd.DataFrame,\n    theta_sensor_set : List[float],\n    EO : int,\n    extra_revolutions : int,\n    signal_suffix : str = \"_filt\" \n) -&gt; pd.DataFrame:\n    \"\"\" This function fits the CFF method for a resonance by\n    using multiple revolutions of data for each set of CFF parameters.\n\n    Args:\n        df_blade (pd.DataFrame): The dataframe containing the tip deflections.\n        theta_sensor_set (List[float]): The sensor angles.\n        EO (int): The Engine Order.\n        extra_revolutions (int): The number of revolutions to use for the fit.\n        signal_suffix (str, optional): The suffix of the tip deflection \n            signals. Defaults to \"_filt\".\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the CFF parameters for \n            each shaft revolution.\n    \"\"\"\n    PROBE_COUNT = len(theta_sensor_set)\n    tip_deflection_signals = [\n        f\"x_p{i_probe + 1}{signal_suffix}\" \n        for i_probe in range(PROBE_COUNT)\n    ]\n    theta_sensors = np.array(theta_sensor_set)\n\n    A = np.ones((PROBE_COUNT*(2*extra_revolutions+1), 3))\n    arr_multiple_thetas = np.array(\n        list(theta_sensors)*(2*extra_revolutions+1)\n    )\n    A[:, 0] = np.sin(arr_multiple_thetas * EO)\n    A[:, 1] = np.cos(arr_multiple_thetas * EO)\n    A_pinv = np.linalg.pinv(A)\n    new_obs_rows = df_blade.shape[0] - 2*extra_revolutions\n    X_multiple_revos = np.zeros(\n        (\n            new_obs_rows, \n            PROBE_COUNT*(2*extra_revolutions+1)\n        )\n    )\n    for n_revo in range(-extra_revolutions, extra_revolutions+1):\n        for i_probe in range(PROBE_COUNT):\n            mat_aoas_start = extra_revolutions + n_revo\n            mat_aoas_end = mat_aoas_start + new_obs_rows\n            i_col = i_probe + n_revo*PROBE_COUNT + extra_revolutions*PROBE_COUNT\n            X_multiple_revos[:,i_col] = (\n                df_blade.iloc[mat_aoas_start:mat_aoas_end][tip_deflection_signals[i_probe]]\n            )\n    B = A_pinv.dot(X_multiple_revos.T)\n    B_full = np.zeros((df_blade.shape[0], 3))\n    B_full[extra_revolutions:-extra_revolutions, :] = B.T\n    B_full[:extra_revolutions, :] = B_full[extra_revolutions, :]\n    B_full[-extra_revolutions:, :] = B_full[-extra_revolutions-1, :]\n\n    df_cff = pd.DataFrame(B_full, columns=[\"A\", \"B\", \"C\"])\n    df_cff[\"X\"] = np.sqrt(df_cff[\"A\"]**2 + df_cff[\"B\"]**2)\n    df_cff[\"phi\"] = np.arctan2(df_cff[\"A\"], df_cff[\"B\"])\n    df_cff[\"n\"] = df_blade[\"n\"].values\n    target_matrix = (A.dot(B_full.T)).T\n    predicted_deflections = target_matrix[:, extra_revolutions*PROBE_COUNT:(extra_revolutions+1)*PROBE_COUNT] \n    df_predicted_targets = pd.DataFrame(\n        predicted_deflections, \n        columns=[\n            col + \"_pred\" \n            for col \n            in tip_deflection_signals\n        ]\n    )\n    df_cff = pd.concat([df_cff, df_predicted_targets], axis=1)\n    return df_cff\n</code></pre> <p>Usage example:</p> <pre><code>&gt;&gt;&gt; df_cff_params = cff_method_multiple_revolutions(\n    df_resonance_window,\n    [\n        df_resonance_window[f\"AoA_p{i_probe + 1}\"].median()\n        for i_probe in range(PROBE_COUNT)\n    ],\n    EO,\n    2\n)\n</code></pre>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/intro_to_btt/ch9/#2-writing-a-function-we-can-use","title":"2. Writing a function we can use","text":"<p>Were now going to write a single entrypoint, receiving the minimum amount of arguments, to fit the CFF method and estimate the EO. This will make it easier to use the CFF method in the future.</p> <p> Write a function, called, <code>perform_CFF_fit</code>, receiving the following three required arguments:</p> <ol> <li>The blade tip deflection DataFrame, <code>df_blade</code>.</li> <li>The revolution number indicating the start of the resonance, <code>n_start</code>.</li> <li>The revolution number indicating the end of the resonance, <code>n_end</code>.</li> </ol> <p>The function should return the following values:</p> <ol> <li>The CFF parameters for each revolution.</li> <li>The EO of vibration.</li> </ol> <p>You may optionally accept other parameters to make the function more flexible.</p> Reveal answer (Please try it yourself before revealing the solution) <pre><code>def perform_CFF_fit(\n    df_blade : pd.DataFrame,\n    n_start : int,\n    n_end : int,\n    EOs : List[int] = np.arange(1, 20),\n    extra_revolutions : int = 1\n) -&gt; Dict[str, Union[pd.DataFrame, int]]:\n    \"\"\" This function performs the CFF method fit for a resonance. The function\n    iterates over EOs and selects the EO that gives the lowest sum of squared\n    errors between the measured and predicted tip deflections.\n\n    Args:\n        df_blade (pd.DataFrame): The dataframe containing the tip deflections.\n        n_start (int): The start revolution number.\n        n_end (int): The end revolution number.\n        EOs (List[int], optional): The EOs to consider for this resonance. Defaults \n            to np.arange(1, 20).\n        extra_revolutions (int, optional): How many extra revolutions to use for \n            the fit. Defaults to 1.\n\n    Returns:\n        Dict[str, Union[pd.DataFrame, int]]: A dictionary containing the CFF \n            parameters and the selected EO.\n    \"\"\"\n    PROBE_COUNT = len(\n        [\n            col \n            for col in df_blade.columns\n            if col.endswith(\"_filt\")\n        ]\n    )\n    theta_sensor_set = [\n        df_blade[f\"AoA_p{i_probe + 1}\"].median()\n        for i_probe in range(PROBE_COUNT)\n    ]\n    errors = []\n    df_resonance_window = df_blade.query(f\"n &gt;= {n_start} and n &lt;= {n_end}\")\n    for EO in EOs:\n        df_cff_params = cff_method_multiple_revolutions(\n            df_resonance_window,\n            theta_sensor_set,\n            EO,\n            extra_revolutions\n        )\n        error = 0\n        for i_probe in range(PROBE_COUNT):\n            error += np.sum(\n                (\n                    df_cff_params[f\"x_p{i_probe+1}_filt_pred\"].values \n                    - df_resonance_window[f\"x_p{i_probe+1}_filt\"].values\n                )**2\n            )\n        errors.append(error)\n    EO = EOs[np.argmin(errors)]\n    df_cff_params = cff_method_multiple_revolutions(\n        df_resonance_window,\n        theta_sensor_set,\n        EO,\n        extra_revolutions\n    )\n    return {\n        \"df_cff_params\" : df_cff_params,\n        \"EO\" : EO\n    }\n</code></pre> <p>Usage example:</p> <pre><code>cff_params = perform_CFF_fit(\n    tip_deflection_dfs[0],\n    500,\n    600\n)\n</code></pre> <ol> <li> <p>Joung, K.-K., Kang, S.-C., Paeng, K.-S., Park, N.-G., Choi, H.-J., You, Y.-J., Von Flotow, A., 2006. Analysis of vibration of the turbine blades using non-intrusive stress measurement system, in: Asme Power Conference. pp. 391--397.\u00a0\u21a9</p> </li> </ol>","tags":["Blade Tip Timing","BTT","Non Intrusive Stress Measurement","NSMS","Time of Arrival","Turbine blade","Mechanical Vibration"]},{"location":"tutorials/mpr_encoder_processing/ch1/","title":"Index","text":"<p>date: 2024-10-01 tags:   - Blade Tip Timing   - Instantaneous Angular Speed   - BTT   - Non Intrusive Stress Measurement   - NSMS   - Turbine blade   - Mechanical Vibration hide:   - tags description: This chapter explains the principle behind Multiple Pulses per Revolution shaft encoders  robots: index, follow, Blade Tip Timing, Instantaneous Angular Speed, BTT, Non Intrusive Stress Measurement, NSMS, Turbine blade,Mechanical Vibration template: main_intro_to_btt.html card_title: Intro to MPR encoder processing Ch1 - Incremental Encoders' fundamental principle card_url: \"ch1/\"</p>"}]}